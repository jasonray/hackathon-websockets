<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>HornetQ 2.1 User Manual</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e18"></a>HornetQ 2.1 User Manual</h1></div><div><h2 class="subtitle">Putting the buzz in messaging</h2></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#notice">1. Legal Notice</a></span></dt><dt><span class="chapter"><a href="#preface">2. Preface</a></span></dt><dt><span class="chapter"><a href="#project-info">3. Project Information</a></span></dt><dd><dl><dt><span class="section"><a href="#download.software">3.1. Software Download</a></span></dt><dt><span class="section"><a href="#download.svn">3.2. Project Information</a></span></dt></dl></dd><dt><span class="chapter"><a href="#messaging-concepts">4. Messaging Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e261">4.1. Messaging Concepts</a></span></dt><dt><span class="section"><a href="#d0e286">4.2. Messaging styles</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e300">4.2.1. The Message Queue Pattern</a></span></dt><dt><span class="section"><a href="#d0e320">4.2.2. The Publish-Subscribe Pattern</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e346">4.3. Delivery guarantees</a></span></dt><dt><span class="section"><a href="#d0e356">4.4. Transactions</a></span></dt><dt><span class="section"><a href="#d0e361">4.5. Durability</a></span></dt><dt><span class="section"><a href="#d0e366">4.6. Messaging APIs and protocols</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e377">4.6.1. Java Message Service (JMS)</a></span></dt><dt><span class="section"><a href="#d0e390">4.6.2. System specific APIs</a></span></dt><dt><span class="section"><a href="#d0e397">4.6.3. RESTful API</a></span></dt><dt><span class="section"><a href="#d0e412">4.6.4. STOMP</a></span></dt><dt><span class="section"><a href="#d0e423">4.6.5. AMQP</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e432">4.7. High Availability</a></span></dt><dt><span class="section"><a href="#d0e443">4.8. Clusters</a></span></dt><dt><span class="section"><a href="#d0e461">4.9. Bridges and routing</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">5. Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e500">5.1. Core Architecture</a></span></dt><dt><span class="section"><a href="#d0e543">5.2. HornetQ embedded in your own application</a></span></dt><dt><span class="section"><a href="#d0e552">5.3. HornetQ integrated with a JEE application server</a></span></dt><dt><span class="section"><a href="#d0e584">5.4. HornetQ stand-alone server</a></span></dt></dl></dd><dt><span class="chapter"><a href="#using-server">6. Using the Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e638">6.1. Starting and Stopping the standalone server</a></span></dt><dt><span class="section"><a href="#d0e690">6.2. Server JVM settings</a></span></dt><dt><span class="section"><a href="#d0e711">6.3. Server classpath</a></span></dt><dt><span class="section"><a href="#using-server.library.path">6.4. Library Path</a></span></dt><dt><span class="section"><a href="#d0e770">6.5. System properties</a></span></dt><dt><span class="section"><a href="#using-server.configuration">6.6. Configuration files</a></span></dt><dt><span class="section"><a href="#server.microcontainer.configuration">6.7. JBoss Microcontainer Beans File</a></span></dt><dt><span class="section"><a href="#server.microkernel.configuration">6.8. JBoss AS4 MBean Service.</a></span></dt><dt><span class="section"><a href="#usingserver.mainconfig">6.9. The main configuration file.</a></span></dt></dl></dd><dt><span class="chapter"><a href="#using-jms">7. Using JMS</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1032">7.1. A simple ordering system</a></span></dt><dt><span class="section"><a href="#using-jms.server.configuration">7.2. JMS Server Configuration</a></span></dt><dt><span class="section"><a href="#d0e1087">7.3. JNDI configuration</a></span></dt><dt><span class="section"><a href="#d0e1129">7.4. The code</a></span></dt><dt><span class="section"><a href="#d0e1186">7.5. Directly instantiating JMS Resources without using JNDI</a></span></dt><dt><span class="section"><a href="#using-jms.clientid">7.6. Setting The Client ID</a></span></dt><dt><span class="section"><a href="#using-jms.dupsokbatchsize">7.7. Setting The Batch Size for DUPS_OK </a></span></dt><dt><span class="section"><a href="#using-jms.txbatchsize">7.8. Setting The Transaction Batch Size</a></span></dt></dl></dd><dt><span class="chapter"><a href="#using-core">8. Using Core</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1294">8.1. Core Messaging Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1299">8.1.1. Message</a></span></dt><dt><span class="section"><a href="#d0e1336">8.1.2. Address</a></span></dt><dt><span class="section"><a href="#d0e1357">8.1.3. Queue</a></span></dt><dt><span class="section"><a href="#d0e1368">8.1.4. ClientSessionFactory</a></span></dt><dt><span class="section"><a href="#d0e1389">8.1.5. ClientSession</a></span></dt><dt><span class="section"><a href="#d0e1409">8.1.6. ClientConsumer</a></span></dt><dt><span class="section"><a href="#d0e1420">8.1.7. ClientProducer</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1441">8.2. A simple example of using Core</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jms-core-mapping">9. Mapping JMS Concepts to the Core API</a></span></dt><dt><span class="chapter"><a href="#client-classpath">10. The Client Classpath</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1519">10.1. HornetQ Core Client</a></span></dt><dt><span class="section"><a href="#d0e1538">10.2. JMS Client</a></span></dt><dt><span class="section"><a href="#d0e1565">10.3. JMS Client with JNDI</a></span></dt></dl></dd><dt><span class="chapter"><a href="#examples">11. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1602">11.1. JMS Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#application-level-failover">11.1.1. Application-Layer Failover</a></span></dt><dt><span class="section"><a href="#examples.bridge">11.1.2. Core Bridge Example</a></span></dt><dt><span class="section"><a href="#examples.browsers">11.1.3. Browser</a></span></dt><dt><span class="section"><a href="#d0e1663">11.1.4. Client Kickoff</a></span></dt><dt><span class="section"><a href="#d0e1671">11.1.5. Client-Side Load-Balancing</a></span></dt><dt><span class="section"><a href="#examples.clustered.grouping">11.1.6. Clustered Grouping</a></span></dt><dt><span class="section"><a href="#d0e1687">11.1.7. Clustered Queue</a></span></dt><dt><span class="section"><a href="#d0e1695">11.1.8. Clustered Standalone</a></span></dt><dt><span class="section"><a href="#d0e1703">11.1.9. Clustered Topic</a></span></dt><dt><span class="section"><a href="#examples.consumer-rate-limit">11.1.10. Message Consumer Rate Limiting</a></span></dt><dt><span class="section"><a href="#examples.dead-letter">11.1.11. Dead Letter</a></span></dt><dt><span class="section"><a href="#examples.delayed-redelivery">11.1.12. Delayed Redelivery</a></span></dt><dt><span class="section"><a href="#divert-example">11.1.13. Divert</a></span></dt><dt><span class="section"><a href="#d0e1745">11.1.14. Durable Subscription</a></span></dt><dt><span class="section"><a href="#d0e1755">11.1.15. Embedded</a></span></dt><dt><span class="section"><a href="#d0e1763">11.1.16. HTTP Transport</a></span></dt><dt><span class="section"><a href="#d0e1771">11.1.17. Instantiate JMS Objects Directly</a></span></dt><dt><span class="section"><a href="#examples.interceptor">11.1.18. Interceptor</a></span></dt><dt><span class="section"><a href="#examples.jaas">11.1.19. JAAS</a></span></dt><dt><span class="section"><a href="#examples.jms.jms-bridge">11.1.20. JMS Bridge</a></span></dt><dt><span class="section"><a href="#examples.jmx">11.1.21. JMX Management</a></span></dt><dt><span class="section"><a href="#examples.large-message">11.1.22. Large Message</a></span></dt><dt><span class="section"><a href="#examples.last-value-queue">11.1.23. Last-Value Queue</a></span></dt><dt><span class="section"><a href="#d0e1836">11.1.24. Load Balanced Clustered Queue</a></span></dt><dt><span class="section"><a href="#examples.management">11.1.25. Management</a></span></dt><dt><span class="section"><a href="#examples.management-notifications">11.1.26. Management Notification</a></span></dt><dt><span class="section"><a href="#examples.message-counters">11.1.27. Message Counter</a></span></dt><dt><span class="section"><a href="#examples.expiry">11.1.28. Message Expiration</a></span></dt><dt><span class="section"><a href="#examples.message-group">11.1.29. Message Group</a></span></dt><dt><span class="section"><a href="#examples.message-group2">11.1.30. Message Group</a></span></dt><dt><span class="section"><a href="#examples.message-priority">11.1.31. Message Priority</a></span></dt><dt><span class="section"><a href="#examples.no-consumer-buffering">11.1.32. No Consumer Buffering</a></span></dt><dt><span class="section"><a href="#examples.non-transaction-failover">11.1.33. Non-Transaction Failover With Server Data Replication</a></span></dt><dt><span class="section"><a href="#examples.paging">11.1.34. Paging</a></span></dt><dt><span class="section"><a href="#examples.pre-acknowledge">11.1.35. Pre-Acknowledge</a></span></dt><dt><span class="section"><a href="#producer-rate-limiting-example">11.1.36. Message Producer Rate Limiting</a></span></dt><dt><span class="section"><a href="#d0e1982">11.1.37. Queue</a></span></dt><dt><span class="section"><a href="#d0e1987">11.1.38. Message Redistribution</a></span></dt><dt><span class="section"><a href="#d0e1995">11.1.39. Queue Requestor</a></span></dt><dt><span class="section"><a href="#d0e2000">11.1.40. Queue with Message Selector</a></span></dt><dt><span class="section"><a href="#d0e2008">11.1.41. Reattach Node example</a></span></dt><dt><span class="section"><a href="#d0e2016">11.1.42. Request-Reply example</a></span></dt><dt><span class="section"><a href="#examples.scheduled-message">11.1.43. Scheduled Message</a></span></dt><dt><span class="section"><a href="#d0e2029">11.1.44. Security</a></span></dt><dt><span class="section"><a href="#asynchronous-send-acknowledgements-example">11.1.45. Send Acknowledgements</a></span></dt><dt><span class="section"><a href="#d0e2048">11.1.46. SSL Transport</a></span></dt><dt><span class="section"><a href="#d0e2056">11.1.47. Static Message Selector</a></span></dt><dt><span class="section"><a href="#d0e2064">11.1.48. Static Message Selector Using JMS</a></span></dt><dt><span class="section"><a href="#d0e2072">11.1.49. Stomp</a></span></dt><dt><span class="section"><a href="#d0e2080">11.1.50. Stomp Over Web Sockets</a></span></dt><dt><span class="section"><a href="#d0e2088">11.1.51. Symmetric Cluster</a></span></dt><dt><span class="section"><a href="#d0e2100">11.1.52. Temporary Queue</a></span></dt><dt><span class="section"><a href="#d0e2105">11.1.53. Topic</a></span></dt><dt><span class="section"><a href="#topic-hierarchy-example">11.1.54. Topic Hierarchy</a></span></dt><dt><span class="section"><a href="#d0e2115">11.1.55. Topic Selector 1</a></span></dt><dt><span class="section"><a href="#d0e2123">11.1.56. Topic Selector 2</a></span></dt><dt><span class="section"><a href="#examples.transaction-failover">11.1.57. Transaction Failover With Data Replication</a></span></dt><dt><span class="section"><a href="#d0e2141">11.1.58. Transactional Session</a></span></dt><dt><span class="section"><a href="#d0e2149">11.1.59. XA Heuristic</a></span></dt><dt><span class="section"><a href="#d0e2157">11.1.60. XA Receive</a></span></dt><dt><span class="section"><a href="#d0e2165">11.1.61. XA Send</a></span></dt><dt><span class="section"><a href="#d0e2173">11.1.62. XA with Transaction Manager</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2181">11.2. Core API Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#examples.embedded">11.2.1. Embedded</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2196">11.3. Java EE Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2207">11.3.1. EJB/JMS Transaction</a></span></dt><dt><span class="section"><a href="#d0e2212">11.3.2. HAJNDI (High Availability)</a></span></dt><dt><span class="section"><a href="#d0e2217">11.3.3. Resource Adapter Configuration</a></span></dt><dt><span class="section"><a href="#d0e2222">11.3.4. Resource Adapter Remote Server Configuration</a></span></dt><dt><span class="section"><a href="#examples.javaee.jms-bridge">11.3.5. JMS Bridge</a></span></dt><dt><span class="section"><a href="#d0e2232">11.3.6. MDB (Message Driven Bean)</a></span></dt><dt><span class="section"><a href="#d0e2237">11.3.7. Servlet Transport</a></span></dt><dt><span class="section"><a href="#d0e2242">11.3.8. Servlet SSL Transport</a></span></dt><dt><span class="section"><a href="#xa-recovery-example">11.3.9. XA Recovery</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#wildcard-routing">12. Routing Messages With Wild Cards</a></span></dt><dt><span class="chapter"><a href="#wildcard-syntax">13. Understanding the HornetQ Wildcard Syntax</a></span></dt><dt><span class="chapter"><a href="#filter-expressions">14. Filter Expressions</a></span></dt><dt><span class="chapter"><a href="#persistence">15. Persistence</a></span></dt><dd><dl><dt><span class="section"><a href="#configuring.bindings.journal">15.1. Configuring the bindings journal</a></span></dt><dt><span class="section"><a href="#configuring.bindings.jms">15.2. Configuring the jms journal</a></span></dt><dt><span class="section"><a href="#configuring.message.journal">15.3. Configuring the message journal</a></span></dt><dt><span class="section"><a href="#disk-write-cache">15.4. An important note on disabling disk write cache.</a></span></dt><dt><span class="section"><a href="#installing-aio">15.5. Installing AIO</a></span></dt><dt><span class="section"><a href="#persistence.enabled">15.6. Configuring HornetQ for Zero Persistence</a></span></dt><dt><span class="section"><a href="#persistence.importexport">15.7. Import/Export the Journal Data</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuring-transports">16. Configuring the Transport</a></span></dt><dd><dl><dt><span class="section"><a href="#configuring-transports.acceptors">16.1. Understanding Acceptors</a></span></dt><dt><span class="section"><a href="#configuring-transports.connectors">16.2. Understanding Connectors</a></span></dt><dt><span class="section"><a href="#configuring-transports.client.side">16.3. Configuring the transport directly from the client side.</a></span></dt><dt><span class="section"><a href="#d0e3087">16.4. Configuring the Netty transport</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3099">16.4.1. Configuring Netty TCP</a></span></dt><dt><span class="section"><a href="#d0e3243">16.4.2. Configuring Netty SSL</a></span></dt><dt><span class="section"><a href="#d0e3281">16.4.3. Configuring Netty HTTP</a></span></dt><dt><span class="section"><a href="#d0e3324">16.4.4. Configuring Netty Servlet</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#connection-ttl">17. Detecting Dead Connections</a></span></dt><dd><dl><dt><span class="section"><a href="#dead.connections">17.1. Cleaning up Dead Connection Resources on the Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3476">17.1.1. Closing core sessions or JMS connections that you have failed to close</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3492">17.2. Detecting failure from the client side.</a></span></dt><dt><span class="section"><a href="#connection-ttl.async-connection-execution">17.3. Configuring Asynchronous Connection Execution</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transaction-config">18. Resource Manager Configuration</a></span></dt><dt><span class="chapter"><a href="#flow-control">19. Flow Control</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3611">19.1. Consumer Flow Control</a></span></dt><dd><dl><dt><span class="section"><a href="#flow-control.consumer.window">19.1.1. Window-Based Flow Control</a></span></dt><dd><dl><dt><span class="section"><a href="#flow-control.core.api">19.1.1.1. Using Core API</a></span></dt><dt><span class="section"><a href="#d0e3712">19.1.1.2. Using JMS</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3731">19.1.2. Rate limited flow control</a></span></dt><dd><dl><dt><span class="section"><a href="#flow-control.rate.core.api">19.1.2.1. Using Core API</a></span></dt><dt><span class="section"><a href="#d0e3762">19.1.2.2. Using JMS</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d0e3784">19.2. Producer flow control</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3789">19.2.1. Window based flow control</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3803">19.2.1.1. Using Core API</a></span></dt><dt><span class="section"><a href="#d0e3811">19.2.1.2. Using JMS</a></span></dt><dt><span class="section"><a href="#d0e3826">19.2.1.3. Blocking producer window based flow control</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3873">19.2.2. Rate limited flow control</a></span></dt><dd><dl><dt><span class="section"><a href="#flow-control.producer.rate.core.api">19.2.2.1. Using Core API</a></span></dt><dt><span class="section"><a href="#d0e3901">19.2.2.2. Using JMS</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#send-guarantees">20. Guarantees of sends and commits</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3936">20.1. Guarantees of Transaction Completion</a></span></dt><dt><span class="section"><a href="#non-transactional-sends">20.2. Guarantees of Non Transactional Message Sends</a></span></dt><dt><span class="section"><a href="#send-guarantees.nontrans.acks">20.3. Guarantees of Non Transactional Acknowledgements</a></span></dt><dt><span class="section"><a href="#asynchronous-send-acknowledgements">20.4. Asynchronous Send Acknowledgements</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4079">20.4.1. Asynchronous Send Acknowledgements</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#undelivered-messages">21. Message Redelivery and Undelivered Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4144">21.1. Delayed Redelivery</a></span></dt><dd><dl><dt><span class="section"><a href="#undelivered-messages.delay">21.1.1. Configuring Delayed Redelivery</a></span></dt><dt><span class="section"><a href="#d0e4170">21.1.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4177">21.2. Dead Letter Addresses</a></span></dt><dd><dl><dt><span class="section"><a href="#undelivered-messages.configuring">21.2.1. Configuring Dead Letter Addresses</a></span></dt><dt><span class="section"><a href="#d0e4221">21.2.2. Dead Letter Properties</a></span></dt><dt><span class="section"><a href="#d0e4236">21.2.3. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#configuring.delivery.count.persistence">21.3. Delivery Count Persistence</a></span></dt></dl></dd><dt><span class="chapter"><a href="#message-expiry">22. Message Expiry</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4315">22.1. Message Expiry</a></span></dt><dt><span class="section"><a href="#message-expiry.configuring">22.2. Configuring Expiry Addresses</a></span></dt><dt><span class="section"><a href="#configuring.expiry.reaper">22.3. Configuring The Expiry Reaper Thread</a></span></dt><dt><span class="section"><a href="#d0e4383">22.4. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#large-messages">23. Large Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#large.message.configuring">23.1. Configuring the server</a></span></dt><dt><span class="section"><a href="#d0e4449">23.2. Setting the limits</a></span></dt><dd><dl><dt><span class="section"><a href="#large-messages.core.config">23.2.1. Using Core API</a></span></dt><dt><span class="section"><a href="#d0e4471">23.2.2. Using JMS</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4485">23.3. Streaming large messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4517">23.3.1. Streaming over Core API</a></span></dt><dt><span class="section"><a href="#large-messages.streaming.over.jms">23.3.2. Streaming over JMS</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4616">23.4. Streaming Alternative</a></span></dt><dt><span class="section"><a href="#large-messages.cache.client">23.5. Cache Large Messages on client</a></span></dt><dt><span class="section"><a href="#large-messages.example">23.6. Large message example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paging">24. Paging</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4691">24.1. Page Files</a></span></dt><dt><span class="section"><a href="#paging.main.config">24.2. Configuration</a></span></dt><dt><span class="section"><a href="#paging.mode">24.3. Paging Mode</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4746">24.3.1. Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4801">24.4. Dropping messages</a></span></dt><dt><span class="section"><a href="#d0e4814">24.5. Blocking producers</a></span></dt><dt><span class="section"><a href="#d0e4831">24.6. Caution with Addresses with Multiple Queues</a></span></dt><dt><span class="section"><a href="#d0e4853">24.7. Paging and message selectors</a></span></dt><dt><span class="section"><a href="#d0e4859">24.8. Paging and browsers</a></span></dt><dt><span class="section"><a href="#d0e4868">24.9. Paging and unacknowledged messages</a></span></dt><dt><span class="section"><a href="#d0e4877">24.10. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queue-attributes">25. Queue Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#predefined.queues">25.1. Predefined Queues</a></span></dt><dt><span class="section"><a href="#d0e4959">25.2. Using the API</a></span></dt><dt><span class="section"><a href="#queue-attributes.address-settings">25.3. Configuring Queues Via Address Settings</a></span></dt></dl></dd><dt><span class="chapter"><a href="#scheduled-messages">26. Scheduled Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5103">26.1. Scheduled Delivery Property</a></span></dt><dt><span class="section"><a href="#d0e5123">26.2. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#last-value-queues">27. Last-Value Queues</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5154">27.1. Configuring Last-Value Queues</a></span></dt><dt><span class="section"><a href="#d0e5168">27.2. Using Last-Value Property</a></span></dt><dt><span class="section"><a href="#d0e5183">27.3. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#message-grouping">28. Message Grouping</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5231">28.1. Using Core API</a></span></dt><dt><span class="section"><a href="#message-grouping.jmsconfigure">28.2. Using JMS</a></span></dt><dt><span class="section"><a href="#d0e5281">28.3. Example</a></span></dt><dt><span class="section"><a href="#d0e5288">28.4. Example</a></span></dt><dt><span class="section"><a href="#d0e5295">28.5.  Clustered Grouping</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5322">28.5.1. Clustered Grouping Best Practices</a></span></dt><dt><span class="section"><a href="#d0e5337">28.5.2. Clustered Grouping Example</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#pre-acknowledge">29. Pre-Acknowledge Mode</a></span></dt><dd><dl><dt><span class="section"><a href="#pre-acknowledge.configure">29.1. Using PRE_ACKNOWLEDGE</a></span></dt><dt><span class="section"><a href="#d0e5437">29.2. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#management">30. Management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5489">30.1. The Management API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5538">30.1.1. Core Management API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5543">30.1.1.1. Core Server Management</a></span></dt><dt><span class="section"><a href="#d0e5691">30.1.1.2. Core Address Management</a></span></dt><dt><span class="section"><a href="#d0e5720">30.1.1.3. Core Queue Management</a></span></dt><dt><span class="section"><a href="#d0e5851">30.1.1.4. Other Core Resources Management</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6007">30.1.2. JMS Management API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6015">30.1.2.1. JMS Server Management</a></span></dt><dt><span class="section"><a href="#d0e6111">30.1.2.2. JMS ConnectionFactory Management</a></span></dt><dt><span class="section"><a href="#d0e6140">30.1.2.3. JMS Queue Management</a></span></dt><dt><span class="section"><a href="#d0e6269">30.1.2.4. JMS Topic Management</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#management.jmx">30.2. Using Management Via JMX</a></span></dt><dd><dl><dt><span class="section"><a href="#management.jmx.configuration">30.2.1. Configuring JMX</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6409">30.2.1.1. MBeanServer configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6425">30.2.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6432">30.3. Using Management Via Core API</a></span></dt><dd><dl><dt><span class="section"><a href="#management.core.configuration">30.3.1. Configuring Core Management</a></span></dt></dl></dd><dt><span class="section"><a href="#management.jms">30.4. Using Management Via JMS</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6610">30.4.1. Configuring JMS Management</a></span></dt><dt><span class="section"><a href="#d0e6617">30.4.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#management.notifications">30.5. Management Notifications</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6644">30.5.1. JMX Notifications</a></span></dt><dt><span class="section"><a href="#d0e6668">30.5.2. Core Messages Notifications</a></span></dt><dd><dl><dt><span class="section"><a href="#management.notifications.core.configuration">30.5.2.1. Configuring The Core Management Notification Address</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6697">30.5.3. JMS Messages Notifications</a></span></dt><dt><span class="section"><a href="#d0e6721">30.5.4. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#management.message-counters">30.6. Message Counters</a></span></dt><dd><dl><dt><span class="section"><a href="#configuring.message.counters">30.6.1. Configuring Message Counters</a></span></dt><dt><span class="section"><a href="#d0e6829">30.6.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6839">30.7. Administering HornetQ Resources Using The JBoss AS Admin Console</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6848">30.7.1. JMS Queues</a></span></dt><dt><span class="section"><a href="#d0e6872">30.7.2. JMS Topics</a></span></dt><dt><span class="section"><a href="#d0e6877">30.7.3. JMS Connection Factories</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#security">31. Security</a></span></dt><dd><dl><dt><span class="section"><a href="#security.settings.roles">31.1. Role based security for addresses</a></span></dt><dt><span class="section"><a href="#d0e7070">31.2. Secure Sockets Layer (SSL) Transport</a></span></dt><dt><span class="section"><a href="#d0e7079">31.3. Basic user credentials</a></span></dt><dt><span class="section"><a href="#change-security-manager">31.4. Changing the security manager</a></span></dt><dt><span class="section"><a href="#d0e7166">31.5. JAAS Security Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7199">31.5.1. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7206">31.6. JBoss AS Security Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7220">31.6.1. Configuring Client Login</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7239">31.7. Changing the username/password for clustering</a></span></dt></dl></dd><dt><span class="chapter"><a href="#appserver-integration">32. Application Server Integration and Java EE</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7276">32.1. Configuring Message-Driven Beans</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7331">32.1.1. Using Container-Managed Transactions</a></span></dt><dt><span class="section"><a href="#d0e7363">32.1.2. Using Bean-Managed Transactions</a></span></dt><dt><span class="section"><a href="#d0e7385">32.1.3. Using Message Selectors with Message-Driven Beans</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7392">32.2. Sending Messages from within JEE components</a></span></dt><dt><span class="section"><a href="#d0e7409">32.3. MDB and Consumer pool size</a></span></dt><dt><span class="section"><a href="#d0e7422">32.4. Configuring the JCA Adaptor</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7451">32.4.1. Global Properties</a></span></dt><dt><span class="section"><a href="#d0e7788">32.4.2. Adapter Outbound Configuration</a></span></dt><dt><span class="section"><a href="#d0e7857">32.4.3. Adapter Inbound Configuration</a></span></dt><dt><span class="section"><a href="#d0e7966">32.4.4. Configuring the adapter to use a standalone HornetQ Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7971">32.4.4.1. </a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d0e8107">32.5. High Availability JNDI (HA-JNDI)</a></span></dt><dt><span class="section"><a href="#xa-recovery">32.6. XA Recovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8134">32.6.1. XA Recovery Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8192">32.6.1.1. Configuration Settings</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8229">32.6.2. Example</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#jms-bridge">33. The JMS Bridge</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8284">33.1. JMS Bridge Parameters</a></span></dt><dt><span class="section"><a href="#d0e8489">33.2. Source and Target Connection Factories</a></span></dt><dt><span class="section"><a href="#d0e8499">33.3. Source and Target Destination Factories</a></span></dt><dt><span class="section"><a href="#quality-of-service">33.4. Quality Of Service</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8516">33.4.1. AT_MOST_ONCE</a></span></dt><dt><span class="section"><a href="#d0e8523">33.4.2. DUPLICATES_OK</a></span></dt><dt><span class="section"><a href="#d0e8530">33.4.3. ONCE_AND_ONLY_ONCE</a></span></dt><dt><span class="section"><a href="#d0e8540">33.4.4. Time outs and the JMS bridge</a></span></dt><dt><span class="section"><a href="#d0e8567">33.4.5. Examples</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#client-reconnection">34. Client Reconnection and Session Reattachment</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8600">34.1. 100% Transparent session re-attachment</a></span></dt><dt><span class="section"><a href="#d0e8649">34.2. Session reconnection</a></span></dt><dt><span class="section"><a href="#d0e8668">34.3. Configuring reconnection/reattachment attributes</a></span></dt><dt><span class="section"><a href="#client-reconnection.exceptionlistener">34.4. ExceptionListeners and SessionFailureListeners</a></span></dt></dl></dd><dt><span class="chapter"><a href="#diverts">35. Diverting and Splitting Message Flows</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8852">35.1. Exclusive Divert</a></span></dt><dt><span class="section"><a href="#d0e8890">35.2. Non-exclusive Divert</a></span></dt></dl></dd><dt><span class="chapter"><a href="#core-bridges">36. Core Bridges</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8964">36.1. Configuring Bridges</a></span></dt></dl></dd><dt><span class="chapter"><a href="#duplicate-detection">37. Duplicate Message Detection</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9237">37.1. Using Duplicate Detection for Message Sending</a></span></dt><dt><span class="section"><a href="#duplicate.id.cache">37.2. Configuring the Duplicate ID Cache</a></span></dt><dt><span class="section"><a href="#d0e9326">37.3. Duplicate Detection and Bridges</a></span></dt><dt><span class="section"><a href="#d0e9351">37.4. Duplicate Detection and Cluster Connections</a></span></dt><dt><span class="section"><a href="#d0e9376">37.5. Duplicate Detection and Paging</a></span></dt></dl></dd><dt><span class="chapter"><a href="#clusters">38. Clusters</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9405">38.1. Clusters Overview</a></span></dt><dt><span class="section"><a href="#clusters.server-discovery">38.2. Server discovery</a></span></dt><dd><dl><dt><span class="section"><a href="#clusters.broadcast-groups">38.2.1. Broadcast Groups</a></span></dt><dt><span class="section"><a href="#clusters.discovery-groups">38.2.2. Discovery Groups</a></span></dt><dt><span class="section"><a href="#d0e9573">38.2.3. Defining Discovery Groups on the Server</a></span></dt><dt><span class="section"><a href="#clusters-discovery.groups.clientside">38.2.4. Discovery Groups on the Client Side</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9631">38.2.4.1. Configuring client discovery using JMS</a></span></dt><dt><span class="section"><a href="#d0e9671">38.2.4.2. Configuring client discovery using Core</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#d0e9697">38.3. Server-Side Message Load Balancing</a></span></dt><dd><dl><dt><span class="section"><a href="#clusters.cluster-connections">38.3.1. Configuring Cluster Connections</a></span></dt><dt><span class="section"><a href="#clusters.clusteruser">38.3.2. Cluster User Credentials</a></span></dt></dl></dd><dt><span class="section"><a href="#clusters.client.loadbalancing">38.4. Client-Side Load balancing</a></span></dt><dt><span class="section"><a href="#d0e9918">38.5. Specifying Members of a Cluster Explicitly</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9925">38.5.1. Specify List of Servers on the Client Side</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9930">38.5.1.1. Specifying List of Servers using JMS</a></span></dt><dt><span class="section"><a href="#d0e9990">38.5.1.2. Specifying List of Servers using the Core API</a></span></dt></dl></dd><dt><span class="section"><a href="#clusters.static.servers">38.5.2. Specifying List of Servers to form a Cluster</a></span></dt></dl></dd><dt><span class="section"><a href="#clusters.message-redistribution">38.6. Message Redistribution</a></span></dt><dt><span class="section"><a href="#d0e10115">38.7. Cluster topologies</a></span></dt><dd><dl><dt><span class="section"><a href="#symmetric-cluster">38.7.1. Symmetric cluster</a></span></dt><dt><span class="section"><a href="#d0e10137">38.7.2. Chain cluster</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ha">39. High Availability and Failover</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10190">39.1. Live - Backup Pairs</a></span></dt><dd><dl><dt><span class="section"><a href="#ha.mode">39.1.1. HA modes</a></span></dt><dd><dl><dt><span class="section"><a href="#ha.mode.replicated">39.1.1.1. Data Replication</a></span></dt><dt><span class="section"><a href="#ha.mode.shared">39.1.1.2. Shared Store</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#failover">39.2. Failover Modes</a></span></dt><dd><dl><dt><span class="section"><a href="#ha.automatic.failover">39.2.1. Automatic Client Failover</a></span></dt><dd><dl><dt><span class="section"><a href="#ha.automatic.failover.noteonreplication">39.2.1.1. A Note on Server Replication</a></span></dt><dt><span class="section"><a href="#ha.automatic.failover.blockingcalls">39.2.1.2. Handling Blocking Calls During Failover</a></span></dt><dt><span class="section"><a href="#ha.automatic.failover.transactions">39.2.1.3. Handling Failover With Transactions</a></span></dt><dt><span class="section"><a href="#ha.automatic.failover.nontransactional">39.2.1.4. Handling Failover With Non Transactional Sessions</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10515">39.2.2. Getting Notified of Connection Failure</a></span></dt><dt><span class="section"><a href="#d0e10532">39.2.3. Application-Level Failover</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#libaio">40. Libaio Native Libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10613">40.1. Compiling the native libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10618">40.1.1. Install requirements</a></span></dt><dt><span class="section"><a href="#d0e10668">40.1.2. Invoking the compilation</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#thread-pooling">41. Thread management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10727">41.1. Server-Side Thread Management</a></span></dt><dd><dl><dt><span class="section"><a href="#server.scheduled.thread.pool">41.1.1. Server Scheduled Thread Pool</a></span></dt><dt><span class="section"><a href="#d0e10762">41.1.2. General Purpose Server Thread Pool</a></span></dt><dt><span class="section"><a href="#d0e10804">41.1.3. Expiry Reaper Thread</a></span></dt><dt><span class="section"><a href="#d0e10813">41.1.4. Asynchronous IO</a></span></dt></dl></dd><dt><span class="section"><a href="#thread-pooling.client.side">41.2. Client-Side Thread Management</a></span></dt></dl></dd><dt><span class="chapter"><a href="#logging">42. Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10928">42.1. Logging With The JBoss Application Server</a></span></dt></dl></dd><dt><span class="chapter"><a href="#embedding-hornetq">43. Embedding HornetQ</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10965">43.1. POJO instantiation</a></span></dt><dt><span class="section"><a href="#d0e11005">43.2. Dependency Frameworks</a></span></dt><dt><span class="section"><a href="#d0e11042">43.3. Connecting to the Embedded HornetQ</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11047">43.3.1. Core API</a></span></dt><dt><span class="section"><a href="#d0e11057">43.3.2. JMS API</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11067">43.4. JMS Embedding Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#intercepting-operations">44. Intercepting Operations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11099">44.1. Implementing The Interceptors</a></span></dt><dt><span class="section"><a href="#d0e11124">44.2. Configuring The Interceptors</a></span></dt><dt><span class="section"><a href="#d0e11136">44.3. Interceptors on the Client Side</a></span></dt><dt><span class="section"><a href="#d0e11152">44.4. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#interoperability">45. Interoperability</a></span></dt><dd><dl><dt><span class="section"><a href="#stomp">45.1. Stomp</a></span></dt><dd><dl><dt><span class="section"><a href="#stomp.native">45.1.1. Native Stomp support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11216">45.1.1.1. Limitations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11224">45.1.2. Mapping Stomp destinations to HornetQ addresses and queues</a></span></dt><dt><span class="section"><a href="#d0e11249">45.1.3. Stomp and JMS interoperabilty</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11252">45.1.3.1. Using JMS destinations</a></span></dt><dt><span class="section"><a href="#d0e11292">45.1.3.2. Send and consuming Stomp message from JMS or HornetQ Core API</a></span></dt></dl></dd><dt><span class="section"><a href="#stomp.websockets">45.1.4. Stomp Over Web Sockets</a></span></dt><dt><span class="section"><a href="#stompconnect">45.1.5. StompConnect</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11399">45.2. REST</a></span></dt><dt><span class="section"><a href="#d0e11404">45.3. AMQP</a></span></dt></dl></dd><dt><span class="chapter"><a href="#perf-tuning">46. Performance Tuning</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11431">46.1. Tuning persistence</a></span></dt><dt><span class="section"><a href="#d0e11462">46.2. Tuning JMS</a></span></dt><dt><span class="section"><a href="#d0e11522">46.3. Other Tunings</a></span></dt><dt><span class="section"><a href="#d0e11627">46.4. Tuning Transport Settings</a></span></dt><dt><span class="section"><a href="#d0e11676">46.5. Tuning the VM</a></span></dt><dt><span class="section"><a href="#d0e11711">46.6. Avoiding Anti-Patterns</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration-index">47. Configuration Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#server.configuration">47.1. Server Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11755">47.1.1. hornetq-configuration.xml</a></span></dt><dt><span class="section"><a href="#d0e12990">47.1.2. hornetq-jms.xml</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="notice"></a>Chapter&nbsp;1.&nbsp;Legal Notice</h2></div></div><div></div></div><p>Copyright &copy; 2010 Red Hat, Inc. and others.</p><p>The text of and illustrations in this document are licensed by Red Hat under
            a Creative Commons Attribution&#8211;Share Alike 3.0 Unported license ("CC-BY-SA").</p><p>An explanation of CC-BY-SA is available at 
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_top">http://creativecommons.org/licenses/by-sa/3.0/</a>. 
            In accordance with CC-BY-SA, if you distribute this document or an adaptation
            of it, you must provide the URL for the original version.</p><p>Red Hat, as the licensor of this document, waives the right to enforce, 
            and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent 
            permitted by applicable law.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Chapter&nbsp;2.&nbsp;Preface</h2></div></div><div></div></div><p>What is HornetQ?</p><div class="itemizedlist"><ul type="disc"><li><p>HornetQ is an open source project to build a multi-protocol, embeddable, very high
                performance, clustered, asynchronous messaging system.</p></li><li><p>HornetQ is an example of Message Oriented Middleware (MoM) For a description of
                MoMs and other messaging concepts please see the <a href="#messaging-concepts" title="Chapter&nbsp;4.&nbsp;Messaging Concepts">Chapter&nbsp;4, <i>Messaging Concepts</i></a>.</p></li><li><p>For answers to more questions about what HornetQ is and what it isn't please visit
                the <a href="http://www.jboss.org/community/wiki/HornetQGeneralFAQs" target="_top">FAQs wiki
                    page</a>.</p></li></ul></div><p>Why use HornetQ? Here are just a few of the reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>100% open source software. HornetQ is licenced using the Apache Software License v
                2.0 to minimise barriers to adoption.</p></li><li><p>HornetQ is designed with usability in mind.</p></li><li><p>Written in Java. Runs on any platform with a Java 6+ runtime, that's everything
                from Windows desktops to IBM mainframes.</p></li><li><p>Amazing performance. Our ground-breaking high performance journal provides
                persistent messaging performance at rates normally seen for non-persistent
                messaging, our non-persistent messaging performance rocks the boat too.</p></li><li><p>Full feature set. All the features you'd expect in any serious messaging system,
                and others you won't find anywhere else.</p></li><li><p>Elegant, clean-cut design with minimal third party dependencies. Run HornetQ
                stand-alone, run it in integrated in your favourite JEE application server, or run
                it embedded inside your own product. It's up to you.</p></li><li><p>Seamless high availability. We provide a HA solution with automatic client
                failover so you can guarantee zero message loss or duplication in event of server
                failure.</p></li><li><p>Hugely flexible clustering. Create clusters of servers that know how to load
                balance messages. Link geographically distributed clusters over unreliable
                connections to form a global network. Configure routing of messages in a highly
                flexible way.</p></li><li><p>For a full list of features, please see the <a href="http://www.jboss.org/community/wiki/HornetQFeatures" target="_top">features wiki
                    page</a> .</p></li></ul></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="project-info"></a>Chapter&nbsp;3.&nbsp;Project Information</h2></div></div><div></div></div><p>The official HornetQ project page is <a href="http://hornetq.org/" target="_top">http://hornetq.org/</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="download.software"></a>3.1.&nbsp;Software Download</h2></div></div><div></div></div><p>The software can be download from the Download page:<a href="http://hornetq.org/downloads.html" target="_top">http://hornetq.org/downloads.html</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="download.svn"></a>3.2.&nbsp;Project Information</h2></div></div><div></div></div><p>
         </p><div class="itemizedlist"><ul type="disc"><li><p>Please take a look at our project <a href="http://www.jboss.org/community/wiki/HornetQ" target="_top">wiki</a></p></li><li><p>If you have any user questions please use our <a href="http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=312" target="_top">user
                     forum</a></p></li><li><p>If you have development related questions, please use our <a href="http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=313" target="_top">developer forum</a></p></li><li><p>Pop in and chat to us in our <a href="irc://irc.freenode.net:6667/hornetq" target="_top">IRC channel</a></p></li><li><p>Our project <a href="http://hornetq.blogspot.com/" target="_top">blog</a></p></li><li><p>Follow us on <a href="http://twitter.com/hornetq" target="_top">twitter</a></p></li><li><p>HornetQ Subversion trunk is <a href="http://anonsvn.jboss.org/repos/hornetq/trunk" target="_top">http://anonsvn.jboss.org/repos/hornetq/trunk</a></p></li><li><p>All release tags are available from <a href="http://anonsvn.jboss.org/repos/hornetq/tags" target="_top">http://anonsvn.jboss.org/repos/hornetq/tags</a></p></li></ul></div><p>
      </p><p>Red Hat kindly employs developers to work full time on HornetQ, they are: </p><div class="itemizedlist"><ul type="disc"><li><p>
                  <a href="http://jbossfox.blogspot.com" target="_top">Tim Fox</a> (project lead)</p></li><li><p>Howard Gao</p></li><li><p><a href="http://jmesnil.net/weblog/" target="_top">Jeff Mesnil</a></p></li><li><p>Clebert Suconic</p></li><li><p>Andy Taylor</p></li></ul></div><p> And many thanks to all our contributors, both old and new who helped create HornetQ,
         for a full list of the people who made it happen, take a look at our <a href="http://jboss.org/hornetq/community/team.html" target="_top">team page</a>. </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="messaging-concepts"></a>Chapter&nbsp;4.&nbsp;Messaging Concepts</h2></div></div><div></div></div><p>HornetQ is an asynchronous messaging system, an example of <a href="http://en.wikipedia.org/wiki/Message_oriented_middleware" target="_top">Message Oriented
            Middleware</a> , we'll just call them messaging systems in the remainder of this
        book.</p><p>We'll first present a brief overview of what kind of things messaging systems do,
        where they're useful and the kind of concepts you'll hear about in the messaging
        world.</p><p>If you're already familiar with what a messaging system is and what it's capable of, then
        you can skip this chapter.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e261"></a>4.1.&nbsp;Messaging Concepts</h2></div></div><div></div></div><p>Messaging systems allow you to loosely couple heteregenous systems together, whilst
            typically providing reliability, transactions and many other features.</p><p>Unlike systems based on a <a href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_top">Remote Procedure
                Call</a> (RPC) pattern, messaging systems primarily use an asynchronous message
            passing pattern with no tight relationship between requests and responses. Most
            messaging systems also support a request-response mode but this is not a primary feature
            of messaging systems.</p><p>Designing systems to be asynchronous from end-to-end allows you to really take
            advantage of your hardware resources, minimizing the amount of threads blocking on IO
            operations, and to use your network bandwidth to its full capacity. With an RPC approach
            you have to wait for a response for each request you make so are limited by the network
            round trip time, or <span class="italic">latency</span> of your network. With an
            asynchronous system you can pipeline flows of messages in different directions, so are
            limited by the network <span class="italic">bandwidth</span> not the latency.
            This typically allows you to create much higher performance applications.</p><p>Messaging systems decouple the senders of messages from the consumers of messages. The
            senders and consumers of messages are completely independent and know nothing of each
            other. This allows you to create flexible, loosely coupled systems.</p><p>Often, large enterprises use a messaging system to implement a message bus which
            loosely couples heterogeneous systems together. Message buses often form the core of an
                <a href="http://en.wikipedia.org/wiki/Enterprise_service_bus" target="_top">Enterprise Service
                Bus</a>. (ESB). Using a message bus to de-couple disparate systems can allow the
            system to grow and adapt more easily. It also allows more flexibility to add new systems
            or retire old ones since they don't have brittle dependencies on each other.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e286"></a>4.2.&nbsp;Messaging styles</h2></div></div><div></div></div><p>Messaging systems normally support two main styles of asynchronous messaging: <a href="http://en.wikipedia.org/wiki/Message_queue" target="_top"> message queue</a> messaging
            (also known as <span class="italic">point-to-point messaging</span>) and <a href="http://en.wikipedia.org/wiki/Publish_subscribe" target="_top">publish subscribe</a>
            messaging. We'll summarise them briefly here:</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e300"></a>4.2.1.&nbsp;The Message Queue Pattern</h3></div></div><div></div></div><p>With this type of messaging you send a message to a queue. The message is then
                typically persisted to provide a guarantee of delivery, then some time later the
                messaging system delivers the message to a consumer. The consumer then processes the
                message and when it is done, it acknowledges the message. Once the message is
                acknowledged it disappears from the queue and is not available to be delivered
                again. If the system crashes before the messaging server receives an acknowledgement
                from the consumer, then on recovery, the message will be available to be delivered
                to a consumer again.</p><p>With point-to-point messaging, there can be many consumers on the queue but a
                particular message will only ever be consumed by a maximum of one of them. Senders
                (also known as<span class="italic"> producers</span>) to the queue are
                completely decoupled from receivers (also known as <span class="italic">consumers</span>) of the queue - they do not know of each others
                existence.</p><p>A classic example of point to point messaging would be an order queue in a
                company's book ordering system. Each order is represented as a message which is sent
                to the order queue. Let's imagine there are many front end ordering systems which
                send orders to the order queue. When a message arrives on the queue it is persisted
                - this ensures that if the server crashes the order is not lost. Let's also imagine
                there are many consumers on the order queue - each representing an instance of an
                order processing component - these can be on different physical machines but
                consuming from the same queue. The messaging system delivers each message to one and
                only one of the ordering processing components. Different messages can be processed
                by different order processors, but a single order is only processed by one order
                processor - this ensures orders aren't processed twice.</p><p>As an order processor receives a message, it fulfills the order, sends order
                information to the warehouse system and then updates the order database with the
                order details. Once it's done that it acknowledges the message to tell the server
                that the order has been processed and can be forgotten about. Often the send to the
                warehouse system, update in database and acknowledgement will be completed in a
                single transaction to ensure <a href="http://en.wikipedia.org/wiki/ACID" target="_top">ACID</a> properties.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e320"></a>4.2.2.&nbsp;The Publish-Subscribe Pattern</h3></div></div><div></div></div><p>With publish-subscribe messaging many senders can send messages to an entity on
                the server, often called a <span class="italic">topic</span> (e.g. in the JMS
                world).</p><p>There can be many <span class="emphasis"><em>subscriptions</em></span> on a topic, a subscription is
                just another word for a consumer of a topic. Each subscription receives a
                    <span class="emphasis"><em>copy</em></span> of <span class="italic">each</span> message
                sent to the topic. This differs from the message queue pattern where each message is
                only consumed by a single consumer.</p><p>Subscriptions can optionally be <span class="italic">durable</span> which
                means they retain a copy of each message sent to the topic until the subscriber
                consumes them - even if the server crashes or is restarted in between. Non-durable
                subscriptions only last a maximum of the lifetime of the connection that created
                them.</p><p>An example of publish-subscribe messaging would be a news feed. As news articles
                are created by different editors around the world they are sent to a news feed
                topic. There are many subscribers around the world who are interested in receiving
                news items - each one creates a subscription and the messaging system ensures that a
                copy of each news message is delivered to each subscription.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e346"></a>4.3.&nbsp;Delivery guarantees</h2></div></div><div></div></div><p>A key feature of most messaging systems is <span class="italic">reliable
                messaging</span>. With reliable messaging the server gives a guarantee that the
            message will be delivered once and only once to each consumer of a queue or each durable
            subscription of a topic, even in the event of system failure. This is crucial for many
            businesses; e.g. you don't want your orders fulfilled more than once or any of your
            orders to be lost.</p><p>In other cases you may not care about a once and only once delivery guarantee and are
            happy to cope with duplicate deliveries or lost messages - an example of this might be
            transient stock price updates - which are quickly superseded by the next update on the
            same stock. The messaging system allows you to configure which delivery guarantees you
            require.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e356"></a>4.4.&nbsp;Transactions</h2></div></div><div></div></div><p>Messaging systems typically support the sending and acknowledgement of multiple
            messages in a single local transaction. HornetQ also supports the sending and
            acknowledgement of message as part of a large global transaction - using the Java
            mapping of XA; JTA.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e361"></a>4.5.&nbsp;Durability</h2></div></div><div></div></div><p>Messages are either durable or non durable. Durable messages will be persisted in
            permanent storage and will survive server failure or restart. Non durable messages will
            not survive server failure or restart. Examples of durable messages might be orders or
            trades, where they cannot be lost. An example of a non durable message might be a stock
            price update which is transitory and doesn't need to survive a restart.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e366"></a>4.6.&nbsp;Messaging APIs and protocols</h2></div></div><div></div></div><p>How do client applications interact with messaging systems in order to send and
            consume messages?</p><p>Several messaging systems provide their own proprietary APIs with which the client
            communicates with the messaging system.</p><p>There are also some standard ways of operating with messaging systems and some
            emerging standards in this space.</p><p>Let's take a brief look at these:</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e377"></a>4.6.1.&nbsp;Java Message Service (JMS)</h3></div></div><div></div></div><p><a href="http://en.wikipedia.org/wiki/Java_Message_Service" target="_top">JMS</a> is part
                of Sun's JEE specification. It's a Java API that encapsulates both message queue and
                publish-subscribe messaging patterns. JMS is a lowest common denominator
                specification - i.e. it was created to encapsulate common functionality of the
                already existing messaging systems that were available at the time of its
                creation.</p><p>JMS is a very popular API and is implemented by most, messaging systems. JMS is
                only available to clients running Java.</p><p>JMS does not define a standard wire format - it only defines a programmatic API so
                JMS clients and servers from different vendors cannot directly interoperate since
                each will use the vendor's own internal wire protocol.</p><p>HornetQ provides a fully compliant JMS 1.1 API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e390"></a>4.6.2.&nbsp;System specific APIs</h3></div></div><div></div></div><p>Many systems provide their own programmatic API for which to interact with the
                messaging system. The advantage of this it allows the full set of system
                functionality to be exposed to the client application. API's like JMS are not
                normally rich enough to expose all the extra features that most messaging systems
                provide.</p><p>HornetQ provides its own core client API for clients to use if they wish to have
                access to functionality over and above that accessible via the JMS API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e397"></a>4.6.3.&nbsp;RESTful API</h3></div></div><div></div></div><p><a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_top">REST</a> approaches to messaging are showing a lot interest
                recently.</p><p>It seems plausible that API standards for cloud computing may converge on a REST
                style set of interfaces and consequently a REST messaging approach is a very strong
                contender for becoming the defacto method for messaging interoperability.</p><p>With a REST approach messaging resources are manipulated as resources defined by a
                URI and typically using a simple set of operations on those resources, e.g. PUT,
                POST, GET etc. REST approaches to messaging often use HTTP as their underlying
                protocol.</p><p>The advantage of a REST approach with HTTP is in its simplicity and the fact the
                internet is already tuned to deal with HTTP optimally.</p><p>HornetQ will shortly be implementing RESTful approach to messaging
                interoperability.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e412"></a>4.6.4.&nbsp;STOMP</h3></div></div><div></div></div><p><a href="http://stomp.codehaus.org/" target="_top">Stomp</a> is a very simple text protocol for interoperating with messaging
                systems. It defines a wire format, so theoretically any Stomp client can work with
                any messaging system that supports Stomp. Stomp clients are available in many
                different programming languages.</p><p>Please see <a href="#stomp" title="45.1.&nbsp;Stomp">Section&nbsp;45.1, &#8220;Stomp&#8221;</a> for using STOMP with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e423"></a>4.6.5.&nbsp;AMQP</h3></div></div><div></div></div><p><a href="http://en.wikipedia.org/wiki/AMQP" target="_top">AMQP</a> is a specification for
                interoperable messaging. It also defines a wire format, so any AMQP client can work
                with any messaging system that supports AMQP. AMQP clients are available in many
                different programming languages.</p><p>HornetQ will shortly be implementing AMQP.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e432"></a>4.7.&nbsp;High Availability</h2></div></div><div></div></div><p>High Availability (HA) means that the system should remain operational after failure
            of one or more of the servers. The degree of support for HA varies between various
            messaging systems.</p><p>HornetQ provides automatic failover where your sessions are automatically reconnected
            to the backup server on event of live server failure.</p><p>For more information on HA, please see <a href="#ha" title="Chapter&nbsp;39.&nbsp;High Availability and Failover">Chapter&nbsp;39, <i>High Availability and Failover</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e443"></a>4.8.&nbsp;Clusters</h2></div></div><div></div></div><p>Many messaging systems allow you to create groups of messaging servers called
                <span class="italic">clusters</span>. Clusters allow the load of sending and
            consuming messages to be spread over many servers. This allows your system to scale
            horizontally by adding new servers to the cluster.</p><p>Degrees of support for clusters varies between messaging systems, with some systems
            having fairly basic clusters with the cluster members being hardly aware of each
            other.</p><p>HornetQ provides very configurable state-of-the-art clustering model where messages
            can be intelligently load balanced between the servers in the cluster, according to the
            number of consumers on each node, and whether they are ready for messages.</p><p>HornetQ also has the ability to automatically redistribute messages between nodes of a
            cluster to prevent starvation on any particular node.</p><p>For full details on clustering, please see <a href="#clusters" title="Chapter&nbsp;38.&nbsp;Clusters">Chapter&nbsp;38, <i>Clusters</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e461"></a>4.9.&nbsp;Bridges and routing</h2></div></div><div></div></div><p>Some messaging systems allow isolated clusters or single nodes to be bridged together,
            typically over unreliable connections like a wide area network (WAN), or the
            internet.</p><p>A bridge normally consumes from a queue on one server and forwards messages to another
            queue on a different server. Bridges cope with unreliable connections, automatically
            reconnecting when the connections becomes available again.</p><p>HornetQ bridges can be configured with filter expressions to only forward certain
            messages, and transformation can also be hooked in.</p><p>HornetQ also allows routing between queues to be configured in server side
            configuration. This allows complex routing networks to be set up forwarding or copying
            messages from one destination to another, forming a global network of interconnected
            brokers.</p><p>For more information please see <a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">Chapter&nbsp;36, <i>Core Bridges</i></a> and <a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">Chapter&nbsp;35, <i>Diverting and Splitting Message Flows</i></a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapter&nbsp;5.&nbsp;Architecture</h2></div></div><div></div></div><p>In this section we will give an overview of the HornetQ high level architecture.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e500"></a>5.1.&nbsp;Core Architecture</h2></div></div><div></div></div><p>HornetQ core is designed simply as set of Plain Old Java Objects (POJOs) - we hope you
            like it's clean-cut design.</p><p>We've also designed it to have as few dependencies on external jars as possible. In
            fact, HornetQ core has only one jar dependency, netty.jar,
            other than the standard JDK classes! This is because we use some of the netty buffer classes
        internally.</p><p>This allows HornetQ to be easily embedded in your own project, or instantiated in any
            dependency injection framework such as JBoss Microcontainer, Spring or Google
            Guice.</p><p>Each HornetQ server has its own ultra high performance persistent journal, which it
            uses for message and other persistence.</p><p>Using a high performance journal allows outrageous persistence message performance,
            something not achievable when using a relational database for persistence.</p><p>HornetQ clients, potentially on different physical machines interact with the HornetQ
            server. HornetQ currently provides two APIs for messaging at the client side:</p><p>
            </p><div class="orderedlist"><ol type="1"><li><p>Core client API. This is a simple intuitive Java API that allows the full
                        set of messaging functionality without some of the complexities of
                        JMS.</p></li><li><p>JMS client API. The standard JMS API is available at the client
                        side.</p></li></ol></div><p>
        </p><p>JMS semantics are implemented by a thin JMS facade layer on the client side.</p><p>The HornetQ server does not speak JMS and in fact does not know anything about JMS,
            it's a protocol agnostic messaging server designed to be used with multiple different
            protocols.</p><p>When a user uses the JMS API on the client side, all JMS interactions are translated
            into operations on the HornetQ core client API before being transferred over the wire
            using the HornetQ wire format.</p><p>The server always just deals with core API interactions.</p><p>A schematic illustrating this relationship is shown in figure 3.1 below:</p><p>
            </p><div align="center"><img src="images/architecture1.jpg" align="middle"></div><p>
        </p><p>Figure 3.1 shows two user applications interacting with a HornetQ server. User
            Application 1 is using the JMS API, while User Application 2 is using the core client
            API directly.</p><p>You can see from the diagram that the JMS API is implemented by a thin facade layer on
            the client side.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e543"></a>5.2.&nbsp;HornetQ embedded in your own application</h2></div></div><div></div></div><p>HornetQ core is designed as a set of simple POJOs so if you have an application that
            requires messaging functionality internally but you don't want to expose that as a
            HornetQ server you can directly instantiate and embed HornetQ servers in your own
            application.</p><p>For more information on embedding HornetQ, see <a href="#embedding-hornetq" title="Chapter&nbsp;43.&nbsp;Embedding HornetQ">Chapter&nbsp;43, <i>Embedding HornetQ</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e552"></a>5.3.&nbsp;HornetQ integrated with a JEE application server</h2></div></div><div></div></div><p>HornetQ provides its own fully functional Java Connector Architecture (JCA) adaptor
            which enables it to be integrated easily into any JEE compliant application server or
            servlet engine.</p><p>JEE application servers provide Message Driven Beans (MDBs), which are a special type
            of Enterprise Java Beans (EJBs) that can process messages from sources such as JMS
            systems or mail systems.</p><p>Probably the most common use of an MDB is to consume messages from a JMS messaging
            system.</p><p>According to the JEE specification, a JEE application server uses a JCA adapter to
            integrate with a JMS messaging system so it can consume messages for MDBs.</p><p>However, the JCA adapter is not only used by the JEE application server for <span class="italic">consuming</span> messages via MDBs, it is also used when sending
            message to the JMS messaging system e.g. from inside an EJB or servlet.</p><p>When integrating with a JMS messaging system from inside a JEE application server it
            is always recommended that this is done via a JCA adaptor. In fact, communicating with a
            JMS messaging system directly, without using JCA would be illegal according to the JEE
            specification.</p><p>The application server's JCA service provides extra functionality such as connection
            pooling and automatic transaction enlistment, which are desirable when using messaging,
            say, from inside an EJB. It is possible to talk to a JMS messaging system directly from
            an EJB, MDB or servlet without going through a JCA adapter, but this is not recommended
            since you will not be able to take advantage of the JCA features, such as caching of JMS
            sessions, which can result in poor performance.</p><p>Figure 3.2 below shows a JEE application server integrating with a HornetQ server via
            the HornetQ JCA adaptor. Note that all communication between EJB sessions or entity
            beans and Message Driven beans go through the adaptor and not directly to
            HornetQ.</p><p>The large arrow with the prohibited sign shows an EJB session bean talking directly to
            the HornetQ server. This is not recommended as you'll most likely end up creating a new
            connection and session every time you want to interact from the EJB, which is an
            anti-pattern.</p><p>
            </p><div><img src="images/architecture2.jpg"></div><p>
        </p><p>For more information on using the JCA adaptor, please see <a href="#appserver-integration" title="Chapter&nbsp;32.&nbsp;Application Server Integration and Java EE">Chapter&nbsp;32, <i>Application Server Integration and Java EE</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e584"></a>5.4.&nbsp;HornetQ stand-alone server</h2></div></div><div></div></div><p>HornetQ can also be deployed as a stand-alone server. This means a fully independent
            messaging server not dependent on a JEE application server.</p><p>The standard stand-alone messaging server configuration comprises a core messaging
            server, a JMS service and a JNDI service.</p><p>The role of the JMS Service is to deploy any JMS Queue, Topic and ConnectionFactory
            instances from any server side <tt class="literal">hornetq-jms.xml</tt> configuration files.
            It also provides a simple management API for creating and destroying Queues, Topics and
            ConnectionFactory instances which can be accessed via JMX or the connection. It is a
            separate service to the HornetQ core server, since the core server is JMS agnostic. If
            you don't want to deploy any JMS Queue, Topic or ConnectionFactory instances via server
            side XML configuration and don't require a JMS management API on the server side then
            you can disable this service.</p><p>We also include a JNDI server since JNDI is a common requirement when using JMS to
            lookup Queues, Topics and ConnectionFactory instances. If you do not require JNDI then
            this service can also be disabled. HornetQ allows you to programmatically create JMS and
            core objects directly on the client side as opposed to looking them up from JNDI, so a
            JNDI server is not always a requirement.</p><p>The stand-alone server configuration uses JBoss Microcontainer to instantiate and
            enforce dependencies between the components. JBoss Microcontainer is a very lightweight
            POJO bootstrapper.</p><p>The stand-alone server architecture is shown in figure 3.3 below:</p><p>
            </p><div><img src="images/architecture3.jpg"></div><p>
        </p><p>For more information on server configuration files see <a href="#server.configuration" title="47.1.&nbsp;Server Configuration">Section&nbsp;47.1, &#8220;Server Configuration&#8221;</a>. $ </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="using-server"></a>Chapter&nbsp;6.&nbsp;Using the Server</h2></div></div><div></div></div><p>This chapter will familiarise you with how to use the HornetQ server.</p><p>We'll show where it is, how to start and stop it, and we'll describe the directory layout
        and what all the files are and what they do.</p><p>For the remainder of this chapter when we talk about the HornetQ server we mean the
        HornetQ standalone server, in its default configuration with a JMS Service and JNDI service
        enabled.</p><p>When running embedded in JBoss Application Server the layout may be slightly different but
        by-and-large will be the same.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e638"></a>6.1.&nbsp;Starting and Stopping the standalone server</h2></div></div><div></div></div><p>In the distribution you will find a directory called <tt class="literal">bin</tt>.</p><p><tt class="literal">cd</tt> into that directory and you'll find a unix/linux script called
                <tt class="literal">run.sh</tt> and a windows batch file called <tt class="literal">run.bat</tt></p><p>To run on Unix/Linux type <tt class="literal">./run.sh</tt></p><p>To run on Windows type <tt class="literal">run.bat</tt></p><p>These scripts are very simple and basically just set-up the classpath and some JVM
            parameters and start the JBoss Microcontainer. The Microcontainer is a light weight
            container used to deploy the HornetQ POJO's</p><p>To stop the server you'll also find a unix/linux script <tt class="literal">stop.sh</tt> and
            a windows batch file <tt class="literal">stop.bat</tt></p><p>To run on Unix/Linux type <tt class="literal">./stop.sh</tt></p><p>To run on Windows type <tt class="literal">stop.bat</tt></p><p>Please note that HornetQ requires a Java 6 or later runtime to run.</p><p>Both the run and the stop scripts use the config under <tt class="literal">config/stand-alone/non-clustered</tt> by default. The configuration can be
            changed by running <tt class="literal">./run.sh ../config/stand-alone/clustered</tt> or
            another config of your choosing. This is the same for the stop script and the windows
            bat files.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e690"></a>6.2.&nbsp;Server JVM settings</h2></div></div><div></div></div><p>The run scripts <tt class="literal">run.sh</tt> and <tt class="literal">run.bat</tt> set some JVM
            settings for tuning running on Java 6 and choosing the garbage collection policy. We
            recommend using a parallel garbage collection algorithm to smooth out latency and
            minimise large GC pauses.</p><p>By default HornetQ runs in a maximum of 1GiB of RAM. To increase the memory settings
            change the <tt class="literal">-Xms</tt> and <tt class="literal">-Xmx</tt> memory settings as you
            would for any Java program.</p><p>If you wish to add any more JVM arguments or tune the existing ones, the run scripts
            are the place to do it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e711"></a>6.3.&nbsp;Server classpath</h2></div></div><div></div></div><p>HornetQ looks for its configuration files on the Java classpath.</p><p>The scripts <tt class="literal">run.sh</tt> and <tt class="literal">run.bat</tt> specify the
            classpath when calling Java to run the server.</p><p>In the distribution, the run scripts will add the non clustered configuration
            directory to the classpath. This is a directory which contains a set of configuration
            files for running the HornetQ server in a basic non-clustered configuration. In the
            distribution this directory is <tt class="literal">config/stand-alone/non-clustered/</tt> from
            the root of the distribution.</p><p>The distribution contains several standard configuration sets for running:</p><div class="itemizedlist"><ul type="disc"><li><p>Non clustered stand-alone.</p></li><li><p>Clustered stand-alone</p></li><li><p>Non clustered in JBoss Application Server</p></li><li><p>Clustered in JBoss Application Server</p></li></ul></div><p>You can of course create your own configuration and specify any configuration
            directory when running the run script.</p><p>Just make sure the directory is on the classpath and HornetQ will search there when
            starting up.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using-server.library.path"></a>6.4.&nbsp;Library Path</h2></div></div><div></div></div><p>If you're using the <a href="#aio-journal">Asynchronous IO Journal</a> on
            Linux, you need to specify <tt class="literal">java.library.path</tt> as a property on your
            Java options. This is done automatically in the <tt class="literal">run.sh</tt> script.</p><p>If you don't specify <tt class="literal">java.library.path</tt> at your Java options then
            the JVM will use the environment variable <tt class="literal">LD_LIBRARY_PATH</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e770"></a>6.5.&nbsp;System properties</h2></div></div><div></div></div><p>HornetQ can take a system property on the command line for configuring logging.</p><p>For more information on configuring logging, please see <a href="#logging" title="Chapter&nbsp;42.&nbsp;Logging">Chapter&nbsp;42, <i>Logging</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using-server.configuration"></a>6.6.&nbsp;Configuration files</h2></div></div><div></div></div><p>The configuration directory is specified on the classpath in the run scripts <tt class="literal">run.sh</tt> and <tt class="literal">run.bat</tt> This directory can contain the
            following files.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">hornetq-beans.xml</tt> (or <tt class="literal">hornetq-jboss-beans.xml</tt> if you're running inside JBoss
                    Application Server). This is the JBoss Microcontainer beans file which defines
                    what beans the Microcontainer should create and what dependencies to enforce
                    between them. Remember that HornetQ is just a set of POJOs. In the stand-alone
                    server, it's the JBoss Microcontainer which instantiates these POJOs and
                    enforces dependencies between them and other beans. </p></li><li><p><tt class="literal">hornetq-configuration.xml</tt>. This is the main HornetQ
                    configuration file. All the parameters in this file are described in <a href="#configuration-index" title="Chapter&nbsp;47.&nbsp;Configuration Reference">Chapter&nbsp;47, <i>Configuration Reference</i></a>. Please see <a href="#usingserver.mainconfig" title="6.9.&nbsp;The main configuration file.">Section&nbsp;6.9, &#8220;The main configuration file.&#8221;</a> for more information on this file.</p></li><li><p><tt class="literal">hornetq-queues.xml</tt>. This file contains predefined queues,
                    queue settings and security settings. The file is optional - all this
                    configuration can also live in <tt class="literal">hornetq-configuration.xml</tt>. In
                    fact, the default configuration sets do not have a <tt class="literal">hornetq-queues.xml</tt> file. The purpose of allowing queues to be
                    configured in these files is to allow you to manage your queue configuration
                    over many files instead of being forced to maintain it in a single file. There
                    can be many <tt class="literal">hornetq-queues.xml</tt> files on the classpath. All
                    will be loaded if found.</p></li><li><p><tt class="literal">hornetq-users.xml</tt> HornetQ ships with a basic security
                    manager implementation which obtains user credentials from the <tt class="literal">hornetq-users.xml</tt> file. This file contains user, password and
                    role information. For more information on security, please see <a href="#security" title="Chapter&nbsp;31.&nbsp;Security">Chapter&nbsp;31, <i>Security</i></a>.</p></li><li><p><tt class="literal">hornetq-jms.xml</tt> The distro configuration by default
                    includes a server side JMS service which mainly deploys JMS Queues, Topics and
                    ConnectionFactorys from this file into JNDI. If you're not using JMS, or you
                    don't need to deploy JMS objects on the server side, then you don't need this
                    file. For more information on using JMS, please see <a href="#using-jms" title="Chapter&nbsp;7.&nbsp;Using JMS">Chapter&nbsp;7, <i>Using JMS</i></a>.</p></li><li><p><tt class="literal">logging.properties</tt> This is used to configure the logging
                    handlers used by the Java logger. For more information on configuring logging,
                    please see <a href="#logging" title="Chapter&nbsp;42.&nbsp;Logging">Chapter&nbsp;42, <i>Logging</i></a>.</p></li><li><p><tt class="literal">log4j.xml</tt> This is the Log4j configuration if the Log4j
                    handler is configured.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The property <tt class="literal">file-deployment-enabled</tt> in the <tt class="literal">hornetq-configuration.xml</tt> configuration when set to false means that
                the other configuration files are not loaded. This is true by default.</p></div><p>It is also possible to use system property substitution in all the configuration
            files. by replacing a value with the name of a system property. Here is an example of
            this with a connector configuration:</p><pre class="programlisting">&lt;connector name="netty"&gt;
         &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory
           &lt;/factory-class&gt;
         &lt;param key="host"  value="${hornetq.remoting.netty.host:localhost}" type="String"/&gt;
         &lt;param key="port"  value="${hornetq.remoting.netty.port:5445}" type="Integer"/&gt;
&lt;/connector&gt;</pre><p>Here you can see we have replaced 2 values with system properties <tt class="literal">hornetq.remoting.netty.host</tt> and <tt class="literal">hornetq.remoting.netty.port</tt>. These values will be replaced by the value
            found in the system property if there is one, if not they default back to localhost or
            5445 respectively. It is also possible to not supply a default. i.e. <tt class="literal">${hornetq.remoting.netty.host}</tt>, however the system property
                <span class="emphasis"><em>must</em></span> be supplied in that case.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="server.microcontainer.configuration"></a>6.7.&nbsp;JBoss Microcontainer Beans File</h2></div></div><div></div></div><p>The stand-alone server is basically a set of POJOs which are instantiated by the light
                weight<a href="http://www.jboss.org/jbossmc/" target="_top"> JBoss Microcontainer
            </a>engine.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A beans file is also needed when the server is deployed in the JBoss Application
                Server but this will deploy a slightly different set of objects since the
                Application Server will already have things like security etc deployed.</p></div><p>Let's take a look at an example beans file from the stand-alone server:</p><p>
            </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;

&lt;bean name="Naming" class="org.jnp.server.NamingBeanImpl"/&gt;

&lt;!-- JNDI server. Disable this if you don't want JNDI --&gt;
&lt;bean name="JNDIServer" class="org.jnp.server.Main"&gt;
   &lt;property name="namingInfo"&gt;
      &lt;inject bean="Naming"/&gt;
   &lt;/property&gt;
   &lt;property name="port"&gt;1099&lt;/property&gt;
   &lt;property name="bindAddress"&gt;localhost&lt;/property&gt;
   &lt;property name="rmiPort"&gt;1098&lt;/property&gt;
   &lt;property name="rmiBindAddress"&gt;localhost&lt;/property&gt;
&lt;/bean&gt;

&lt;!-- MBean server --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="java.lang.management.ManagementFactory"
      factoryMethod="getPlatformMBeanServer"/&gt;
&lt;/bean&gt; 

&lt;!-- The core configuration --&gt;
&lt;bean name="Configuration" class="org.hornetq.core.config.impl.FileConfiguration"&gt;
&lt;/bean&gt;

&lt;!-- The security manager --&gt;
&lt;bean name="HornetQSecurityManager" 
      class="org.hornetq.spi.core.security.HornetQSecurityManagerImpl"&gt;
   &lt;start ignored="true"/&gt;
   &lt;stop ignored="true"/&gt;
&lt;/bean&gt;

&lt;!-- The core server --&gt;
&lt;bean name="HornetQServer" class="org.hornetq.core.server.impl.HornetQServerImpl"&gt;
   &lt;start ignored="true"/&gt;
   &lt;stop ignored="true"/&gt;  
   &lt;constructor&gt;
      &lt;parameter&gt;
         &lt;inject bean="Configuration"/&gt;
      &lt;/parameter&gt;
      &lt;parameter&gt;
         &lt;inject bean="MBeanServer"/&gt;
      &lt;/parameter&gt;
      &lt;parameter&gt;
         &lt;inject bean="HornetQSecurityManager"/&gt;
      &lt;/parameter&gt;        
   &lt;/constructor&gt;         
&lt;/bean&gt;

&lt;!-- The JMS server --&gt;
&lt;bean name="JMSServerManager" 
      class="org.hornetq.jms.server.impl.JMSServerManagerImpl"&gt;
   &lt;constructor&gt;         
      &lt;parameter&gt;
         &lt;inject bean="HornetQServer"/&gt;
      &lt;/parameter&gt;         
   &lt;/constructor&gt;
&lt;/bean&gt;

&lt;/deployment&gt;</pre><p>
        </p><p>We can see that, as well as the core HornetQ server, the stand-alone server
            instantiates various different POJOs, lets look at them in turn:</p><div class="itemizedlist"><ul type="disc"><li><p>JNDIServer</p><p>Many clients like to look up JMS Objects from JNDI so we provide a JNDI server
                    for them to do that. If you don't need JNDI this can be commented out or
                    removed.</p></li><li><p>MBeanServer</p><p>In order to provide a JMX management interface a JMS MBean server is necessary
                    in which to register the management objects. Normally this is just the default
                    platform MBean server available in the JVM instance. If you don't want to
                    provide a JMX management interface this can be commented out or removed.</p></li><li><p>Configuration</p><p>The HornetQ server is configured with a Configuration object. In the default
                    stand-alone set-up it uses a FileConfiguration object which knows to read
                    configuration information from the file system. In different configurations such
                    as embedded you might want to provide configuration information from somewhere
                    else.</p></li><li><p>Security Manager. The security manager used by the messaging server is
                    pluggable. The default one used just reads user-role information from the
                        <tt class="literal">hornetq-users.xml</tt> file on disk. However it can be
                    replaced by a JAAS security manager, or when running inside JBoss Application
                    Server it can be configured to use the JBoss AS security manager for tight
                    integration with JBoss AS security. If you've disabled security altogether you
                    can remove this too.</p></li><li><p>HornetQServer</p><p>This is the core server. It's where 99% of the magic happens</p></li><li><p><a name="bean-jmsservermanager"></a>JMSServerManager</p><p>This deploys any JMS Objects such as JMS Queues, Topics and ConnectionFactory
                    instances from <tt class="literal">hornetq-jms.xml</tt> files on the disk. It also
                    provides a simple management API for manipulating JMS Objects. On the whole it
                    just translates and delegates its work to the core server. If you don't need to
                    deploy JMS Queues, Topics and ConnectionFactorys from server side configuration
                    and don't require the JMS management interface this can be disabled.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="server.microkernel.configuration"></a>6.8.&nbsp;JBoss AS4 MBean Service.</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The section is only to configure HornetQ on JBoss AS4. The service funtionality is
                similar to Microcontainer Beans</p></div><p>
            </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;server&gt;

   &lt;mbean code="org.hornetq.service.HornetQFileConfigurationService"
      name="org.hornetq:service=HornetQFileConfigurationService"&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.hornetq.service.JBossASSecurityManagerService"
      name="org.hornetq:service=JBossASSecurityManagerService"&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.hornetq.service.HornetQStarterService" 
      name="org.hornetq:service=HornetQStarterService"&gt;
      &lt;!--lets let the JMS Server start us--&gt;
         &lt;attribute name="Start"&gt;false&lt;/attribute&gt;

      &lt;depends optional-attribute-name="SecurityManagerService"
         proxy-type="attribute"&gt;org.hornetq:service=JBossASSecurityManagerService&lt;/depends&gt;
      &lt;depends optional-attribute-name="ConfigurationService"
         proxy-type="attribute"&gt;org.hornetq:service=HornetQFileConfigurationService&lt;/depends&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.hornetq.service.HornetQJMSStarterService"
      name="org.hornetq:service=HornetQJMSStarterService"&gt;
      &lt;depends optional-attribute-name="HornetQServer"
         proxy-type="attribute"&gt;org.hornetq:service=HornetQStarterService&lt;/depends&gt;
   &lt;/mbean&gt;
   
&lt;/server&gt;
            </pre><p>
        </p><p>This jboss-service.xml configuration file is included inside the hornetq-service.sar
            on AS4 with embebbed HornetQ. As you can see, on this configuration file we are starting
            various services:</p><div class="itemizedlist"><ul type="disc"><li><p>HornetQFileConfigurationService</p><p>This is an MBean Service that takes care of the life cycle of the <tt class="literal">FileConfiguration POJO</tt></p></li><li><p>JBossASSecurityManagerService</p><p>This is an MBean Service that takes care of the lifecycle of the <tt class="literal">JBossASSecurityManager</tt> POJO</p></li><li><p>HornetQStarterService</p><p>This is an MBean Service that controls the main <tt class="literal">HornetQServer</tt> POJO.
                   this has a dependency on JBossASSecurityManagerService and HornetQFileConfigurationService MBeans</p></li><li><p>HornetQJMSStarterService</p><p>This is an MBean Service that controls the <tt class="literal">JMSServerManagerImpl</tt> POJO.
                   If you aren't using jms this can be removed.</p></li><li><p>JMSServerManager</p><p>Has the responsibility to start the JMSServerManager and the same behaviour that JMSServerManager Bean</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="usingserver.mainconfig"></a>6.9.&nbsp;The main configuration file.</h2></div></div><div></div></div><p>The configuration for the HornetQ core server is contained in <tt class="literal">hornetq-configuration.xml</tt>. This is what the FileConfiguration bean uses
            to configure the messaging server.</p><p>There are many attributes which you can configure HornetQ. In most cases the defaults
            will do fine, in fact every attribute can be defaulted which means a file with a single
            empty <tt class="literal">configuration</tt> element is a valid configuration file. The
            different configuration will be explained throughout the manual or you can refer to the
            configuration reference <a href="#configuration-index" title="Chapter&nbsp;47.&nbsp;Configuration Reference">here</a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="using-jms"></a>Chapter&nbsp;7.&nbsp;Using JMS</h2></div></div><div></div></div><p>Although HornetQ provides a JMS agnostic messaging API, many users will be more
        comfortable using JMS.</p><p>JMS is a very popular API standard for messaging, and most messaging systems provide a JMS
        API. If you are completely new to JMS we suggest you follow the<a href="http://java.sun.com/products/jms/tutorial/1_3_1-fcs/doc/jms_tutorialTOC.html" target="_top"> Sun
            JMS tutorial</a> - a full JMS tutorial is out of scope for this guide.</p><p>HornetQ also ships with a wide range of examples, many of which demonstrate JMS API usage.
        A good place to start would be to play around with the simple JMS Queue and Topic example,
        but we also provide examples for many other parts of the JMS API. A full description of the
        examples is available in <a href="#examples" title="Chapter&nbsp;11.&nbsp;Examples">Chapter&nbsp;11, <i>Examples</i></a>.</p><p>In this section we'll go through the main steps in configuring the server for JMS and
        creating a simple JMS program. We'll also show how to configure and use JNDI, and also how
        to use JMS with HornetQ without using any JNDI.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1032"></a>7.1.&nbsp;A simple ordering system</h2></div></div><div></div></div><p>For this chapter we're going to use a very simple ordering system as our example. It's
            a somewhat contrived example because of its extreme simplicity, but it serves to
            demonstrate the very basics of setting up and using JMS.</p><p>We will have a single JMS Queue called <tt class="literal">OrderQueue</tt>, and we will have
            a single <tt class="literal">MessageProducer</tt> sending an order message to the queue and a
            single <tt class="literal">MessageConsumer</tt> consuming the order message from the
            queue.</p><p>The queue will be a <tt class="literal">durable</tt> queue, i.e. it will survive a server
            restart or crash. We also want to predeploy the queue, i.e. specify the queue in the
            server JMS configuration so it's created automatically without us having to explicitly
            create it from the client.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using-jms.server.configuration"></a>7.2.&nbsp;JMS Server Configuration</h2></div></div><div></div></div><p>The file <tt class="literal">hornetq-jms.xml</tt> on the server classpath contains any JMS
            Queue, Topic and ConnectionFactory instances that we wish to create and make available
            to lookup via the JNDI.</p><p>A JMS ConnectionFactory object is used by the client to make connections to the
            server. It knows the location of the server it is connecting to, as well as many other
            configuration parameters. In most cases the defaults will be acceptable.</p><p>We'll deploy a single JMS Queue and a single JMS Connection Factory instance on the
            server for this example but there are no limits to the number of Queues, Topics and
            Connection Factory instances you can deploy from the file. Here's our
            configuration:</p><pre class="programlisting">
&lt;configuration xmlns="urn:hornetq" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:hornetq ../schemas/hornetq-jms.xsd "&gt;
    
    &lt;connection-factory name="ConnectionFactory"&gt;
        &lt;connectors&gt;
           &lt;connector-ref connector-name="netty"/&gt;
        &lt;/connectors&gt;
        &lt;entries&gt;
            &lt;entry name="ConnectionFactory"/&gt;           
        &lt;/entries&gt;
    &lt;/connection-factory&gt;
    
    &lt;queue name="OrderQueue"&gt;
        &lt;entry name="queues/OrderQueue"/&gt;
    &lt;/queue&gt;
    
&lt;/configuration&gt; 
        </pre><p>We deploy one ConnectionFactory called <tt class="literal">ConnectionFactory</tt> and bind
            it in just one place in JNDI as given by the <tt class="literal">entry</tt> element.
            ConnectionFactory instances can be bound in many places in JNDI if you require. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The JMS connection factory references a <tt class="literal">connector</tt> called
                    <tt class="literal">netty</tt>. This is a reference to a connector object deployed in
                the main core configuration file <tt class="literal">hornetq-configuration.xml</tt> which
                defines the transport and parameters used to actually connect to the server.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1087"></a>7.3.&nbsp;JNDI configuration</h2></div></div><div></div></div><p>When using JNDI from the client side you need to specify a set of JNDI properties
            which tell the JNDI client where to locate the JNDI server, amongst other things. These
            are often specified in a file called <tt class="literal">jndi.properties</tt> on the client
            classpath, or you can specify them directly when creating the JNDI initial context. A
            full JNDI tutorial is outside the scope of this document, please see the <a href="http://java.sun.com/products/jndi/tutorial/TOC.html" target="_top">Sun JNDI tutorial</a>
            for more information on how to use JNDI.</p><p>For talking to the JBoss JNDI Server, the jndi properties will look something like
            this:</p><pre class="programlisting">
java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory
java.naming.provider.url=jnp://myhost:1099
java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces                        
        </pre><p>Where <tt class="literal">myhost</tt> is the hostname or IP address of the JNDI server. 1099
            is the port used by the JNDI server and may vary depending on how you have configured
            your JNDI server.</p><p>In the default standalone configuration, JNDI server ports are configured in the file
                <tt class="literal">hornetq-beans.xml</tt> by setting properties on the <tt class="literal">JNDIServer</tt> bean:</p><pre class="programlisting">
&lt;bean name="JNDIServer" class="org.jnp.server.Main"&gt;
    &lt;property name="namingInfo"&gt;
        &lt;inject bean="Naming"/&gt;
    &lt;/property&gt;
    &lt;property name="port"&gt;1099&lt;/property&gt;
    &lt;property name="bindAddress"&gt;localhost&lt;/property&gt;
    &lt;property name="rmiPort"&gt;1098&lt;/property&gt;
    &lt;property name="rmiBindAddress"&gt;localhost&lt;/property&gt;
&lt;/bean&gt;                        
        </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you want your JNDI server to be available to non local clients make sure you
                change it's bind address to something other than <tt class="literal">localhost</tt>!</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The JNDIServer bean must be defined <span class="emphasis"><em>only when HornetQ is running in
                    stand-alone mode</em></span>. When HornetQ is integrated to JBoss Application
                Server, JBoss AS will provide a ready-to-use JNDI server without any additional
                configuration.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1129"></a>7.4.&nbsp;The code</h2></div></div><div></div></div><p>Here's the code for the example:</p><p>First we'll create a JNDI initial context from which to lookup our JMS objects:</p><pre class="programlisting">InitialContect ic = new InitialContext();</pre><p>Now we'll look up the connection factory:</p><pre class="programlisting">ConnectionFactory cf = (ConnectionFactory)ic.lookup("/ConnectionFactory");</pre><p>And look up the Queue:</p><pre class="programlisting">Queue orderQueue = (Queue)ic.lookup("/queues/OrderQueue");</pre><p>Next we create a JMS connection using the connection factory:</p><pre class="programlisting">Connection connection = cf.createConnection();</pre><p>And we create a non transacted JMS Session, with AUTO_ACKNOWLEDGE acknowledge
            mode:</p><pre class="programlisting">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</pre><p>We create a MessageProducer that will send orders to the queue:</p><pre class="programlisting">MessageProducer producer = session.createProducer(orderQueue);</pre><p>And we create a MessageConsumer which will consume orders from the queue:</p><pre class="programlisting">MessageConsumer consumer = session.createConsumer(orderQueue);</pre><p>We make sure we start the connection, or delivery won't occur on it:</p><pre class="programlisting">connection.start();</pre><p>We create a simple TextMessage and send it:</p><pre class="programlisting">TextMessage message = session.createTextMessage("This is an order");
producer.send(message);</pre><p>And we consume the message:</p><pre class="programlisting">TextMessage receivedMessage = (TextMessage)consumer.receive();
System.out.println("Got order: " + receivedMessage.getText());
        </pre><p>It's as simple as that. For a wide range of working JMS examples please see the
            examples directory in the distribution.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Please note that JMS connections, sessions, producers and consumers are
                    <span class="emphasis"><em>designed to be re-used</em></span>.</p><p>It's an anti-pattern to create new connections, sessions, producers and consumers
                for each message you produce or consume. If you do this, your application will
                perform very poorly. This is discussed further in the section on performance tuning
                    <a href="#perf-tuning" title="Chapter&nbsp;46.&nbsp;Performance Tuning">Chapter&nbsp;46, <i>Performance Tuning</i></a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1186"></a>7.5.&nbsp;Directly instantiating JMS Resources without using JNDI</h2></div></div><div></div></div><p>Although it's a very common JMS usage pattern to lookup JMS <span class="emphasis"><em>Administered
                Objects</em></span> (that's JMS Queue, Topic and ConnectionFactory instances) from
            JNDI, in some cases a JNDI server is not available and you still want to use JMS, or you
            just think "Why do I need JNDI? Why can't I just instantiate these objects
            directly?"</p><p>With HornetQ you can do exactly that. HornetQ supports the direct instantiation of JMS
            Queue, Topic and ConnectionFactory instances, so you don't have to use JNDI at
            all.</p><p>For a full working example of direct instantiation please see the JMS examples in
                <a href="#examples" title="Chapter&nbsp;11.&nbsp;Examples">Chapter&nbsp;11, <i>Examples</i></a>.</p><p>Here's our simple example, rewritten to not use JNDI at all:</p><p>We create the JMS ConnectionFactory object via the HornetQJMSClient Utility class,
            note we need to provide connection parameters and specify which transport we are using,
            for more information on connectors please see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a>.</p><pre class="programlisting">              
TransportConfiguration transportConfiguration = 
                     new TransportConfiguration(NettyConnectorFactory.class.getName());                
ConnectionFactory cf = HornetQJMSClient.createConnectionFactory(transportConfiguration);
        </pre><p>We also create the JMS Queue object via the HornetQJMSClient Utility class:</p><pre class="programlisting">Queue orderQueue = HornetQJMSClient.createQueue("OrderQueue");</pre><p>Next we create a JMS connection using the connection factory:</p><pre class="programlisting">Connection connection = cf.createConnection();</pre><p>And we create a non transacted JMS Session, with AUTO_ACKNOWLEDGE acknowledge
            mode:</p><pre class="programlisting">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</pre><p>We create a MessageProducer that will send orders to the queue:</p><pre class="programlisting">MessageProducer producer = session.createProducer(orderQueue);</pre><p>And we create a MessageConsumer which will consume orders from the queue:</p><pre class="programlisting">MessageConsumer consumer = session.createConsumer(orderQueue);</pre><p>We make sure we start the connection, or delivery won't occur on it:</p><pre class="programlisting">connection.start();</pre><p>We create a simple TextMessage and send it:</p><pre class="programlisting">TextMessage message = session.createTextMessage("This is an order");
producer.send(message);</pre><p>And we consume the message:</p><pre class="programlisting">TextMessage receivedMessage = (TextMessage)consumer.receive();
System.out.println("Got order: " + receivedMessage.getText());
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using-jms.clientid"></a>7.6.&nbsp;Setting The Client ID</h2></div></div><div></div></div><p>This represents the client id for a JMS client and is needed for creating durable
            subscriptions. It is possible to configure this on the connection factory and can be set
            via the <tt class="literal">client-id</tt> element. Any connection created by this connection
            factory will have this set as its client id.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using-jms.dupsokbatchsize"></a>7.7.&nbsp;Setting The Batch Size for DUPS_OK </h2></div></div><div></div></div><p>When the JMS acknowledge mode is set to <tt class="literal">DUPS_OK</tt> it is possible to
            configure the consumer so that it sends acknowledgements in batches rather that one at a
            time, saving valuable bandwidth. This can be configured via the connection factory via
            the <tt class="literal">dups-ok-batch-size</tt> element and is set in bytes. The default is
            1024 * 1024 bytes = 1 MiB.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using-jms.txbatchsize"></a>7.8.&nbsp;Setting The Transaction Batch Size</h2></div></div><div></div></div><p>When receiving messages in a transaction it is possible to configure the consumer to
            send acknowledgements in batches rather than individually saving valuable bandwidth.
            This can be configured on the connection factory via the <tt class="literal">transaction-batch-size</tt> element and is set in bytes. The default is 1024 *
            1024.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="using-core"></a>Chapter&nbsp;8.&nbsp;Using Core</h2></div></div><div></div></div><p>HornetQ core is a completely JMS-agnostic messaging system with its own non-JMS API. We
        call this the <span class="emphasis"><em>core API</em></span>.</p><p>If you don't want to use JMS you can use the core API directly. The core API provides all
        the functionality of JMS but without much of the complexity. It also provides features that
        are not available using JMS.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1294"></a>8.1.&nbsp;Core Messaging Concepts</h2></div></div><div></div></div><p>Some of the core messaging concepts are similar to JMS concepts, but core messaging
            concepts differ in some ways. In general the core messaging API is simpler than the JMS
            API, since we remove distinctions between queues, topics and subscriptions. We'll
            discuss each of the major core messaging concepts in turn, but to see the API in detail,
            please consult the Javadoc.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1299"></a>8.1.1.&nbsp;Message</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>A message is the unit of data which is sent between clients and
                        servers.</p></li><li><p>A message has a body which is a buffer containing convenient methods for
                        reading and writing data into it.</p></li><li><p>A message has a set of properties which are key-value pairs. Each property
                        key is a string and property values can be of type integer, long, short,
                        byte, byte[], String, double, float or boolean.</p></li><li><p>A message has an <span class="emphasis"><em>address</em></span> it is being sent to. When
                        the message arrives on the server it is routed to any queues that are bound
                        to the address - if the queues are bound with any filter, the message will
                        only be routed to that queue if the filter matches. An address may have many
                        queues bound to it or even none. There may also be entities other than
                        queues, like <span class="italic">diverts</span> bound to
                        addresses.</p></li><li><p>Messages can be either durable or non durable. Durable messages in a
                        durable queue will survive a server crash or restart. Non durable messages
                        will never survive a server crash or restart.</p></li><li><p>Messages can be specified with a priority value between 0 and 9. 0
                        represents the lowest priority and 9 represents the highest. HornetQ will
                        attempt to deliver higher priority messages before lower priority
                        ones.</p></li><li><p>Messages can be specified with an optional expiry time. HornetQ will not
                        deliver messages after its expiry time has been exceeded.</p></li><li><p>Messages also have an optional timestamp which represents the time the
                        message was sent.</p></li><li><p>HornetQ also supports the sending/consuming of very large messages - much
                        larger than can fit in available RAM at any one time.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1336"></a>8.1.2.&nbsp;Address</h3></div></div><div></div></div><p>A server maintains a mapping between an address and a set of queues. Zero or more
                queues can be bound to a single address. Each queue can be bound with an optional
                message filter. When a message is routed, it is routed to the set of queues bound to
                the message's address. If any of the queues are bound with a filter expression, then
                the message will only be routed to the subset of bound queues which match that
                filter expression.</p><p>Other entities, such as <span class="italic">diverts</span> can also be
                bound to an address and messages will also be routed there.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In core, there is no concept of a Topic, Topic is a JMS only term. Instead, in
                    core, we just deal with <span class="emphasis"><em>addresses</em></span> and
                        <span class="emphasis"><em>queues</em></span>.</p><p>For example, a JMS topic would implemented by a single address to which many
                    queues are bound. Each queue represents a subscription of the topic. A JMS Queue
                    would be implemented as a single address to which one queue is bound - that
                    queue represents the JMS queue.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1357"></a>8.1.3.&nbsp;Queue</h3></div></div><div></div></div><p>Queues can be durable, meaning the messages they contain survive a server crash or
                restart, as long as the messages in them are durable. Non durable queues do not
                survive a server restart or crash even if the messages they contain are
                durable.</p><p>Queues can also be temporary, meaning they are automatically deleted when the
                client connection is closed, if they are not explicitly deleted before that.</p><p>Queues can be bound with an optional filter expression. If a filter expression is
                supplied then the server will only route messages that match that filter expression
                to any queues bound to the address.</p><p>Many queues can be bound to a single address. A particular queue is only bound to
                a maximum of one address.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1368"></a>8.1.4.&nbsp;ClientSessionFactory</h3></div></div><div></div></div><p>Clients use <tt class="literal">ClientSessionFactory</tt> instances to create <tt class="literal">ClientSession</tt> instances. <tt class="literal">ClientSessionFactory</tt>
                instances know how to connect to the server to create sessions, and are configurable
                with many settings.</p><p><tt class="literal">ClientSessionFactory</tt> instances are created using the <tt class="literal">HornetQClient</tt> factory class.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1389"></a>8.1.5.&nbsp;ClientSession</h3></div></div><div></div></div><p>A client uses a ClientSession for consuming and producing messages and for
                grouping them in transactions. ClientSession instances can support both
                transactional and non transactional semantics and also provide an <tt class="literal">XAResource</tt> interface so messaging operations can be performed as part
                of a <a href="http://java.sun.com/javaee/technologies/jta/index.jsp" target="_top">JTA</a>
                transaction.</p><p>ClientSession instances group ClientConsumers and ClientProducers.</p><p>ClientSession instances can be registered with an optional <tt class="literal">SendAcknowledgementHandler</tt>. This allows your client code to be
                notified asynchronously when sent messages have successfully reached the server.
                This unique HornetQ feature, allows you to have full guarantees that sent messages
                have reached the server without having to block on each message sent until a
                response is received. Blocking on each messages sent is costly since it requires a
                network round trip for each message sent. By not blocking and receiving send
                acknowledgements asynchronously you can create true end to end asynchronous systems
                which is not possible using the standard JMS API. For more information on this
                advanced feature please see the section <a href="#send-guarantees" title="Chapter&nbsp;20.&nbsp;Guarantees of sends and commits">Chapter&nbsp;20, <i>Guarantees of sends and commits</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1409"></a>8.1.6.&nbsp;ClientConsumer</h3></div></div><div></div></div><p>Clients use <tt class="literal">ClientConsumer</tt> instances to consume messages from a
                queue. Core Messaging supports both synchronous and asynchronous message consumption
                semantics. <tt class="literal">ClientConsumer</tt> instances can be configured with an
                optional filter expression and will only consume messages which match that
                expression.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1420"></a>8.1.7.&nbsp;ClientProducer</h3></div></div><div></div></div><p>Clients create <tt class="literal">ClientProducer</tt> instances on <tt class="literal">ClientSession</tt> instances so they can send messages. ClientProducer
                instances can specify an address to which all sent messages are routed, or they can
                have no specified address, and the address is specified at send time for the
                message.</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Please note that ClientSession, ClientProducer and ClientConsumer instances are
                <span class="emphasis"><em>designed to be re-used</em></span>.</p><p>It's an anti-pattern to create new ClientSession, ClientProducer and ClientConsumer instances
                for each message you produce or consume. If you do this, your application will
                perform very poorly. This is discussed further in the section on performance tuning
                <a href="#perf-tuning" title="Chapter&nbsp;46.&nbsp;Performance Tuning">Chapter&nbsp;46, <i>Performance Tuning</i></a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1441"></a>8.2.&nbsp;A simple example of using Core</h2></div></div><div></div></div><p>Here's a very simple program using the core messaging API to send and receive a
            message:</p><pre class="programlisting">
ClientSessionFactory factory =  HornetQClient.createClientSessionFactory(
                                        new TransportConfiguration(
                                           InVMConnectorFactory.class.getName()));

ClientSession session = factory.createSession();

session.createQueue("example", "example", true);

ClientProducer producer = session.createProducer("example");

ClientMessage message = session.createMessage(true);

message.getBodyBuffer().writeString("Hello");

producer.send(message);

session.start();

ClientConsumer consumer = session.createConsumer("example");

ClientMessage msgReceived = consumer.receive();

System.out.println("message = " + msgReceived.getBodyBuffer().readString());

session.close();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jms-core-mapping"></a>Chapter&nbsp;9.&nbsp;Mapping JMS Concepts to the Core API</h2></div></div><div></div></div><p>This chapter describes how JMS destinations are mapped to HornetQ addresses.</p><p>HornetQ core is JMS-agnostic. It does not have any concept of a JMS topic. A JMS topic is
        implemented in core as an address (the topic name) with zero or more queues bound to it.
        Each queue bound to that address represents a topic subscription. Likewise, a JMS queue is
        implemented as an address (the JMS queue name) with one single queue bound to it which
        represents the JMS queue.</p><p>By convention, all JMS queues map to core queues where the core queue name has the string
            <tt class="literal">jms.queue.</tt> prepended to it. E.g. the JMS queue with the name
        "orders.europe" would map to the core queue with the name "jms.queue.orders.europe". The
        address at which the core queue is bound is also given by the core queue name.</p><p>For JMS topics the address at which the queues that represent the subscriptions are bound
        is given by prepending the string "jms.topic." to the name of the JMS topic. E.g. the JMS
        topic with name "news.europe" would map to the core address "jms.topic.news.europe"</p><p>In other words if you send a JMS message to a JMS queue with name "orders.europe" it will
        get routed on the server to any core queues bound to the address "jms.queue.orders.europe".
        If you send a JMS message to a JMS topic with name "news.europe" it will get routed on the
        server to any core queues bound to the address "jms.topic.news.europe".</p><p>If you want to configure settings for a JMS Queue with the name "orders.europe", you need
        to configure the corresponding core queue "jms.queue.orders.europe":</p><pre class="programlisting">
&lt;!-- expired messages in JMS Queue "orders.europe"
    will be sent to the JMS Queue "expiry.europe" --&gt;
&lt;address-setting match="jms.queue.orders.europe"&gt;
   &lt;expiry-address&gt;jms.queue.expiry.europe&lt;/expiry-address&gt;
   ...
&lt;/address-setting&gt;
   </pre></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="client-classpath"></a>Chapter&nbsp;10.&nbsp;The Client Classpath</h2></div></div><div></div></div><p>HornetQ requires several jars on the <span class="emphasis"><em>Client Classpath</em></span> depending on
        whether the client uses HornetQ Core API, JMS, and JNDI.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>All the jars mentioned here can be found in the <tt class="literal">lib</tt> directory of
            the HornetQ distribution. Be sure you only use the jars from the correct version of the
            release, you <span class="emphasis"><em>must not</em></span> mix and match versions of jars from different
            HornetQ versions. Mixing and matching different jar versions may cause subtle errors and
            failures to occur.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1519"></a>10.1.&nbsp;HornetQ Core Client</h2></div></div><div></div></div><p>If you are using just a pure HornetQ Core client (i.e. no JMS) then you need <tt class="literal">hornetq-core-client.jar</tt> and
                <tt class="literal">netty.jar</tt> on your client classpath.</p><p>If the client runs inside a <span class="emphasis"><em>Java 5 virtual machine</em></span>, use instead <tt class="literal">hornetq-core-client-java5.jar</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1538"></a>10.2.&nbsp;JMS Client</h2></div></div><div></div></div><p>If you are using JMS on the client side, then you will also need to include <tt class="literal">hornetq-jms-client.jar</tt> and <tt class="literal">jboss-jms-api.jar</tt>.</p><p>If the client runs inside a <span class="emphasis"><em>Java 5 virtual machine</em></span>, include instead <tt class="literal">hornetq-jms-client-java5.jar</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="literal">jboss-jms-api.jar</tt> just contains Java EE API interface classes
                needed for the <tt class="literal">javax.jms.*</tt> classes. If you already have a jar
                with these interface classes on your classpath, you will not need it.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1565"></a>10.3.&nbsp;JMS Client with JNDI</h2></div></div><div></div></div><p>If you are looking up JMS resources from the JNDI server co-located with the HornetQ
            standalone server, you wil also need the jar <tt class="literal">jnp-client.jar</tt> jar on
            your client classpath as well as any other jars mentioned previously.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="examples"></a>Chapter&nbsp;11.&nbsp;Examples</h2></div></div><div></div></div><p>The HornetQ distribution comes with over 70 run out-of-the-box examples demonstrating many
        of the features.</p><p>The examples are available in the distribution, in the <tt class="literal">examples</tt>
        directory. Examples are split into JMS and core examples. JMS examples show how a particular
        feature can be used by a normal JMS client. Core examples show how the equivalent feature
        can be used by a core messaging client.</p><p>A set of Java EE examples are also provided which need the JBoss Application Server
        installed to be able to run.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1602"></a>11.1.&nbsp;JMS Examples</h2></div></div><div></div></div><p>To run a JMS example, simply <tt class="literal">cd</tt> into the appropriate example
            directory and type <tt class="literal">./build.sh</tt> (or <tt class="literal">build.bat</tt> if you
            are on Windows).</p><p>Here's a listing of the examples with a brief description.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="application-level-failover"></a>11.1.1.&nbsp;Application-Layer Failover</h3></div></div><div></div></div><p>HornetQ also supports Application-Layer failover, useful in the case that
                replication is not enabled on the server side.</p><p>With Application-Layer failover, it's up to the application to register a JMS
                    <tt class="literal">ExceptionListener</tt> with HornetQ which will be called by
                HornetQ in the event that connection failure is detected.</p><p>The code in the <tt class="literal">ExceptionListener</tt> then recreates the JMS
                connection, session, etc on another node and the application can continue.</p><p>Application-layer failover is an alternative approach to High Availability (HA).
                Application-layer failover differs from automatic failover in that some client side
                coding is required in order to implement this. Also, with Application-layer
                failover, since the old session object dies and a new one is created, any
                uncommitted work in the old session will be lost, and any unacknowledged messages
                might be redelivered.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.bridge"></a>11.1.2.&nbsp;Core Bridge Example</h3></div></div><div></div></div><p>The <tt class="literal">bridge</tt> example demonstrates a core bridge deployed on one
                server, which consumes messages from a local queue and forwards them to an address
                on a second server.</p><p>Core bridges are used to create message flows between any two HornetQ servers
                which are remotely separated. Core bridges are resilient and will cope with
                temporary connection failure allowing them to be an ideal choice for forwarding over
                unreliable connections, e.g. a WAN.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.browsers"></a>11.1.3.&nbsp;Browser</h3></div></div><div></div></div><p>The <tt class="literal">browser</tt> example shows you how to use a JMS <tt class="literal">QueueBrowser</tt> with HornetQ.</p><p>Queues are a standard part of JMS, please consult the JMS 1.1 specification for
                full details.</p><p> A <tt class="literal">QueueBrowser</tt> is used to look at messages on the queue
                without removing them. It can scan the entire content of a queue or only messages
                matching a message selector.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1663"></a>11.1.4.&nbsp;Client Kickoff</h3></div></div><div></div></div><p>The <tt class="literal">client-kickoff</tt> example shows how to terminate client
                connections given an IP address using the JMX management API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1671"></a>11.1.5.&nbsp;Client-Side Load-Balancing</h3></div></div><div></div></div><p>The <tt class="literal">client-side-load-balancing</tt> example demonstrates how
                sessions created from a single JMS <tt class="literal">Connection</tt> can
                be created to different nodes of the cluster. In other words it demonstrates how
                HornetQ does client-side load-balancing of sessions across the cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.clustered.grouping"></a>11.1.6.&nbsp;Clustered Grouping</h3></div></div><div></div></div><p>This is similar to the message grouping example except that it demonstrates it
                working over a cluster. Messages sent to different nodes with the same group id will
                be sent to the same node and the same consumer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1687"></a>11.1.7.&nbsp;Clustered Queue</h3></div></div><div></div></div><p>The <tt class="literal">clustered-queue</tt> example demonstrates a JMS queue deployed
                on two different nodes. The two nodes are configured to form a cluster. We then
                create a consumer for the queue on each node, and we create a producer on only one
                of the nodes. We then send some messages via the producer, and we verify that both
                consumers receive the sent messages in a round-robin fashion.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1695"></a>11.1.8.&nbsp;Clustered Standalone</h3></div></div><div></div></div><p>The <tt class="literal">clustered-standalone</tt> example demonstrates how to configure
                and starts 3 cluster nodes on the same machine to form a cluster. A subscriber for a
                JMS topic is created on each node, and we create a producer on only one of the
                nodes. We then send some messages via the producer, and we verify that the 3
                subscribers receive all the sent messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1703"></a>11.1.9.&nbsp;Clustered Topic</h3></div></div><div></div></div><p>The <tt class="literal">clustered-topic</tt> example demonstrates a JMS topic deployed
                on two different nodes. The two nodes are configured to form a cluster. We then
                create a subscriber on the topic on each node, and we create a producer on only one
                of the nodes. We then send some messages via the producer, and we verify that both
                subscribers receive all the sent messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.consumer-rate-limit"></a>11.1.10.&nbsp;Message Consumer Rate Limiting</h3></div></div><div></div></div><p>With HornetQ you can specify a maximum consume rate at which a JMS MessageConsumer
                will consume messages. This can be specified when creating or deploying the
                connection factory.</p><p>If this value is specified then HornetQ will ensure that messages are never
                consumed at a rate higher than the specified rate. This is a form of consumer
                throttling.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.dead-letter"></a>11.1.11.&nbsp;Dead Letter</h3></div></div><div></div></div><p>The <tt class="literal">dead-letter</tt> example shows you how to define and deal with
                dead letter messages. Messages can be delivered unsuccessfully (e.g. if the
                transacted session used to consume them is rolled back). </p><p>Such a message goes back to the JMS destination ready to be redelivered. However,
                this means it is possible for a message to be delivered again and again without any
                success and remain in the destination, clogging the system.</p><p>To prevent this, messaging systems define dead letter messages: after a specified
                unsuccessful delivery attempts, the message is removed from the destination and put
                instead in a dead letter destination where they can be consumed for further
                investigation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.delayed-redelivery"></a>11.1.12.&nbsp;Delayed Redelivery</h3></div></div><div></div></div><p>The <tt class="literal">delayed-redelivery</tt> example demonstrates how HornetQ can be
                configured to provide a delayed redelivery in the case a message needs to be
                redelivered.</p><p>Delaying redelivery can often be useful in the case that clients regularly fail or
                roll-back. Without a delayed redelivery, the system can get into a "thrashing"
                state, with delivery being attempted, the client rolling back, and delivery being
                re-attempted in quick succession, using up valuable CPU and network
                resources.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="divert-example"></a>11.1.13.&nbsp;Divert</h3></div></div><div></div></div><p>HornetQ diverts allow messages to be transparently "diverted" or copied from one
                address to another with just some simple configuration defined on the server
                side.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1745"></a>11.1.14.&nbsp;Durable Subscription</h3></div></div><div></div></div><p>The <tt class="literal">durable-subscription</tt> example shows you how to use a durable
                subscription with HornetQ. Durable subscriptions are a standard part of JMS, please
                consult the JMS 1.1 specification for full details.</p><p>Unlike non-durable subscriptions, the key function of durable subscriptions is
                that the messages contained in them persist longer than the lifetime of the
                subscriber - i.e. they will accumulate messages sent to the topic even if there is
                no active subscriber on them. They will also survive server restarts or crashes.
                Note that for the messages to be persisted, the messages sent to them must be marked
                as durable messages. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1755"></a>11.1.15.&nbsp;Embedded</h3></div></div><div></div></div><p>The <tt class="literal">embedded</tt> example shows how to embed the HornetQ server
                within your own code.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1763"></a>11.1.16.&nbsp;HTTP Transport</h3></div></div><div></div></div><p>The <tt class="literal">http-transport</tt> example shows you how to configure HornetQ
                to use the HTTP protocol as its transport layer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1771"></a>11.1.17.&nbsp;Instantiate JMS Objects Directly</h3></div></div><div></div></div><p>Usually, JMS Objects such as <tt class="literal">ConnectionFactory</tt>, <tt class="literal">Queue</tt> and <tt class="literal">Topic</tt> instances are looked up from JNDI
                before being used by the client code. This objects are called "administered objects"
                in JMS terminology.</p><p>However, in some cases a JNDI server may not be available or desired. To come to
                the rescue HornetQ also supports the direct instantiation of these administered
                objects on the client side so you don't have to use JNDI for JMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.interceptor"></a>11.1.18.&nbsp;Interceptor</h3></div></div><div></div></div><p>HornetQ allows an application to use an interceptor to hook into the messaging
                system. Interceptors allow you to handle various message events in HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.jaas"></a>11.1.19.&nbsp;JAAS</h3></div></div><div></div></div><p>The <tt class="literal">jaas</tt> example shows you how to configure HornetQ to use JAAS
                for security. HornetQ can leverage JAAS to delegate user authentication and
                authorization to existing security infrastructure.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.jms.jms-bridge"></a>11.1.20.&nbsp;JMS Bridge</h3></div></div><div></div></div><p>The <tt class="literal">jms-brige</tt> example shows how to setup a bridge
            between two standalone HornetQ servers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.jmx"></a>11.1.21.&nbsp;JMX Management</h3></div></div><div></div></div><p>The <tt class="literal">jmx</tt> example shows how to manage HornetQ using JMX.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.large-message"></a>11.1.22.&nbsp;Large Message</h3></div></div><div></div></div><p>The <tt class="literal">large-message</tt> example shows you how to send and receive
                very large messages with HornetQ. HornetQ supports the sending and receiving of huge
                messages, much larger than can fit in available RAM on the client or server.
                Effectively the only limit to message size is the amount of disk space you have on
                the server.</p><p>Large messages are persisted on the server so they can survive a server restart.
                In other words HornetQ doesn't just do a simple socket stream from the sender to the
                consumer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.last-value-queue"></a>11.1.23.&nbsp;Last-Value Queue</h3></div></div><div></div></div><p>The <tt class="literal">last-value-queue</tt> example shows you how to define and deal
                with last-value queues. Last-value queues are special queues which discard any
                messages when a newer message with the same value for a well-defined last-value
                property is put in the queue. In other words, a last-value queue only retains the
                last value.</p><p>A typical example for last-value queue is for stock prices, where you are only
                interested by the latest price for a particular stock.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1836"></a>11.1.24.&nbsp;Load Balanced Clustered Queue</h3></div></div><div></div></div><p>The <tt class="literal">clustered-queue</tt> example demonstrates a JMS queue deployed
                on two different nodes. The two nodes are configured to form a cluster.</p><p>We then create a consumer on the queue on each node, and we create a producer on
                only one of the nodes. We then send some messages via the producer, and we verify
                that both consumers receive the sent messages in a round-robin fashion.</p><p>In other words, HornetQ load balances the sent messages across all consumers on
                the cluster</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.management"></a>11.1.25.&nbsp;Management</h3></div></div><div></div></div><p>The <tt class="literal">management</tt> example shows how to manage HornetQ using JMS
                Messages to invoke management operations on the server.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.management-notifications"></a>11.1.26.&nbsp;Management Notification</h3></div></div><div></div></div><p>The <tt class="literal">management-notification</tt> example shows how to receive
                management notifications from HornetQ using JMS messages. HornetQ servers emit
                management notifications when events of interest occur (consumers are created or
                closed, addresses are created or deleted, security authentication fails,
                etc.).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.message-counters"></a>11.1.27.&nbsp;Message Counter</h3></div></div><div></div></div><p>The <tt class="literal">message-counters</tt> example shows you how to use message
                counters to obtain message information for a JMS queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.expiry"></a>11.1.28.&nbsp;Message Expiration</h3></div></div><div></div></div><p>The <tt class="literal">expiry</tt> example shows you how to define and deal with
                message expiration. Messages can be retained in the messaging system for a limited
                period of time before being removed. JMS specification states that clients should
                not receive messages that have been expired (but it does not guarantee this will not
                happen).</p><p>HornetQ can assign an expiry address to a given queue so that when messages
                are expired, they are removed from the queue and sent to the expiry address.
                These "expired" messages can later be consumed from the expiry address for
                further inspection.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.message-group"></a>11.1.29.&nbsp;Message Group</h3></div></div><div></div></div><p>The <tt class="literal">message-group</tt> example shows you how to configure and use
                message groups with HornetQ. Message groups allow you to pin messages so they are
                only consumed by a single consumer. Message groups are sets of messages that has the
                following characteristics:</p><p>
                </p><div class="itemizedlist"><ul type="disc"><li><p>Messages in a message group share the same group id, i.e. they have
                            same JMSXGroupID string property values</p></li><li><p>The consumer that receives the first message of a group will receive
                            all the messages that belongs to the group</p></li></ul></div><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.message-group2"></a>11.1.30.&nbsp;Message Group</h3></div></div><div></div></div><p>The <tt class="literal">message-group2</tt> example shows you how to configure and use
                message groups with HornetQ via a connection factory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.message-priority"></a>11.1.31.&nbsp;Message Priority</h3></div></div><div></div></div><p>Message Priority can be used to influence the delivery order for messages.</p><p>It can be retrieved by the message's standard header field 'JMSPriority' as
                defined in JMS specification version 1.1. </p><p>The value is of type integer, ranging from 0 (the lowest) to 9 (the highest). When
                messages are being delivered, their priorities will effect their order of delivery.
                Messages of higher priorities will likely be delivered before those of lower
                priorities. </p><p>Messages of equal priorities are delivered in the natural order of their arrival
                at their destinations. Please consult the JMS 1.1 specification for full
                details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.no-consumer-buffering"></a>11.1.32.&nbsp;No Consumer Buffering</h3></div></div><div></div></div><p>By default, HornetQ consumers buffer messages from the server in a client side
                buffer before you actually receive them on the client side. This improves
                performance since otherwise every time you called receive() or had processed the
                last message in a <tt class="literal">MessageListener onMessage()</tt> method, the HornetQ
                client would have to go the server to request the next message, which would then get
                sent to the client side, if one was available.</p><p>This would involve a network round trip for every message and reduce performance.
                Therefore, by default, HornetQ pre-fetches messages into a buffer on each
                consumer.</p><p>In some case buffering is not desirable, and HornetQ allows it to be switched off.
                This example demonstrates that.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.non-transaction-failover"></a>11.1.33.&nbsp;Non-Transaction Failover With Server Data Replication</h3></div></div><div></div></div><p>The <tt class="literal">non-transaction-failover</tt> example demonstrates two servers coupled
                as a live-backup pair for high availability (HA), and a client using a <span class="emphasis"><em>non-transacted
                </em></span> JMS session failing over from live to backup when the live server is
                crashed.</p><p>HornetQ implements failover of client connections between
                live and backup servers. This is implemented by the replication of state between
                live and backup nodes. When replication is configured and a live node crashes, the
                client connections can carry and continue to send and consume messages. When non-transacted
                 sessions are used, once and only once message delivery is not guaranteed and it is possible
                 that some messages will be lost or delivered twice.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.paging"></a>11.1.34.&nbsp;Paging</h3></div></div><div></div></div><p>The <tt class="literal">paging</tt> example shows how HornetQ can support huge queues
                even when the server is running in limited RAM. It does this by transparently
                    <span class="emphasis"><em>paging</em></span> messages to disk, and <span class="emphasis"><em>depaging</em></span>
                them when they are required.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.pre-acknowledge"></a>11.1.35.&nbsp;Pre-Acknowledge</h3></div></div><div></div></div><p>Standard JMS supports three acknowledgement modes:<tt class="literal">
                    AUTO_ACKNOWLEDGE</tt>, <tt class="literal">CLIENT_ACKNOWLEDGE</tt>, and <tt class="literal">DUPS_OK_ACKNOWLEDGE</tt>. For a full description on these modes please
                consult the JMS specification, or any JMS tutorial.</p><p>All of these standard modes involve sending acknowledgements from the client to
                the server. However in some cases, you really don't mind losing messages in event of
                failure, so it would make sense to acknowledge the message on the server before
                delivering it to the client. This example demonstrates how HornetQ allows this with
                an extra acknowledgement mode.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="producer-rate-limiting-example"></a>11.1.36.&nbsp;Message Producer Rate Limiting</h3></div></div><div></div></div><p>The <tt class="literal">producer-rte-limit</tt> example demonstrates how, with HornetQ,
                you can specify a maximum send rate at which a JMS message producer will send
                messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1982"></a>11.1.37.&nbsp;Queue</h3></div></div><div></div></div><p>A simple example demonstrating a JMS queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1987"></a>11.1.38.&nbsp;Message Redistribution</h3></div></div><div></div></div><p>The <tt class="literal">queue-message-redistribution</tt> example demonstrates message
                redistribution between queues with the same name deployed in different nodes of a
                cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1995"></a>11.1.39.&nbsp;Queue Requestor</h3></div></div><div></div></div><p>A simple example demonstrating a JMS queue requestor.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2000"></a>11.1.40.&nbsp;Queue with Message Selector</h3></div></div><div></div></div><p>The <tt class="literal">queue-selector</tt> example shows you how to selectively consume
                messages using message selectors with queue consumers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2008"></a>11.1.41.&nbsp;Reattach Node example</h3></div></div><div></div></div><p>The <tt class="literal">Reattach Node</tt> example shows how a client can try to reconnect to
               the same server instead of failing the connection immediately and
               notifying any user ExceptionListener objects. HornetQ can be configured to automatically
               retry the connection, and reattach to the server when it becomes available again across
               the network.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2016"></a>11.1.42.&nbsp;Request-Reply example</h3></div></div><div></div></div><p>A simple example showing the JMS request-response pattern.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.scheduled-message"></a>11.1.43.&nbsp;Scheduled Message</h3></div></div><div></div></div><p>The <tt class="literal">scheduled-message</tt> example shows you how to send a scheduled
                message to a JMS Queue with HornetQ. Scheduled messages won't get delivered until a
                specified time in the future.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2029"></a>11.1.44.&nbsp;Security</h3></div></div><div></div></div><p>The <tt class="literal">security</tt> example shows you how configure and use role based
                queue security with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="asynchronous-send-acknowledgements-example"></a>11.1.45.&nbsp;Send Acknowledgements</h3></div></div><div></div></div><p>The <tt class="literal">send-acknowledgements</tt> example shows you how to use
                HornetQ's advanced <span class="emphasis"><em>asynchronous send acknowledgements</em></span> feature
                to obtain acknowledgement from the server that sends have been received and
                processed in a separate stream to the sent messages. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2048"></a>11.1.46.&nbsp;SSL Transport</h3></div></div><div></div></div><p>The <tt class="literal">ssl-enabled</tt> shows you how to configure SSL with HornetQ to
                send and receive message.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2056"></a>11.1.47.&nbsp;Static Message Selector</h3></div></div><div></div></div><p>The <tt class="literal">static-selector</tt> example shows you how to configure a
                HornetQ core queue with static message selectors (filters).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2064"></a>11.1.48.&nbsp;Static Message Selector Using JMS</h3></div></div><div></div></div><p>The <tt class="literal">static-selector-jms</tt> example shows you how to configure a
                HornetQ queue with static message selectors (filters) using JMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2072"></a>11.1.49.&nbsp;Stomp</h3></div></div><div></div></div><p>The <tt class="literal">stomp</tt> example shows you how to configure a
                HornetQ server to send and receive Stomp messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2080"></a>11.1.50.&nbsp;Stomp Over Web Sockets</h3></div></div><div></div></div><p>The <tt class="literal">stomp-websockets</tt> example shows you how to configure a
                HornetQ server to send and receive Stomp messages directly from Web browsers (provided
                they support Web Sockets).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2088"></a>11.1.51.&nbsp;Symmetric Cluster</h3></div></div><div></div></div><p>The <tt class="literal">symmetric-cluster</tt> example demonstrates a symmetric cluster
                set-up with HornetQ.</p><p>HornetQ has extremely flexible clustering which allows you to set-up servers in
                many different topologies. The most common topology that you'll perhaps be familiar
                with if you are used to application server clustering is a symmetric cluster.</p><p>With a symmetric cluster, the cluster is homogeneous, i.e. each node is configured
                the same as every other node, and every node is connected to every other node in the
                cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2100"></a>11.1.52.&nbsp;Temporary Queue</h3></div></div><div></div></div><p>A simple example demonstrating how to use a JMS temporary queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2105"></a>11.1.53.&nbsp;Topic</h3></div></div><div></div></div><p>A simple example demonstrating a JMS topic.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="topic-hierarchy-example"></a>11.1.54.&nbsp;Topic Hierarchy</h3></div></div><div></div></div><p>HornetQ supports topic hierarchies. With a topic hierarchy you can register a
                subscriber with a wild-card and that subscriber will receive any messages sent to an
                address that matches the wild card.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2115"></a>11.1.55.&nbsp;Topic Selector 1</h3></div></div><div></div></div><p>The <tt class="literal">topic-selector-example1</tt> example shows you how to send
                message to a JMS Topic, and subscribe them using selectors with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2123"></a>11.1.56.&nbsp;Topic Selector 2</h3></div></div><div></div></div><p>The <tt class="literal">topic-selector-example2</tt> example shows you how to
                selectively consume messages using message selectors with topic consumers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.transaction-failover"></a>11.1.57.&nbsp;Transaction Failover With Data Replication</h3></div></div><div></div></div><p>The <tt class="literal">transaction-failover</tt> example demonstrates two servers coupled
                as a live-backup pair for high availability (HA), and a client using a transacted JMS
                session failing over from live to backup when the live server is
                crashed.</p><p>HornetQ implements failover of client connections between
                live and backup servers. This is implemented by the replication of data between
                live and backup nodes. When replication is configured and a live node crashes, the
                client connections can carry and continue to send and consume messages. When transacted
                sessions are used, once and only once message delivery is guaranteed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2141"></a>11.1.58.&nbsp;Transactional Session</h3></div></div><div></div></div><p>The <tt class="literal">transactional</tt> example shows you how to use a transactional
                Session with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2149"></a>11.1.59.&nbsp;XA Heuristic</h3></div></div><div></div></div><p>The <tt class="literal">xa-heuristic</tt> example shows you how to make an XA heuristic
                decision through HornetQ Management Interface. A heuristic decision is a unilateral
                decision to commit or rollback an XA transaction branch after it has been
                prepared.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2157"></a>11.1.60.&nbsp;XA Receive</h3></div></div><div></div></div><p>The <tt class="literal">xa-receive</tt> example shows you how message receiving behaves
                in an XA transaction in HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2165"></a>11.1.61.&nbsp;XA Send</h3></div></div><div></div></div><p>The <tt class="literal">xa-send</tt> example shows you how message sending behaves in an
                XA transaction in HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2173"></a>11.1.62.&nbsp;XA with Transaction Manager</h3></div></div><div></div></div><p>The <tt class="literal">xa-with-jta</tt> example shows you how to use JTA interfaces to
                control transactions with HornetQ.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2181"></a>11.2.&nbsp;Core API Examples</h2></div></div><div></div></div><p>To run a core example, simply <tt class="literal">cd</tt> into the appropriate example
            directory and type <tt class="literal">ant</tt></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.embedded"></a>11.2.1.&nbsp;Embedded</h3></div></div><div></div></div><p>This example shows how to embed the HornetQ server within your own code.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2196"></a>11.3.&nbsp;Java EE Examples</h2></div></div><div></div></div><p>Most of the Java EE examples can be run the following way. simply cd into the
            appropriate example directory and type <tt class="literal">ant deploy</tt>. This will create a
            new JBoss AS profile and start the server. When the server is started from a different
            window type <tt class="literal">ant run</tt> to run the example. Some examples require further
            steps, please refer to the examples documentation for further instructions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2207"></a>11.3.1.&nbsp;EJB/JMS Transaction</h3></div></div><div></div></div><p>An example that shows using an EJB and JMS together within a transaction.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2212"></a>11.3.2.&nbsp;HAJNDI (High Availability)</h3></div></div><div></div></div><p>A simple example demonstrating using JNDI within a cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2217"></a>11.3.3.&nbsp;Resource Adapter Configuration</h3></div></div><div></div></div><p>This example demonstrates how to configure several properties on the HornetQ JCA
                resource adaptor.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2222"></a>11.3.4.&nbsp;Resource Adapter Remote Server Configuration</h3></div></div><div></div></div><p>This example demonstrates how to configure the HornetQ resource adapter to talk to a remote HornetQ server</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.javaee.jms-bridge"></a>11.3.5.&nbsp;JMS Bridge</h3></div></div><div></div></div><p>An example demonstrating the use of the HornetQ JMS bridge.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2232"></a>11.3.6.&nbsp;MDB (Message Driven Bean)</h3></div></div><div></div></div><p>A simple example of a message driven bean.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2237"></a>11.3.7.&nbsp;Servlet Transport</h3></div></div><div></div></div><p>An example of how to use the HornetQ servlet transport.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2242"></a>11.3.8.&nbsp;Servlet SSL Transport</h3></div></div><div></div></div><p>An example of how to use the HornetQ servlet transport over SSL.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xa-recovery-example"></a>11.3.9.&nbsp;XA Recovery</h3></div></div><div></div></div><p>An example of how XA recovery works within the JBoss Application server using
                HornetQ.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="wildcard-routing"></a>Chapter&nbsp;12.&nbsp;Routing Messages With Wild Cards</h2></div></div><div></div></div><p>HornetQ allows the routing of messages via wildcard addresses.</p><p>If a queue is created with an address of say <tt class="literal">queue.news.#</tt> then it
        will receive any messages sent to addresses that match this, for instance <tt class="literal">queue.news.europe</tt> or <tt class="literal">queue.news.usa</tt> or <tt class="literal">queue.news.usa.sport</tt>. If you create a consumer on this queue, this allows a consumer to consume messages which are
        sent to a <span class="emphasis"><em>hierarchy</em></span> of addresses.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In JMS terminology this allows "topic hierarchies" to be created.</p></div><p>To enable this functionality set the property <tt class="literal">wild-card-routing-enabled</tt>
        in the <tt class="literal">hornetq-configuration.xml</tt> file to <tt class="literal">true</tt>. This is
            <tt class="literal">true</tt> by default.</p><p>For more information on the wild card syntax take a look at <a href="#wildcard-syntax" title="Chapter&nbsp;13.&nbsp;Understanding the HornetQ Wildcard Syntax">Chapter&nbsp;13, <i>Understanding the HornetQ Wildcard Syntax</i></a> chapter, also see <a href="#topic-hierarchy-example" title="11.1.54.&nbsp;Topic Hierarchy">Section&nbsp;11.1.54, &#8220;Topic Hierarchy&#8221;</a>.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="wildcard-syntax"></a>Chapter&nbsp;13.&nbsp;Understanding the HornetQ Wildcard Syntax</h2></div></div><div></div></div><p>HornetQ uses a specific syntax for representing wildcards in security settings,
        address settings and when creating consumers.</p><p>The syntax is similar to that used by <a href="http://www.amqp.org" target="_top">AMQP</a>.</p><p>A HornetQ wildcard expression contains words delimited by the character '<tt class="literal">.</tt>' (full stop).</p><p>The special characters '<tt class="literal">#</tt>' and '<tt class="literal">*</tt>' also have special
        meaning and can take the place of a word.</p><p>The character '<tt class="literal">#</tt>' means 'match any sequence of zero or more
        words'.</p><p>The character '<tt class="literal">*</tt>' means 'match a single word'.</p><p>So the wildcard 'news.europe.#' would match 'news.europe', 'news.europe.sport',
        'news.europe.politics', and 'news.europe.politics.regional' but would not match 'news.usa',
        'news.usa.sport' nor 'entertainment'.</p><p>The wildcard 'news.*' would match 'news.europe', but not 'news.europe.sport'.</p><p>The wildcard 'news.*.sport' would match 'news.europe.sport' and also 'news.usa.sport', but
        not 'news.europe.politics'.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="filter-expressions"></a>Chapter&nbsp;14.&nbsp;Filter Expressions</h2></div></div><div></div></div><p>HornetQ provides a powerful filter language based on a subset of the SQL 92
        expression syntax.</p><p>It is the same as the syntax used for JMS selectors, but the predefined identifiers are
        different. For documentation on JMS selector syntax please the JMS javadoc for <a href="http://java.sun.com/javaee/5/docs/api/javax/jms/Message.html" target="_top">javax.jms.Message</a>.</p><p>Filter expressions are used in several places in HornetQ</p><div class="itemizedlist"><ul type="disc"><li><p>Predefined Queues. When pre-defining a queue, either in <tt class="literal">hornetq-configuration.xml</tt> or <tt class="literal">hornetq-jms.xml</tt> a filter
                expression can be defined for a queue. Only messages that match the filter
                expression will enter the queue.</p></li><li><p>Core bridges can be defined with an optional filter expression, only matching
                messages will be bridged (see <a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">Chapter&nbsp;36, <i>Core Bridges</i></a>).</p></li><li><p>Diverts can be defined with an optional filter expression, only matching messages
                will be diverted (see <a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">Chapter&nbsp;35, <i>Diverting and Splitting Message Flows</i></a>).</p></li><li><p>Filter are also used programmatically when creating consumers, queues and in
                several places as described in <a href="#management" title="Chapter&nbsp;30.&nbsp;Management">Chapter&nbsp;30, <i>Management</i></a>.</p></li></ul></div><p>There are some differences between JMS selector expressions and HornetQ core
        filter expressions. Whereas JMS selector expressions operate on a JMS message, HornetQ
        core filter expressions operate on a core message.</p><p>The following identifiers can be used in a core filter expressions to refer to attributes
        of the core message in an expression:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">HQPriority</tt>. To refer to the priority of a message. Message
                priorities are integers with valid values from <tt class="literal">0 - 9</tt>. <tt class="literal">0</tt> is the lowest priority and <tt class="literal">9</tt> is the highest.
                E.g. <tt class="literal">HQPriority = 3 AND animal = 'aardvark'</tt></p></li><li><p><tt class="literal">HQExpiration</tt>. To refer to the expiration time of a message.
                The value is a long integer.</p></li><li><p><tt class="literal">HQDurable</tt>. To refer to whether a message is durable or not.
                The value is a string with valid values: <tt class="literal">DURABLE</tt> or <tt class="literal">NON_DURABLE</tt>.</p></li><li><p><tt class="literal">HQTimestamp</tt>. The timestamp of when the message was created.
                The value is a long integer.</p></li><li><p><tt class="literal">HQSize</tt>. The size of a message in bytes. The value is an
                integer.</p></li></ul></div><p>Any other identifiers used in core filter expressions will be assumed to be properties of
        the message.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="persistence"></a>Chapter&nbsp;15.&nbsp;Persistence</h2></div></div><div></div></div><p>In this chapter we will describe how persistence works with HornetQ and how to configure
        it.</p><p>HornetQ ships with a high performance journal. Since HornetQ handles its own persistence,
        rather than relying on a database or other 3rd party persistence engine it is very highly
        optimised for the specific messaging use cases.</p><p>A HornetQ journal is an <span class="emphasis"><em>append only</em></span> journal. It consists of a set of
        files on disk. Each file is pre-created to a fixed size and initially filled with padding.
        As operations are performed on the server, e.g. add message, update message, delete message,
        records are appended to the journal. When one journal file is full we move to the next
        one.</p><p>Because records are only appended, i.e. added to the end of the journal we minimise disk
        head movement, i.e. we minimise random access operations which is typically the slowest
        operation on a disk.</p><p>Making the file size configurable means that an optimal size can be chosen, i.e. making
        each file fit on a disk cylinder. Modern disk topologies are complex and we are not in
        control over which cylinder(s) the file is mapped onto so this is not an exact science. But
        by minimising the number of disk cylinders the file is using, we can minimise the amount of
        disk head movement, since an entire disk cylinder is accessible simply by the disk rotating
        - the head does not have to move.</p><p>As delete records are added to the journal, HornetQ has a sophisticated file garbage
        collection algorithm which can determine if a particular journal file is needed any more -
        i.e. has all it's data been deleted in the same or other files. If so, the file can be
        reclaimed and re-used. </p><p>HornetQ also has a compaction algorithm which removes dead space from the journal and
        compresses up the data so it takes up less files on disk.</p><p>The journal also fully supports transactional operation if required, supporting both local
        and XA transactions.</p><p>The majority of the journal is written in Java, however we abstract out the interaction
        with the actual file system to allow different pluggable implementations. HornetQ ships with
        two implementations:</p><div class="itemizedlist"><ul type="disc"><li><p>Java <a href="http://en.wikipedia.org/wiki/New_I/O" target="_top">NIO</a>.</p><p>The first implementation uses standard Java NIO to interface with the file system.
                This provides extremely good performance and runs on any platform where there's a
                Java 6+ runtime.</p></li><li><p><a name="aio-journal"></a>Linux Asynchronous IO</p><p>The second implementation uses a thin native code wrapper to talk to the Linux
                asynchronous IO library (AIO). With AIO, HornetQ will be called back when the data
                has made it to disk, allowing us to avoid explicit syncs altogether and simply send
                back confirmation of completion when AIO informs us that the data has been
                persisted.</p><p>Using AIO will typically provide even better performance than using Java
                NIO.</p><p>The AIO journal is only available when running Linux kernel 2.6 or later and after
                having installed libaio (if it's not already installed). For instructions on how to
                install libaio please see <a href="#installing-aio" title="15.5.&nbsp;Installing AIO">Section&nbsp;15.5, &#8220;Installing AIO&#8221;</a>.</p><p>Also, please note that AIO will only work with the following file systems: ext2,
                ext3, ext4, jfs, xfs. With other file systems, e.g. NFS it may appear to work, but
                it will fall back to a slower sychronous behaviour. Don't put the journal on a NFS
                share!</p><p>For more information on libaio please see <a href="#libaio" title="Chapter&nbsp;40.&nbsp;Libaio Native Libraries">Chapter&nbsp;40, <i>Libaio Native Libraries</i></a>.</p><p>libaio is part of the kernel project.</p></li></ul></div><p>The standard HornetQ core server uses two instances of the journal:</p><div class="itemizedlist"><a name="persistence.journallist"></a><ul type="disc"><li><p>Bindings journal.</p><p>This journal is used to store bindings related data. That includes the set of
                queues that are deployed on the server and their attributes. It also stores data
                such as id sequence counters. </p><p>The bindings journal is always a NIO journal as it is typically low throughput
                compared to the message journal.</p><p>The files on this journal are prefixed as <tt class="literal">hornetq-bindings</tt>.
                Each file has a <tt class="literal">bindings</tt> extension. File size is <tt class="literal">1048576</tt>, and it is located at the bindings folder.</p></li><li><p>JMS journal.</p><p>This journal instance stores all JMS related data, This is basically any JMS
                Queues, Topics and Connection Factories and any JNDI bindings for these
                resources.</p><p>Any JMS Resources created via the management API will be persisted to this
                journal. Any resources configured via configuration files will not. The JMS Journal
                will only be created if JMS is being used.</p><p>The files on this journal are prefixed as <tt class="literal">hornetq-jms</tt>. Each
                file has a <tt class="literal">jms</tt> extension. File size is <tt class="literal">1048576</tt>, and it is located at the bindings folder.</p></li><li><p>Message journal.</p><p>This journal instance stores all message related data, including the message
                themselves and also duplicate-id caches.</p><p>By default HornetQ will try and use an AIO journal. If AIO is not available, e.g.
                the platform is not Linux with the correct kernel version or AIO has not been
                installed then it will automatically fall back to using Java NIO which is available
                on any Java platform.</p><p>The files on this journal are prefixed as <tt class="literal">hornetq-data</tt>. Each
                file has a <tt class="literal">hq</tt> extension. File size is by the default <tt class="literal">10485760</tt> (configurable), and it is located at the journal
                folder.</p></li></ul></div><p>For large messages, HornetQ persists them outside the message journal. This is discussed
        in <a href="#large-messages" title="Chapter&nbsp;23.&nbsp;Large Messages">Chapter&nbsp;23, <i>Large Messages</i></a>.</p><p>HornetQ can also be configured to page messages to disk in low memory situations. This is
        discussed in <a href="#paging" title="Chapter&nbsp;24.&nbsp;Paging">Chapter&nbsp;24, <i>Paging</i></a>.</p><p>If no persistence is required at all, HornetQ can also be configured not to persist any
        data at all to storage as discussed in <a href="#persistence.enabled" title="15.6.&nbsp;Configuring HornetQ for Zero Persistence">Section&nbsp;15.6, &#8220;Configuring HornetQ for Zero Persistence&#8221;</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuring.bindings.journal"></a>15.1.&nbsp;Configuring the bindings journal</h2></div></div><div></div></div><p>The bindings journal is configured using the following attributes in <tt class="literal">hornetq-configuration.xml</tt></p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">bindings-directory</tt></p><p>This is the directory in which the bindings journal lives. The default value
                    is <tt class="literal">data/bindings</tt>.</p></li><li><p><tt class="literal">create-bindings-dir</tt></p><p>If this is set to <tt class="literal">true</tt> then the bindings directory will be
                    automatically created at the location specified in <tt class="literal">bindings-directory</tt> if it does not already exist. The default
                    value is <tt class="literal">true</tt></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuring.bindings.jms"></a>15.2.&nbsp;Configuring the jms journal</h2></div></div><div></div></div><p>The jms config shares its configuration with the bindings journal.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuring.message.journal"></a>15.3.&nbsp;Configuring the message journal</h2></div></div><div></div></div><p>The message journal is configured using the following attributes in <tt class="literal">hornetq-configuration.xml</tt></p><div class="itemizedlist"><ul type="disc"><li><p><a name="configuring.message.journal.journal-directory"></a><tt class="literal">journal-directory</tt></p><p>This is the directory in which the message journal lives. The default value is
                        <tt class="literal">data/journal</tt>.</p><p>For the best performance, we recommend the journal is located on its own
                    physical volume in order to minimise disk head movement. If the journal is on a
                    volume which is shared with other processes which might be writing other files
                    (e.g. bindings journal, database, or transaction coordinator) then the disk head
                    may well be moving rapidly between these files as it writes them, thus
                    drastically reducing performance.</p><p>When the message journal is stored on a SAN we recommend each journal instance
                    that is stored on the SAN is given its own LUN (logical unit).</p></li><li><p><a name="configuring.message.journal.create-journal-dir"></a><tt class="literal">create-journal-dir</tt></p><p>If this is set to <tt class="literal">true</tt> then the journal directory will be
                    automatically created at the location specified in <tt class="literal">journal-directory</tt> if it does not already exist. The default value
                    is <tt class="literal">true</tt></p></li><li><p><a name="configuring.message.journal.journal-type"></a><tt class="literal">journal-type</tt></p><p>Valid values are <tt class="literal">NIO</tt> or <tt class="literal">ASYNCIO</tt>.</p><p>Choosing <tt class="literal">NIO</tt> chooses the Java NIO journal. Choosing
                        <tt class="literal">AIO</tt> chooses the Linux asynchronous IO journal. If you
                    choose <tt class="literal">AIO</tt> but are not running Linux or you do not have
                    libaio installed then HornetQ will detect this and automatically fall back to
                    using <tt class="literal">NIO</tt>.</p></li><li><p><a name="configuring.message.journal.journal-sync-transactional"></a><tt class="literal">journal-sync-transactional</tt></p><p>If this is set to true then HornetQ will make sure all transaction data is
                    flushed to disk on transaction boundaries (commit, prepare and rollback). The
                    default value is <tt class="literal">true</tt>.</p></li><li><p><a name="configuring.message.journal.journal-sync-non-transactional"></a><tt class="literal">journal-sync-non-transactional</tt></p><p>If this is set to true then HornetQ will make sure non transactional message
                    data (sends and acknowledgements) are flushed to disk each time. The default
                    value for this is <tt class="literal">true</tt>.</p></li><li><p><a name="configuring.message.journal.journal-file-size"></a><tt class="literal">journal-file-size</tt></p><p>The size of each journal file in bytes. The default value for this is <tt class="literal">10485760</tt> bytes (10MiB).</p></li><li><p><a name="configuring.message.journal.journal-min-files"></a><tt class="literal">journal-min-files</tt></p><p>The minimum number of files the journal will maintain. When HornetQ starts and
                    there is no initial message data, HornetQ will pre-create <tt class="literal">journal-min-files</tt> number of files.</p><p>Creating journal files and filling them with padding is a fairly expensive
                    operation and we want to minimise doing this at run-time as files get filled. By
                    precreating files, as one is filled the journal can immediately resume with the
                    next one without pausing to create it.</p><p>Depending on how much data you expect your queues to contain at steady state
                    you should tune this number of files to match that total amount of data.</p></li><li><p><a name="configuring.message.journal.journal-max-io"></a><tt class="literal">journal-max-io</tt></p><p>Write requests are queued up before being submitted to the system for
                    execution. This parameter controls the maximum number of write requests that can
                    be in the IO queue at any one time. If the queue becomes full then writes will
                    block until space is freed up. </p><p>When using NIO, this value should always be equal to <tt class="literal">1</tt></p><p>When using AIO, the default should be <tt class="literal">500</tt>.</p><p>The system maintains different defaults for this parameter depening on whether
                    it's NIO or AIO (default for NIO is 1, default for AIO is 500)</p><p>There is a limit and the total max AIO can't be higher than what is configured
                    at the OS level (/proc/sys/fs/aio-max-nr) usually at 65536.</p></li><li><p><a name="configuring.message.journal.journal-buffer-timeout"></a><tt class="literal">journal-buffer-timeout</tt></p><p>Instead of flushing on every write that requires a flush, we maintain an
                    internal buffer, and flush the entire buffer either when it is full, or when a
                    timeout expires, whichever is sooner. This is used for both NIO and AIO and
                    allows the system to scale better with many concurrent writes that require
                    flushing.</p><p>This parameter controls the timeout at which the buffer will be flushed if it
                    hasn't filled already. AIO can typically cope with a higher flush rate than NIO,
                    so the system maintains different defaults for both NIO and AIO (default for NIO
                    is 3333333 nanoseconds - 300 times per second, default for AIO is 500000
                    nanoseconds - ie. 2000 times per second).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>By increasing the timeout, you may be able to increase system throughput
                        at the expense of latency, the default parameters are chosen to give a
                        reasonable balance between throughput and latency.</p></div></li><li><p><a name="configuring.message.journal.journal-buffer-size"></a><tt class="literal">journal-buffer-size</tt></p><p>The size of the timed buffer on AIO. The default value is <tt class="literal">490KiB</tt>.</p></li><li><p><a name="configuring.message.journal.journal-compact-min-files"></a><tt class="literal">journal-compact-min-files</tt></p><p>The minimal number of files before we can consider compacting the journal. The
                    compacting algorithm won't start until you have at least <tt class="literal">journal-compact-min-files</tt></p><p>The default for this parameter is <tt class="literal">10</tt></p></li><li><p><a name="configuring.message.journal.journal-compact-percentage"></a><tt class="literal">journal-compact-percentage</tt></p><p>The threshold to start compacting. When less than this percentage is
                    considered live data, we start compacting. Note also that compacting won't kick
                    in until you have at least <tt class="literal">journal-compact-min-files</tt> data
                    files on the journal</p><p>The default for this parameter is <tt class="literal">30</tt></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="disk-write-cache"></a>15.4.&nbsp;An important note on disabling disk write cache.</h2></div></div><div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Most disks contain hardware write caches. A write cache can increase the apparent
                performance of the disk because writes just go into the cache and are then lazily
                written to the disk later. </p><p>This happens irrespective of whether you have executed a fsync() from the
                operating system or correctly synced data from inside a Java program!</p><p>By default many systems ship with disk write cache enabled. This means that even
                after syncing from the operating system there is no guarantee the data has actually
                made it to disk, so if a failure occurs, critical data can be lost.</p><p>Some more expensive disks have non volatile or battery backed write caches which
                won't necessarily lose data on event of failure, but you need to test them!</p><p>If your disk does not have an expensive non volatile or battery backed cache and
                it's not part of some kind of redundant array (e.g. RAID), and you value your data
                integrity you need to make sure disk write cache is disabled.</p><p>Be aware that disabling disk write cache can give you a nasty shock performance
                wise. If you've been used to using disks with write cache enabled in their default
                setting, unaware that your data integrity could be compromised, then disabling it
                will give you an idea of how fast your disk can perform when acting really
                reliably.</p><p>On Linux you can inspect and/or change your disk's write cache settings using the
                tools <tt class="literal">hdparm</tt> (for IDE disks) or <tt class="literal">sdparm</tt> or
                    <tt class="literal">sginfo</tt> (for SDSI/SATA disks)</p><p>On Windows you can check / change the setting by right clicking on the disk and
                clicking properties.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="installing-aio"></a>15.5.&nbsp;Installing AIO</h2></div></div><div></div></div><p>The Java NIO journal gives great performance, but If you are running HornetQ using
            Linux Kernel 2.6 or later, we highly recommend you use the <tt class="literal">AIO</tt>
            journal for the very best persistence performance.</p><p>It's not possible to use the AIO journal under other operating systems or earlier
            versions of the Linux kernel.</p><p>If you are running Linux kernel 2.6 or later and don't already have <tt class="literal">libaio</tt> installed, you can easily install it using the following
            steps:</p><p>Using yum, (e.g. on Fedora or Red Hat Enterprise Linux):
            </p><pre class="programlisting">yum install libaio</pre><p>Using aptitude, (e.g. on Ubuntu or Debian system):
            </p><pre class="programlisting">apt-get install libaio</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistence.enabled"></a>15.6.&nbsp;Configuring HornetQ for Zero Persistence</h2></div></div><div></div></div><p>In some situations, zero persistence is sometimes required for a messaging system.
            Configuring HornetQ to perform zero persistence is straightforward. Simply set the
            parameter <tt class="literal">persistence-enabled</tt> in <tt class="literal">hornetq-configuration.xml</tt> to <tt class="literal">false</tt>. </p><p>Please note that if you set this parameter to false, then <span class="emphasis"><em>zero</em></span>
            persistence will occur. That means no bindings data, message data, large message data,
            duplicate id caches or paging data will be persisted.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="persistence.importexport"></a>15.7.&nbsp;Import/Export the Journal Data</h2></div></div><div></div></div><p>You may want to inspect the existent records on each one of the journals used by
            HornetQ, and you can use the export/import tool for that purpose. The export/import are
            classes located at the hornetq-core.jar, you can export the journal as a text file by
            using this command:</p><p><tt class="literal">java -cp hornetq-core.jar org.hornetq.core.journal.impl.ExportJournal
                &lt;JournalDirectory&gt; &lt;JournalPrefix&gt; &lt;FileExtension&gt; &lt;FileSize&gt;
                &lt;FileOutput&gt;</tt></p><p>To import the file as binary data on the journal (Notice you also require
            netty.jar):</p><p><tt class="literal">java -cp hornetq-core.jar:netty.jar org.hornetq.core.journal.impl.ImportJournal
                &lt;JournalDirectory&gt; &lt;JournalPrefix&gt; &lt;FileExtension&gt; &lt;FileSize&gt;
                &lt;FileInput&gt;</tt></p><div class="itemizedlist"><ul type="disc"><li><p>JournalDirectory: Use the configured folder for your selected folder. Example:
                    ./hornetq/data/journal</p></li><li><p>JournalPrefix: Use the prefix for your selected journal, as discussed
                    <a href="#persistence.journallist">here</a></p></li><li><p>FileExtension: Use the extension for your selected journal, as discussed
                    <a href="#persistence.journallist">here</a></p></li><li><p>FileSize: Use the size for your selected journal, as discussed <a href="#persistence.journallist">here</a></p></li><li><p>FileOutput: text file that will contain the exported data</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuring-transports"></a>Chapter&nbsp;16.&nbsp;Configuring the Transport</h2></div></div><div></div></div><p>HornetQ has a fully pluggable and highly flexible transport layer and defines its own
        Service Provider Interface (SPI) to make plugging in a new transport provider relatively
        straightforward.</p><p>In this chapter we'll describe the concepts required for understanding HornetQ transports
        and where and how they're configured.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuring-transports.acceptors"></a>16.1.&nbsp;Understanding Acceptors</h2></div></div><div></div></div><p>One of the most important concepts in HornetQ transports is the
                <span class="emphasis"><em>acceptor</em></span>. Let's dive straight in and take a look at an acceptor
            defined in xml in the configuration file <tt class="literal">hornetq-configuration.xml</tt>.</p><pre class="programlisting">
&lt;acceptors&gt;                
    &lt;acceptor name="netty"&gt;
        &lt;factory-class&gt;
org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory
        &lt;/factory-class&gt;
        &lt;param key="port" value="5446"/&gt;
    &lt;/acceptor&gt;
&lt;/acceptors&gt;            
        </pre><p>Acceptors are always defined inside an <tt class="literal">acceptors</tt> element. There can
            be one or more acceptors defined in the <tt class="literal">acceptors</tt> element. There's no
            upper limit to the number of acceptors per server.</p><p>Each acceptor defines a way in which connections can be made to the HornetQ
            server.</p><p>In the above example we're defining an acceptor that uses <a href="http://jboss.org/netty" target="_top">Netty</a> to listen for connections at port
                <tt class="literal">5446</tt>. </p><p>The <tt class="literal">acceptor</tt> element contains a sub-element <tt class="literal">factory-class</tt>, this element defines the factory used to create acceptor
            instances. In this case we're using Netty to listen for connections so we use the Netty
            implementation of an <tt class="literal">AcceptorFactory</tt> to do this. Basically, the
                <tt class="literal">factory-class</tt> element determines which pluggable transport we're
            going to use to do the actual listening.</p><p>The <tt class="literal">acceptor</tt> element can also be configured with zero or more
                <tt class="literal">param</tt> sub-elements. Each <tt class="literal">param</tt> element defines
            a key-value pair. These key-value pairs are used to configure the specific transport,
            the set of valid key-value pairs depends on the specific transport be used and are
            passed straight through to the underlying transport.</p><p>Examples of key-value pairs for a particular transport would be, say, to configure the
            IP address to bind to, or the port to listen at.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuring-transports.connectors"></a>16.2.&nbsp;Understanding Connectors</h2></div></div><div></div></div><p>Whereas acceptors are used on the server to define how we accept connections,
            connectors are used by a client to define how it connects to a server.</p><p>Let's look at a connector defined in our <tt class="literal">hornetq-configuration.xml</tt>
            file:</p><pre class="programlisting">
&lt;connectors&gt;
    &lt;connector name="netty"&gt;
        &lt;factory-class&gt;
            org.hornetq.core.remoting.impl.netty.NettyConnectorFactory
        &lt;/factory-class&gt;
        &lt;param key="port" value="5446"/&gt;
    &lt;/connector&gt;
&lt;/connectors&gt;            
        </pre><p>Connectors can be defined inside a <tt class="literal">connectors</tt> element. There can be
            one or more connectors defined in the <tt class="literal">connectors</tt> element. There's no
            upper limit to the number of connectors per server.</p><p>You make ask yourself, if connectors are used by the <span class="emphasis"><em>client</em></span> to
            make connections then why are they defined on the <span class="emphasis"><em>server</em></span>? There are
            a couple of reasons for this:</p><div class="itemizedlist"><ul type="disc"><li><p>Sometimes the server acts as a client itself when it connects to another
                    server, for example when one server is bridged to another, or when a server
                    takes part in a cluster. In this cases the server needs to know how to connect
                    to other servers. That's defined by <span class="emphasis"><em>connectors</em></span>.</p></li><li><p>If you're using JMS and the server side JMS service to instantiate JMS
                    ConnectionFactory instances and bind them in JNDI, then when creating the
                        <tt class="literal">HornetQConnectionFactory</tt> it needs to know what server
                    that connection factory will create connections to.</p><p>That's defined by the <tt class="literal">connector-ref</tt> element in the <tt class="literal">hornetq-jms.xml</tt>file on the server side. Let's take a look at a
                    snipped from a <tt class="literal">hornetq-jms.xml</tt> file that shows a JMS
                    connection factory that references our netty connector defined in our <tt class="literal">hornetq-configuration.xml</tt> file:</p><pre class="programlisting">
&lt;connection-factory name="ConnectionFactory"&gt;
    &lt;connectors&gt;
       &lt;connector-ref connector-name="netty"/&gt;
    &lt;/connectors&gt;
    &lt;entries&gt;
        &lt;entry name="ConnectionFactory"/&gt;
        &lt;entry name="XAConnectionFactory"/&gt;
    &lt;/entries&gt;
&lt;/connection-factory&gt;                
            </pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuring-transports.client.side"></a>16.3.&nbsp;Configuring the transport directly from the client side.</h2></div></div><div></div></div><p>How do we configure a core <tt class="literal">ClientSessionFactory</tt> with the
            information that it needs to connect with a server?</p><p>Connectors are also used indirectly when directly configuring a core <tt class="literal">ClientSessionFactory</tt> to directly talk to a server. Although in this case
            there's no need to define such a connector in the server side configuration, instead we
            just create the parameters and tell the <tt class="literal">ClientSessionFactory</tt> which
            connector factory to use.</p><p>Here's an example of creating a <tt class="literal">ClientSessionFactory</tt> which will
            connect directly to the acceptor we defined earlier in this chapter, it uses the
            standard Netty TCP transport and will try and connect on port 5446 to localhost
            (default):</p><pre class="programlisting">
Map&lt;String, Object&gt; connectionParams = new HashMap&lt;String, Object&gt;();
    
connectionParams.put(org.hornetq.core.remoting.impl.netty.TransportConstants.PORT_PROP_NAME, 
                    5446);

TransportConfiguration transportConfiguration = 
    new TransportConfiguration(
    "org.hornetq.core.remoting.impl.netty.NettyConnectorFactory", 
    connectionParams);

ClientSessionFactory sessionFactory = HornetQClient.createClientSessionFactory(transportConfiguration);

ClientSession session = sessionFactory.createSession(...);

etc                       
        </pre><p>Similarly, if you're using JMS, you can configure the JMS connection factory directly
            on the client side without having to define a connector on the server side or define a
            connection factory in <tt class="literal">hornetq-jms.xml</tt>:</p><pre class="programlisting">
Map&lt;String, Object&gt; connectionParams = new HashMap&lt;String, Object&gt;();

connectionParams.put(org.hornetq.core.remoting.impl.netty.TransportConstants.PORT_PROP_NAME, 5446);

TransportConfiguration transportConfiguration = 
    new TransportConfiguration(
    "org.hornetq.core.remoting.impl.netty.NettyConnectorFactory", 
    connectionParams);

ConnectionFactory connectionFactory = HornetQJMSClient.createConnectionFactory(transportConfiguration);

Connection jmsConnection = connectionFactory.createConnection();

etc                       
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3087"></a>16.4.&nbsp;Configuring the Netty transport</h2></div></div><div></div></div><p>Out of the box, HornetQ currently uses <a href="http://www.jboss.org/netty/" target="_top">Netty</a>, a high performance low level network library.</p><p>Our Netty transport can be configured in several different ways; to use old (blocking)
            Java IO, or NIO (non-blocking), also to use straightforward TCP sockets, SSL, or to
            tunnel over HTTP or HTTPS, on top of that we also provide a servlet transport.</p><p>We believe this caters for the vast majority of transport requirements.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3099"></a>16.4.1.&nbsp;Configuring Netty TCP</h3></div></div><div></div></div><p>Netty TCP is a simple unencrypted TCP sockets based transport. Netty TCP can be
                configured to use old blocking Java IO or non blocking Java NIO. We recommend you
                use the Java NIO on the server side for better scalability with many concurrent
                connections. However using Java old IO can sometimes give you better latency than
                NIO when you're not so worried about supporting many thousands of concurrent
                connections. </p><p>If you're running connections across an untrusted network please bear in mind this
                transport is unencrypted. You may want to look at the SSL or HTTPS
                configurations.</p><p>With the Netty TCP transport all connections are initiated from the client side.
                I.e. the server does not initiate any connections to the client. This works well
                with firewall policies that typically only allow connections to be initiated in one
                direction.</p><p>All the valid Netty transport keys are defined in the class <tt class="literal">org.hornetq.core.remoting.impl.netty.TransportConstants</tt>. Most
                parameters can be used either with acceptors or connectors, some only work with
                acceptors. The following parameters can be used to configure Netty for simple
                TCP:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">use-nio</tt>. If this is <tt class="literal">true</tt> then Java
                        non blocking NIO will be used. If set to <tt class="literal">false</tt> then old
                        blocking Java IO will be used.</p><p>If you require the server to handle many concurrent connections, we highly
                        recommend that you use non blocking Java NIO. Java NIO does not maintain a
                        thread per connection so can scale to many more concurrent connections than
                        with old blocking IO. If you don't require the server to handle many
                        concurrent connections, you might get slightly better performance by using
                        old (blocking) IO. The default value for this property is <tt class="literal">false</tt> on the server side and <tt class="literal">false</tt> on the
                        client side.</p></li><li><p><tt class="literal">host</tt>. This specifies the host name or IP address to
                        connect to (when configuring a connector) or to listen on (when configuring
                        an acceptor). The default value for this property is <tt class="literal">localhost</tt>. When configuring acceptors, multiple hosts or IP
                        addresses can be specified by separating them with commas. It is also
                        possible to specify <tt class="code">0.0.0.0</tt> to accept connection from all the
                        host's network interfaces. It's not valid to specify multiple addresses when
                        specifying the host for a connector; a connector makes a connection to one
                        specific address.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Don't forget to specify a host name or ip address! If you want your
                            server able to accept connections from other nodes you must specify a
                            hostname or ip address at which the acceptor will bind and listen for
                            incoming connections. The default is localhost which of course is not
                            accessible from remote nodes!</p></div></li><li><p><tt class="literal">port</tt>. This specified the port to connect to (when
                        configuring a connector) or to listen on (when configuring an acceptor). The
                        default value for this property is <tt class="literal">5445</tt>.</p></li><li><p><tt class="literal">tcp-no-delay</tt>. If this is <tt class="literal">true</tt> then
                            <a href="http://en.wikipedia.org/wiki/Nagle's_algorithm" target="_top">Nagle's
                            algorithm</a> will be enabled. The default value for this property
                        is <tt class="literal">true</tt>.</p></li><li><p><tt class="literal">tcp-send-buffer-size</tt>. This parameter determines the
                        size of the TCP send buffer in bytes. The default value for this property is
                            <tt class="literal">32768</tt> bytes (32KiB).</p><p>TCP buffer sizes should be tuned according to the bandwidth and latency of
                        your network. Here's a good link that explains the theory behind <a href="http://www-didc.lbl.gov/TCP-tuning/" target="_top">this</a>.</p><p>In summary TCP send/receive buffer sizes should be calculated as:</p><pre class="programlisting">
                        buffer_size = bandwidth * RTT.
                    </pre><p>Where bandwidth is in <span class="emphasis"><em>bytes per second</em></span> and network
                        round trip time (RTT) is in seconds. RTT can be easily measured using the
                            <tt class="literal">ping</tt> utility.</p><p>For fast networks you may want to increase the buffer sizes from the
                        defaults.</p></li><li><p><tt class="literal">tcp-receive-buffer-size</tt>. This parameter determines the
                        size of the TCP receive buffer in bytes. The default value for this property
                        is <tt class="literal">32768</tt> bytes (32KiB).</p></li><li><p><tt class="literal">batch-delay</tt>. Before writing packets to the transport,
                        HornetQ can be configured to batch up writes for a maximum of <tt class="literal">batch-delay</tt> milliseconds. This can increase overall
                        throughput for very small messages. It does so at the expense of an increase
                        in average latency for message transfer. The default value for this property
                        is <tt class="literal">0</tt> ms.</p></li><li><p><tt class="literal">direct-deliver</tt>. When a message arrives on the server
                        and is delivered to waiting consumers, by default, the delivery is done on a
                        different thread to that which the message arrived on. This gives the best
                        overall throughput and scalability, especially on multi-core machines.
                        However it also introduces some extra latency due to the extra context
                        switch required. If you want the lowest latency and the possible expense of
                        some reduction in throughput then you can make sure <tt class="literal">direct-deliver</tt> to true. The default value for this parameter
                        is <tt class="literal">true</tt>. If you are willing to take some small extra hit
                        on latency but want the highest throughput set this parameter to <tt class="literal">false</tt>.</p></li><li><p><tt class="literal">nio-remoting-threads</tt>. When configured to use NIO,
                        HornetQ will, by default, use a number of threads equal to three times the
                        number of cores (or hyper-threads) as reported by <tt class="literal">Runtime.getRuntime().availableProcessors()</tt> for processing
                        incoming packets. If you want to override this value, you can set the number
                        of threads by specifying this parameter. The default value for this
                        parameter is <tt class="literal">-1</tt> which means use the value from <tt class="literal">Runtime.getRuntime().availableProcessors()</tt> * 3.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3243"></a>16.4.2.&nbsp;Configuring Netty SSL</h3></div></div><div></div></div><p>Netty SSL is similar to the Netty TCP transport but it provides additional
                security by encrypting TCP connections using the Secure Sockets Layer SSL</p><p>Please see the examples for a full working example of using Netty SSL.</p><p>Netty SSL uses all the same properties as Netty TCP but adds the following
                additional properties:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">ssl-enabled</tt>. Must be <tt class="literal">true</tt> to enable
                        SSL.</p></li><li><p><tt class="literal">key-store-path</tt>. This is the path to the SSL key store
                        on the client which holds the client certificates.</p></li><li><p><tt class="literal">key-store-password</tt>. This is the password for the client
                        certificate key store on the client.</p></li><li><p><tt class="literal">trust-store-path</tt>. This is the path to the trusted
                        client certificate store on the server.</p></li><li><p><tt class="literal">trust-store-password</tt>. This is the password to the
                        trusted client certificate store on the server.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3281"></a>16.4.3.&nbsp;Configuring Netty HTTP</h3></div></div><div></div></div><p>Netty HTTP tunnels packets over the HTTP protocol. It can be useful in scenarios
                where firewalls only allow HTTP traffice to pass.</p><p>Please see the examples for a full working example of using Netty HTTP.</p><p>Netty HTTP uses the same properties as Netty TCP but adds the following additional
                properties:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">http-enabled</tt>. Must be <tt class="literal">true</tt> to enable
                        HTTP.</p></li><li><p><tt class="literal">http-client-idle-time</tt>. How long a client can be idle
                        before sending an empty http request to keep the connection alive</p></li><li><p><tt class="literal">http-client-idle-scan-period</tt>. How often, in
                        milliseconds, to scan for idle clients</p></li><li><p><tt class="literal">http-response-time</tt>. How long the server can wait before
                        sending an empty http response to keep the connection alive</p></li><li><p><tt class="literal">http-server-scan-period</tt>. How often, in milliseconds, to
                        scan for clients needing responses</p></li><li><p><tt class="literal">http-requires-session-id</tt>. If true the client will wait
                        after the first call to receive a session id. Used the http connector is
                        connecting to servlet acceptor (not recommended) </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3324"></a>16.4.4.&nbsp;Configuring Netty Servlet</h3></div></div><div></div></div><p>We also provide a Netty servlet transport for use with HornetQ. The servlet
                transport allows HornetQ traffic to be tunneled over HTTP to a servlet running in a
                servlet engine which then redirects it to an in-VM HornetQ server.</p><p>The servlet transport differs from the Netty HTTP transport in that, with the HTTP
                transport HornetQ effectively acts a web server listening for HTTP traffic on, e.g.
                port 80 or 8080, whereas with the servlet transport HornetQ traffic is proxied
                through a servlet engine which may already be serving web site or other
                applications. This allows HornetQ to be used where corporate policies may only allow
                a single web server listening on an HTTP port, and this needs to serve all
                applications including messaging.</p><p>Please see the examples for a full working example of the servlet transport being
                used.</p><p>To configure a servlet engine to work the Netty Servlet transport we need to do
                the following things:</p><div class="itemizedlist"><ul type="disc"><li><p>Deploy the servlet. Here's an example web.xml describing a web application
                        that uses the servlet:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
         version="2.4"&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;HornetQServlet&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.netty.channel.socket.http.HttpTunnelingServlet&lt;/servlet-class&gt;
      &lt;init-param&gt;
             &lt;param-name&gt;endpoint&lt;/param-name&gt;
             &lt;param-value&gt;local:org.hornetq&lt;/param-value&gt;
           &lt;/init-param&gt;
           &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;HornetQServlet&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/HornetQServlet&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;

</pre></li><li><p>We also need to add a special Netty invm acceptor on the server side
                        configuration.</p><p>Here's a snippet from the <tt class="literal">hornetq-configuration.xml</tt>
                        file showing that acceptor being defined:</p><pre class="programlisting">                    
&lt;acceptors&gt;

      &lt;acceptor name="netty-invm"&gt;
         &lt;factory-class&gt;
            org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory
         &lt;/factory-class&gt;
         &lt;param key="use-invm" value="true"/&gt;
         &lt;param key="host" value="org.hornetq"/&gt;
      &lt;/acceptor&gt;

&lt;/acceptors&gt;                                         
                </pre></li><li><p>Lastly we need a connector for the client, this again will be configured
                        in the <tt class="literal">hornetq-configuration.xml</tt> file as such:</p><pre class="programlisting">&lt;connectors&gt;

      &lt;connector name="netty-servlet"&gt;
         &lt;factory-class&gt;
            org.hornetq.core.remoting.impl.netty.NettyConnectorFactory
         &lt;/factory-class&gt;
         &lt;param key="host" value="localhost"/&gt;
         &lt;param key="port" value="8080"/&gt;
         &lt;param key="use-servlet" value="true"/&gt;
         &lt;param key="servlet-path" value="/messaging/HornetQServlet"/&gt;
      &lt;/connector&gt;

 &lt;/connectors&gt;</pre></li></ul></div><p>Heres a list of the init params and what they are used for</p><div class="itemizedlist"><ul type="disc"><li><p>endpoint - This is the name of the netty acceptor that the servlet will
                        forward its packets to. You can see it matches the name of the <tt class="literal">host</tt> param.</p></li></ul></div><p>The servlet pattern configured in the <tt class="literal">web.xml</tt> is the path of
                the URL that is used. The connector param <tt class="literal">servlet-path</tt> on the
                connector config must match this using the application context of the web app if
                there is one.</p><p>Its also possible to use the servlet transport over SSL. simply add the following
                configuration to the
                connector:</p><pre class="programlisting">    &lt;connector name="netty-servlet"&gt;
         &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/factory-class&gt;
         &lt;param key="host" value="localhost"/&gt;
         &lt;param key="port" value="8443"/&gt;
         &lt;param key="use-servlet" value="true"/&gt;
         &lt;param key="servlet-path" value="/messaging/HornetQServlet"/&gt;
         &lt;param key="ssl-enabled" value="true"/&gt;
         &lt;param key="key-store-path" value="path to a keystoree"/&gt;
         &lt;param key="key-store-password" value="keystore password"/&gt;
      &lt;/connector&gt;
</pre><p>You will also have to configure the Application server to use a KeyStore. Edit the
                    <tt class="literal">server.xml</tt> file that can be found under <tt class="literal">server/default/deploy/jbossweb.sar</tt> of the Application Server
                installation and edit the SSL/TLS connector configuration to look like the
                following:</p><pre class="programlisting">&lt;Connector protocol="HTTP/1.1" SSLEnabled="true"
           port="8443" address="${jboss.bind.address}"
           scheme="https" secure="true" clientAuth="false"
           keystoreFile="path to a keystore"
           keystorePass="keystore password" sslProtocol = "TLS" /&gt;

</pre><p>In
                both cases you will need to provide a keystore and password. Take a look at the
                servlet ssl example shipped with HornetQ for more detail.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="connection-ttl"></a>Chapter&nbsp;17.&nbsp;Detecting Dead Connections</h2></div></div><div></div></div><p>In this section we will discuss connection time-to-live (TTL) and explain how HornetQ
        deals with crashed clients and clients which have exited without cleanly closing their
        resources.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dead.connections"></a>17.1.&nbsp;Cleaning up Dead Connection Resources on the Server</h2></div></div><div></div></div><p>Before a HornetQ client application exits it is considered good practice that it
            should close its resources in a controlled manner, using a <tt class="literal">finally</tt>
            block.</p><p>Here's an example of a well behaved core client application closing its session and
            session factory in a finally block:</p><pre class="programlisting">
ClientSessionFactory sf = null;
ClientSession session = null;

try
{
   sf = HornetQClient.createClientSessionFactory(...);

   session = sf.createSession(...);
   
   ... do some stuff with the session...
}
finally
{
   if (session != null)
   {
      session.close();
   }
   
   if (sf != null)
   {
      sf.close();
   }
}
        </pre><p>And here's an example of a well behaved JMS client application:</p><pre class="programlisting">
Connection jmsConnection = null;

try
{
   ConnectionFactory jmsConnectionFactory = HornetQJMSClient.createConnectionFactory(...);

   jmsConnection = jmsConnectionFactory.createConnection();

   ... do some stuff with the connection...
}
finally
{
   if (connection != null)
   {
      connection.close();
   }
}
        </pre><p>Unfortunately users don't always write well behaved applications, and sometimes
            clients just crash so they don't have a chance to clean up their resources!</p><p>If this occurs then it can leave server side resources, like sessions, hanging on the
            server. If these were not removed they would cause a resource leak on the server and
            over time this result in the server running out of memory or other resources.</p><p>We have to balance the requirement for cleaning up dead client resources with the fact
            that sometimes the network between the client and the server can fail and then come
            back, allowing the client to reconnect. HornetQ supports client reconnection, so we
            don't want to clean up "dead" server side resources too soon or this will prevent any
            client from reconnecting, as it won't be able to find its old sessions on the
            server.</p><p>HornetQ makes all of this configurable. For each <tt class="literal">ClientSessionFactory</tt> we define a <span class="emphasis"><em>connection TTL</em></span>.
            Basically, the TTL determines how long the server will keep a connection alive in the
            absence of any data arriving from the client. The client will automatically send "ping"
            packets periodically to prevent the server from closing it down. If the server doesn't
            receive any packets on a connection for the connection TTL time, then it will
            automatically close all the sessions on the server that relate to that
            connection.</p><p>If you're using JMS, the connection TTL is defined by the <tt class="literal">ConnectionTTL</tt> attribute on a <tt class="literal">HornetQConnectionFactory</tt>
            instance, or if you're deploying JMS connection factory instances direct into JNDI on
            the server side, you can specify it in the xml config, using the parameter <tt class="literal">connection-ttl</tt>.</p><p>The default value for connection ttl is <tt class="literal">60000</tt>ms, i.e. 1 minute. A
            value of <tt class="literal">-1</tt> for <tt class="literal">ConnectionTTL</tt> means the server
            will never time out the connection on the server side.</p><p>If you do not wish clients to be able to specify their own connection TTL, you can
            override all values used by a global value set on the server side. This can be done by
            specifying the <tt class="literal">connection-ttl-override</tt> attribute in the server side
            configuration. The default value for <tt class="literal">connection-ttl-override</tt> is
                <tt class="literal">-1</tt> which means "do not override" (i.e. let clients use their own
            values).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3476"></a>17.1.1.&nbsp;Closing core sessions or JMS connections that you have failed to close</h3></div></div><div></div></div><p>As previously discussed, it's important that all core client sessions and JMS
                connections are always closed explicitly in a <tt class="literal">finally</tt> block when
                you are finished using them. </p><p>If you fail to do so, HornetQ will detect this at garbage collection time, and log
                a warning similar to the following in the logs (If you are using JMS the warning
                will involve a JMS connection not a client session):</p><pre class="programlisting">
                
[Finalizer] 20:14:43,244 WARNING [org.hornetq.core.client.impl.DelegatingSession]  I'm closin
g a ClientSession you left open. Please make sure you close all ClientSessions explicitly before let
ting them go out of scope!
[Finalizer] 20:14:43,244 WARNING [org.hornetq.core.client.impl.DelegatingSession]  The sessi
on you didn't close was created here:
java.lang.Exception
at org.hornetq.core.client.impl.DelegatingSession.&lt;init&gt;(DelegatingSession.java:83)
at org.acme.yourproject.YourClass (YourClass.java:666)    
                
            </pre><p>HornetQ will then close the connection / client session for you.</p><p>Note that the log will also tell you the exact line of your user code where you
                created the JMS connection / client session that you later did not close. This will
                enable you to pinpoint the error in your code and correct it appropriately.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3492"></a>17.2.&nbsp;Detecting failure from the client side.</h2></div></div><div></div></div><p>In the previous section we discussed how the client sends pings to the server and how
            "dead" connection resources are cleaned up by the server. There's also another reason
            for pinging, and that's for the <span class="emphasis"><em>client</em></span> to be able to detect that
            the server or network has failed.</p><p>As long as the client is receiving data from the server it will consider the
            connection to be still alive. </p><p>If the client does not receive any packets for <tt class="literal">client-failure-check-period</tt> milliseconds then it will consider the
            connection failed and will either initiate failover, or call any <tt class="literal">FailureListener</tt> instances (or <tt class="literal">ExceptionListener</tt>
            instances if you are using JMS) depending on how it has been configured.</p><p>If you're using JMS it's defined by the <tt class="literal">ClientFailureCheckPeriod</tt>
            attribute on a <tt class="literal">HornetQConnectionFactory</tt> instance, or if you're
            deploying JMS connection factory instances direct into JNDI on the server side, you can
            specify it in the <tt class="literal">hornetq-jms.xml </tt> configuration file, using the
            parameter <tt class="literal">client-failure-check-period</tt>.</p><p>The default value for client failure check period is <tt class="literal">30000</tt>ms, i.e.
            30 seconds. A value of <tt class="literal">-1</tt> means the client will never fail the
            connection on the client side if no data is received from the server. Typically this is
            much lower than connection TTL to allow clients to reconnect in case of transitory
            failure.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="connection-ttl.async-connection-execution"></a>17.3.&nbsp;Configuring Asynchronous Connection Execution</h2></div></div><div></div></div><p>By default, packets received on the server side are executed on the remoting
            thread.</p><p>It is possible instead to use a thread from a thread pool to handle some packets so
            that the remoting thread is not tied up for too long. However, please note that
            processing operations asynchronously on another thread adds a little more latency.
            Please note that most short running operations are always handled on the remoting thread for performance reasons.
           
            To enable asynchronous connection execution, set the parameter <tt class="literal">async-connection-execution-enabled</tt> in <tt class="literal">hornetq-configuration.xml</tt> to <tt class="literal">true</tt> (default value is
                <tt class="literal">true</tt>).</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transaction-config"></a>Chapter&nbsp;18.&nbsp;Resource Manager Configuration</h2></div></div><div></div></div><p>HornetQ has its own Resource Manager for handling the lifespan of JTA transactions. When a
        transaction is started the resource manager is notified and keeps a record of the
        transaction and its current state. It is possible in some cases for a transaction to be
        started but then forgotten about. Maybe the client died and never came back. If this happens
        then the transaction will just sit there indefinitely.</p><p>To cope with this HornetQ can, if configured, scan for old transactions and rollback any
        it finds. The default for this is 3000000 milliseconds (5 minutes), i.e. any transactions older
        than 5 minutes are removed. This timeout can be changed by editing the <tt class="literal">transaction-timeout</tt> property in <tt class="literal">hornetq-configuration.xml</tt> (value must be in milliseconds).
        The property <tt class="literal">transaction-timeout-scan-period</tt> configures how often, in
        milliseconds, to scan for old transactions.</p><p>Please note that HornetQ will not unilaterally rollback any XA transactions in a prepared state - this must be heuristically rolled
    back via the management API if you are sure they will never be resolved by the transaction manager.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="flow-control"></a>Chapter&nbsp;19.&nbsp;Flow Control</h2></div></div><div></div></div><p>Flow control is used to limit the flow of data between a client and server, or a server and
      another server in order to prevent the client or server being overwhelmed with data.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3611"></a>19.1.&nbsp;Consumer Flow Control</h2></div></div><div></div></div><p>This controls the flow of data between the server and the client as the client consumes
         messages. For performance reasons clients normally buffer messages before delivering to the
         consumer via the <tt class="literal">receive()</tt> method or asynchronously via a message
         listener. If the consumer cannot process messages as fast as they are being delivered and
         stored in the internal buffer, then you could end up with a situation where messages would
         keep building up possibly causing out of memory on the client if they cannot be processed
         in time.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="flow-control.consumer.window"></a>19.1.1.&nbsp;Window-Based Flow Control</h3></div></div><div></div></div><p>By default, HornetQ consumers buffer messages from the server in a client side buffer
            before the client consumes them. This improves performance: otherwise every time the
            client consumes a message, HornetQ would have to go the server to request the next
            message. In turn, this message would then get sent to the client side, if one was
            available.</p><p>A network round trip would be involved for <span class="emphasis"><em>every</em></span> message and
            considerably reduce performance.</p><p>To prevent this, HornetQ pre-fetches messages into a buffer on each consumer. The
            total maximum size of messages (in bytes) that will be buffered on each consumer is
            determined by the <tt class="literal">consumer-window-size</tt> parameter.</p><p>By default, the <tt class="literal">consumer-window-size</tt> is set to 1 MiB (1024 * 1024
            bytes).</p><p>The value can be:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">-1</tt> for an <span class="emphasis"><em>unbounded</em></span> buffer</p></li><li><p><tt class="literal">0</tt> to not buffer any messages. See <a href="#examples.no-consumer-buffering" title="11.1.32.&nbsp;No Consumer Buffering">Section&nbsp;11.1.32, &#8220;No Consumer Buffering&#8221;</a> for working example of a consumer
                  with no buffering.</p></li><li><p><tt class="literal">&gt;0</tt> for a buffer with the given maximum size in
                  bytes.</p></li></ul></div><p>Setting the consumer window size can considerably improve performance depending on
            the messaging use case. As an example, let's consider the two extremes: </p><div class="variablelist"><dl><dt><span class="term">Fast consumers</span></dt><dd><p>Fast consumers can process messages as fast as they consume them (or even
                     faster)</p><p>To allow fast consumers, set the <tt class="literal">consumer-window-size</tt> to
                     -1. This will allow <span class="emphasis"><em>unbounded</em></span> message buffering on the
                     client side.</p><p>Use this setting with caution: it can overflow the client memory if the
                     consumer is not able to process messages as fast as it receives them.</p></dd><dt><span class="term">Slow consumers</span></dt><dd><p>Slow consumers takes significant time to process each message and it is
                     desirable to prevent buffering messages on the client side so that they can be
                     delivered to another consumer instead.</p><p>Consider a situation where a queue has 2 consumers; 1 of which is very slow.
                     Messages are delivered in a round robin fashion to both consumers, the fast
                     consumer processes all of its messages very quickly until its buffer is empty.
                     At this point there are still messages awaiting to be processed in the buffer
                     of the slow consumer thus preventing them being processed by the fast consumer.
                     The fast consumer is therefore sitting idle when it could be processing the
                     other messages. </p><p>To allow slow consumers, set the <tt class="literal">consumer-window-size</tt> to
                     0 (for no buffer at all). This will prevent the slow consumer from buffering
                     any messages on the client side. Messages will remain on the server side ready
                     to be consumed by other consumers.</p><p>Setting this to 0 can give deterministic distribution between multiple
                     consumers on a queue.</p></dd></dl></div><p>Most of the consumers cannot be clearly identified as fast or slow consumers but are
            in-between. In that case, setting the value of <tt class="literal">consumer-window-size</tt>
            to optimize performance depends on the messaging use case and requires benchmarks to
            find the optimal value, but a value of 1MiB is fine in most cases.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="flow-control.core.api"></a>19.1.1.1.&nbsp;Using Core API</h4></div></div><div></div></div><p>If HornetQ Core API is used, the consumer window size is specified by <tt class="literal">ClientSessionFactory.setConsumerWindowSize()</tt> method and some of the
                  <tt class="literal">ClientSession.createConsumer()</tt> methods.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3712"></a>19.1.1.2.&nbsp;Using JMS</h4></div></div><div></div></div><p>if JNDI is used to look up the connection factory, the consumer window size is
               configured in <tt class="literal">hornetq-jms.xml</tt>:</p><pre class="programlisting">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;       
   &lt;/entries&gt;
      
   &lt;!-- Set the consumer window size to 0 to have *no* buffer on the client side --&gt;
   &lt;consumer-window-size&gt;0&lt;/consumer-window-size&gt;
&lt;/connection-factory&gt;
            </pre><p>If the connection factory is directly instantiated, the consumer window size is
               specified by <tt class="literal">HornetQConnectionFactory.setConsumerWindowSize()</tt>
               method.</p><p>Please see <a href="#examples.no-consumer-buffering" title="11.1.32.&nbsp;No Consumer Buffering">Section&nbsp;11.1.32, &#8220;No Consumer Buffering&#8221;</a> for an example which
               shows how to configure HornetQ to prevent consumer buffering when dealing with slow
               consumers.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3731"></a>19.1.2.&nbsp;Rate limited flow control</h3></div></div><div></div></div><p>It is also possible to control the <span class="emphasis"><em>rate</em></span> at which a consumer can
            consume messages. This is a form of throttling and can be used to make sure that a
            consumer never consumes messages at a rate faster than the rate specified. </p><p>The rate must be a positive integer to enable this functionality and is the maximum
            desired message consumption rate specified in units of messages per second. Setting this
            to <tt class="literal">-1</tt> disables rate limited flow control. The default value is
               <tt class="literal">-1</tt>.</p><p>Please see <a href="#examples.consumer-rate-limit" title="11.1.10.&nbsp;Message Consumer Rate Limiting">Section&nbsp;11.1.10, &#8220;Message Consumer Rate Limiting&#8221;</a> for a working example of
            limiting consumer rate.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="flow-control.rate.core.api"></a>19.1.2.1.&nbsp;Using Core API</h4></div></div><div></div></div><p>If the HornetQ core API is being used the rate can be set via the <tt class="literal">ClientSessionFactory.setConsumerMaxRate(int consumerMaxRate)</tt> method or
               alternatively via some of the <tt class="literal">ClientSession.createConsumer()</tt>
               methods. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3762"></a>19.1.2.2.&nbsp;Using JMS</h4></div></div><div></div></div><p>If JNDI is used to look up the connection factory, the max rate can be configured
               in <tt class="literal">hornetq-jms.xml</tt>:</p><pre class="programlisting">&lt;connection-factory name="ConnectionFactory"&gt;
      &lt;connectors&gt;
         &lt;connector-ref connector-name="netty-connector"/&gt;
      &lt;/connectors&gt;
      &lt;entries&gt;
         &lt;entry name="ConnectionFactory"/&gt;       
      &lt;/entries&gt;
      &lt;!-- We limit consumers created on this connection factory to consume messages
             at a maximum rate
      of 10 messages per sec --&gt;
      &lt;consumer-max-rate&gt;10&lt;/consumer-max-rate&gt;
 &lt;/connection-factory&gt;</pre><p>If the connection factory is directly instantiated, the max rate size can be set
               via the <tt class="literal">HornetQConnectionFactory.setConsumerMaxRate(int
                  consumerMaxRate)</tt> method.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Rate limited flow control can be used in conjunction with window based flow
                  control. Rate limited flow control only effects how many messages a client can
                  consume in a second and not how many messages are in its buffer. So if you had a
                  slow rate limit and a high window based limit the clients internal buffer would
                  soon fill up with messages.</p></div><p>Please see <a href="#examples.consumer-rate-limit" title="11.1.10.&nbsp;Message Consumer Rate Limiting">Section&nbsp;11.1.10, &#8220;Message Consumer Rate Limiting&#8221;</a> for an example which
               shows how to configure HornetQ to prevent consumer buffering when dealing with slow
               consumers.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3784"></a>19.2.&nbsp;Producer flow control</h2></div></div><div></div></div><p>HornetQ also can limit the amount of data sent from a client to a server to prevent the
         server being overwhelmed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3789"></a>19.2.1.&nbsp;Window based flow control</h3></div></div><div></div></div><p>In a similar way to consumer window based flow control, HornetQ producers, by
            default, can only send messages to an address as long as they have sufficient credits to
            do so. The amount of credits required to send a message is given by the size of the
            message.</p><p>As producers run low on credits they request more from the server, when the server
            sends them more credits they can send more messages.</p><p>The amount of credits a producer requests in one go is known as the <span class="italic">window size</span>.</p><p>The window size therefore determines the amount of bytes that can be in-flight at any
            one time before more need to be requested - this prevents the remoting connection from
            getting overloaded.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3803"></a>19.2.1.1.&nbsp;Using Core API</h4></div></div><div></div></div><p>If the HornetQ core API is being used, window size can be set via the <tt class="literal">ClientSessionFactory.setProducerWindowSize(int producerWindowSize)</tt>
               method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3811"></a>19.2.1.2.&nbsp;Using JMS</h4></div></div><div></div></div><p>If JNDI is used to look up the connection factory, the producer window size can be
               configured in <tt class="literal">hornetq-jms.xml</tt>:</p><pre class="programlisting">
               &lt;connection-factory name="ConnectionFactory"&gt;
                  &lt;connectors&gt;
                     &lt;connector-ref connector-name="netty-connector"/&gt;
                  &lt;/connectors&gt;
                  &lt;entries&gt;
                     &lt;entry name="ConnectionFactory"/&gt;       
                  &lt;/entries&gt;
                  &lt;producer-window-size&gt;10&lt;/producer-window-size&gt;
               &lt;/connection-factory&gt;</pre><p>If the connection factory is directly instantiated, the producer window size can
               be set via the <tt class="literal">HornetQConnectionFactory.setProducerWindowSize(int
                  producerWindowSize)</tt> method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3826"></a>19.2.1.3.&nbsp;Blocking producer window based flow control</h4></div></div><div></div></div><p>Normally the server will always give the same number of credits as have been
               requested. However, it is also possible to set a maximum size on any address, and the
               server will never send more credits than could cause the address's upper memory limit
               to be exceeded.</p><p>For example, if I have a JMS queue called "myqueue", I could set the maximum
               memory size to 10MiB, and the the server will control the number of credits sent to
               any producers which are sending any messages to myqueue such that the total messages
               in the queue never exceeds 10MiB.</p><p>When the address gets full, producers will block on the client side until more
               space frees up on the address, i.e. until messages are consumed from the queue thus
               freeing up space for more messages to be sent.</p><p>We call this blocking producer flow control, and it's an efficient way to prevent
               the server running out of memory due to producers sending more messages than can be
               handled at any time.</p><p>It is an alternative approach to paging, which does not block producers but
               instead pages messages to storage.</p><p>To configure an address with a maximum size and tell the server that you want to
               block producers for this address if it becomes full, you need to define an
               AddressSettings (<a href="#queue-attributes.address-settings" title="25.3.&nbsp;Configuring Queues Via Address Settings">Section&nbsp;25.3, &#8220;Configuring Queues Via Address Settings&#8221;</a>) block for the
               address and specify <tt class="literal">max-size-bytes</tt> and <tt class="literal">address-full-policy</tt></p><p>The address block applies to all queues registered to that address. I.e. the total
               memory for all queues bound to that address will not exceed <tt class="literal">max-size-bytes</tt>. In the case of JMS topics this means the <span class="italic">total</span> memory of all subscriptions in the topic won't
               exceed max-size-bytes.</p><p>Here's an example:</p><pre class="programlisting">
               &lt;address-settings&gt;
                  &lt;address-setting match="jms.queue.exampleQueue"&gt;            
                     &lt;max-size-bytes&gt;100000&lt;/max-size-bytes&gt;
                     &lt;address-full-policy&gt;BLOCK&lt;/address-full-policy&gt;   
                  &lt;/address-setting&gt;
               &lt;/address-settings&gt;</pre><p>The above example would set the max size of the JMS queue "exampleQueue" to be
               100000 bytes and would block any producers sending to that address to prevent that
               max size being exceeded.</p><p>Note the policy must be set to <tt class="literal">BLOCK</tt> to enable blocking producer
            flow control.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Note that in the default configuration all addresses are set to block producers after 10 MiB of message data
            is in the address. This means you cannot send more than 10MiB of message data to an address without it being consumed before the producers
            will be blocked. If you do not want this behaviour increase the <tt class="literal">max-size-bytes</tt> parameter or change the 
            address full message policy.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3873"></a>19.2.2.&nbsp;Rate limited flow control</h3></div></div><div></div></div><p>HornetQ also allows the rate a producer can emit message to be limited, in units of
            messages per second. By specifying such a rate, HornetQ will ensure that producer never
            produces messages at a rate higher than that specified.</p><p>The rate must be a positive integer to enable this functionality and is the maximum
            desired message consumption rate specified in units of messages per second. Setting this
            to <tt class="literal">-1</tt> disables rate limited flow control. The default value is
               <tt class="literal">-1</tt>.</p><p>Please see the <a href="#producer-rate-limiting-example" title="11.1.36.&nbsp;Message Producer Rate Limiting">Section&nbsp;11.1.36, &#8220;Message Producer Rate Limiting&#8221;</a> for a working example
            of limiting producer rate.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="flow-control.producer.rate.core.api"></a>19.2.2.1.&nbsp;Using Core API</h4></div></div><div></div></div><p>If the HornetQ core API is being used the rate can be set via the <tt class="literal">ClientSessionFactory.setProducerMaxRate(int consumerMaxRate)</tt> method or
               alternatively via some of the <tt class="literal">ClientSession.createProducer()</tt>
               methods. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3901"></a>19.2.2.2.&nbsp;Using JMS</h4></div></div><div></div></div><p>If JNDI is used to look up the connection factory, the max rate can be configured
               in <tt class="literal">hornetq-jms.xml</tt>:</p><pre class="programlisting">&lt;connection-factory name="ConnectionFactory"&gt;
      &lt;connectors&gt;
         &lt;connector-ref connector-name="netty-connector"/&gt;
      &lt;/connectors&gt;
      &lt;entries&gt;
         &lt;entry name="ConnectionFactory"/&gt;       
      &lt;/entries&gt;
      &lt;!-- We limit producers created on this connection factory to produce messages 
                at a maximum rate
      of 10 messages per sec --&gt;
      &lt;producer-max-rate&gt;10&lt;/producer-max-rate&gt;
 &lt;/connection-factory&gt;</pre><p>If the connection factory is directly instantiated, the max rate size can be set
               via the <tt class="literal">HornetQConnectionFactory.setProducerMaxRate(int
                  consumerMaxRate)</tt> method.</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="send-guarantees"></a>Chapter&nbsp;20.&nbsp;Guarantees of sends and commits</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3936"></a>20.1.&nbsp;Guarantees of Transaction Completion</h2></div></div><div></div></div><p>When committing or rolling back a transaction with HornetQ, the request to commit or
            rollback is sent to the server, and the call will block on the client side until a
            response has been received from the server that the commit or rollback was
            executed.</p><p>When the commit or rollback is received on the server, it will be committed to the
            journal, and depending on the value of the parameter <tt class="literal">journal-sync-transactional</tt> the server will ensure that the commit or
            rollback is durably persisted to storage before sending the response back to the client.
            If this parameter has the value <tt class="literal">false</tt> then commit or rollback may not
            actually get persisted to storage until some time after the response has been sent to
            the client. In event of server failure this may mean the commit or rollback never gets
            persisted to storage. The default value of this parameter is <tt class="literal">true</tt> so
            the client can be sure all transaction commits or rollbacks have been persisted to
            storage by the time the call to commit or rollback returns.</p><p>Setting this parameter to <tt class="literal">false</tt> can improve performance at the
            expense of some loss of transaction durability.</p><p>This parameter is set in <tt class="literal">hornetq-configuration.xml</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="non-transactional-sends"></a>20.2.&nbsp;Guarantees of Non Transactional Message Sends</h2></div></div><div></div></div><p>If you are sending messages to a server using a non transacted session, HornetQ can be
            configured to block the call to send until the message has definitely reached the
            server, and a response has been sent back to the client. This can be configured
            individually for durable and non-durable messages, and is determined by the
            following two parameters:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">BlockOnDurableSend</tt>. If this is set to <tt class="literal">true</tt> then all calls to send for durable messages on non
                    transacted sessions will block until the message has reached the server, and a
                    response has been sent back. The default value is <tt class="literal">true</tt>.
                </p></li><li><p><tt class="literal">BlockOnNonDurableSend</tt>. If this is set to <tt class="literal">true</tt> then all calls to send for non-durable messages on non
                    transacted sessions will block until the message has reached the server, and a
                    response has been sent back. The default value is <tt class="literal">false</tt>.</p></li></ul></div><p>Setting block on sends to <tt class="literal">true</tt> can reduce performance since each
            send requires a network round trip before the next send can be performed. This means the
            performance of sending messages will be limited by the network round trip time (RTT) of
            your network, rather than the bandwidth of your network. For better performance we
            recommend either batching many messages sends together in a transaction since with a
            transactional session, only the commit / rollback blocks not every send, or, using
            HornetQ's advanced <span class="emphasis"><em>asynchronous send acknowledgements feature</em></span>
            described in <a href="#asynchronous-send-acknowledgements" title="20.4.&nbsp;Asynchronous Send Acknowledgements">Section&nbsp;20.4, &#8220;Asynchronous Send Acknowledgements&#8221;</a>.</p><p>If you are using JMS and you're using the JMS service on the server to load your JMS
            connection factory instances into JNDI then these parameters can be configured in
                <tt class="literal">hornetq-jms.xml</tt> using the elements <tt class="literal">block-on-durable-send</tt> and <tt class="literal">block-on-non-durable-send</tt>. If you're using JMS but not using JNDI then
            you can set these values directly on the <tt class="literal">HornetQConnectionFactory</tt>
            instance using the appropriate setter methods.</p><p>If you're using core you can set these values directly on the <tt class="literal">ClientSessionFactory</tt> instance using the appropriate setter
            methods.</p><p>When the server receives a message sent from a non transactional session, and that
            message is durable and the message is routed to at least one durable queue, then the
            server will persist the message in permanent storage. If the journal parameter <tt class="literal">journal-sync-non-transactional</tt> is set to <tt class="literal">true</tt> the
            server will not send a response back to the client until the message has been persisted
            and the server has a guarantee that the data has been persisted to disk. The default
            value for this parameter is <tt class="literal">true</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="send-guarantees.nontrans.acks"></a>20.3.&nbsp;Guarantees of Non Transactional Acknowledgements</h2></div></div><div></div></div><p>If you are acknowledging the delivery of a message at the client side using a non
            transacted session, HornetQ can be configured to block the call to acknowledge until the
            acknowledge has definitely reached the server, and a response has been sent back to the
            client. This is configured with the parameter <tt class="literal">BlockOnAcknowledge</tt>. If
            this is set to <tt class="literal">true</tt> then all calls to acknowledge on non transacted
            sessions will block until the acknowledge has reached the server, and a response has
            been sent back. You might want to set this to <tt class="literal">true</tt> if you want to
            implement a strict <span class="emphasis"><em>at most once</em></span> delivery policy. The default value
            is <tt class="literal">false</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="asynchronous-send-acknowledgements"></a>20.4.&nbsp;Asynchronous Send Acknowledgements</h2></div></div><div></div></div><p>If you are using a non transacted session but want a guarantee that every message sent
            to the server has reached it, then, as discussed in <a href="#non-transactional-sends" title="20.2.&nbsp;Guarantees of Non Transactional Message Sends">Section&nbsp;20.2, &#8220;Guarantees of Non Transactional Message Sends&#8221;</a>, you can configure HornetQ to block the call to
            send until the server has received the message, persisted it and sent back a response.
            This works well but has a severe performance penalty - each call to send needs to block
            for at least the time of a network round trip (RTT) - the performance of sending is thus
            limited by the latency of the network, <span class="emphasis"><em>not</em></span> limited by the network
            bandwidth.</p><p>Let's do a little bit of maths to see how severe that is. We'll consider a standard
            1Gib ethernet network with a network round trip between the server and the client of
            0.25 ms.</p><p>With a RTT of 0.25 ms, the client can send <span class="emphasis"><em>at most</em></span> 1000/ 0.25 =
            4000 messages per second if it blocks on each message send.</p><p>If each message is &lt; 1500 bytes and a standard 1500 bytes MTU size is used on the
            network, then a 1GiB network has a <span class="emphasis"><em>theoretical</em></span> upper limit of (1024
            * 1024 * 1024 / 8) / 1500 = 89478 messages per second if messages are sent without
            blocking! These figures aren't an exact science but you can clearly see that being
            limited by network RTT can have serious effect on performance.</p><p>To remedy this, HornetQ provides an advanced new feature called <span class="emphasis"><em>asynchronous
                send acknowledgements</em></span>. With this feature, HornetQ can be configured to
            send messages without blocking in one direction and asynchronously getting
            acknowledgement from the server that the messages were received in a separate stream. By
            de-coupling the send from the acknowledgement of the send, the system is not limited by
            the network RTT, but is limited by the network bandwidth. Consequently better throughput
            can be achieved than is possible using a blocking approach, while at the same time
            having absolute guarantees that messages have successfully reached the server.</p><p>The window size for send acknowledgements is determined by the confirmation-window-size parameter on
        the connection factory or client session factory. Please see <a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">Chapter&nbsp;34, <i>Client Reconnection and Session Reattachment</i></a> for more info on this.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4079"></a>20.4.1.&nbsp;Asynchronous Send Acknowledgements</h3></div></div><div></div></div><p>To use the feature using the core API, you implement the interface <tt class="literal">org.hornetq.api.core.client.SendAcknowledgementHandler</tt> and set a handler
                instance on your <tt class="literal">ClientSession</tt>.</p><p>Then, you just send messages as normal using your <tt class="literal">ClientSession</tt>, and as messages reach the server, the server will send
                back an acknowledgement of the send asynchronously, and some time later you are
                informed at the client side by HornetQ calling your handler's <tt class="literal">sendAcknowledged(ClientMessage message)</tt> method, passing in a
                    reference to the message that was sent.</p><p>To enable asynchronous send acknowledgements you must make sure <tt class="literal">confirmation-window-size</tt> is set to a positive integer value, e.g. 10MiB</p><p>Please see <a href="#asynchronous-send-acknowledgements-example" title="11.1.45.&nbsp;Send Acknowledgements">Section&nbsp;11.1.45, &#8220;Send Acknowledgements&#8221;</a> for a full
                working example.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="undelivered-messages"></a>Chapter&nbsp;21.&nbsp;Message Redelivery and Undelivered Messages</h2></div></div><div></div></div><p>Messages can be delivered unsuccessfully (e.g. if the transacted session used to consume
      them is rolled back). Such a message goes back to its queue ready to be redelivered. However,
      this means it is possible for a message to be delivered again and again without any success
      and remain in the queue, clogging the system.</p><p>There are 2 ways to deal with these undelivered messages:</p><div class="itemizedlist"><ul type="disc"><li><p>Delayed redelivery.</p><p>It is possible to delay messages redelivery to let the client some time to recover
            from transient failures and not overload its network or CPU resources</p></li><li><p>Dead Letter Address.</p><p>It is also possible to configure a dead letter address so that after a specified
            number of unsuccessful deliveries, messages are removed from the queue and will not be
            delivered again</p></li></ul></div><p>Both options can be combined for maximum flexibility.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4144"></a>21.1.&nbsp;Delayed Redelivery</h2></div></div><div></div></div><p>Delaying redelivery can often be useful in the case that clients regularly fail or
         rollback. Without a delayed redelivery, the system can get into a "thrashing" state, with
         delivery being attempted, the client rolling back, and delivery being re-attempted ad
         infinitum in quick succession, consuming valuable CPU and network resources.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="undelivered-messages.delay"></a>21.1.1.&nbsp;Configuring Delayed Redelivery</h3></div></div><div></div></div><p>Delayed redelivery is defined in the address-setting configuration:</p><pre class="programlisting">
     &lt;!-- delay redelivery of messages for 5s --&gt;
     &lt;address-setting match="jms.queue.exampleQueue"&gt;
        &lt;redelivery-delay&gt;5000&lt;/redelivery-delay&gt;
     &lt;/address-setting&gt;
             </pre><p>If a <tt class="literal">redelivery-delay</tt> is specified, HornetQ will wait this delay
            before redelivering the messages</p><p>By default, there is no redelivery delay (<tt class="literal">redelivery-delay</tt>is set
            to 0).</p><p>Address wildcards can be used to configure redelivery delay for a set of addresses
            (see <a href="#wildcard-syntax" title="Chapter&nbsp;13.&nbsp;Understanding the HornetQ Wildcard Syntax">Chapter&nbsp;13, <i>Understanding the HornetQ Wildcard Syntax</i></a>), so you don't have to specify redelivery delay
            individually for each address.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4170"></a>21.1.2.&nbsp;Example</h3></div></div><div></div></div><p>See <a href="#examples.delayed-redelivery" title="11.1.12.&nbsp;Delayed Redelivery">Section&nbsp;11.1.12, &#8220;Delayed Redelivery&#8221;</a> for an example which shows how
            delayed redelivery is configured and used with JMS.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4177"></a>21.2.&nbsp;Dead Letter Addresses</h2></div></div><div></div></div><p>To prevent a client infinitely receiving the same undelivered message (regardless of
         what is causing the unsuccessful deliveries), messaging systems define <span class="italic">dead letter addresses</span>: after a specified unsuccessful delivery
         attempts, the message is removed from the queue and send instead to a dead letter address. </p><p>Any such messages can then be diverted to queue(s) where they can later be perused by
         the system administrator for action to be taken.</p><p>HornetQ's addresses can be assigned a dead letter address. Once the messages have be
         unsuccessfully delivered for a given number of attempts, they are removed from the queue
         and sent to the dead letter address. These <span class="emphasis"><em>dead letter</em></span> messages can
         later be consumed for further inspection.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="undelivered-messages.configuring"></a>21.2.1.&nbsp;Configuring Dead Letter Addresses</h3></div></div><div></div></div><p>Dead letter address is defined in the address-setting configuration:</p><pre class="programlisting">
     &lt;!-- undelivered messages in exampleQueue will be sent to the dead letter address 
        deadLetterQueue after 3 unsuccessful delivery attempts
      --&gt;
     &lt;address-setting match="jms.queue.exampleQueue"&gt;
        &lt;dead-letter-address&gt;jms.queue.deadLetterQueue&lt;/dead-letter-address&gt;
        &lt;max-delivery-attempts&gt;3&lt;/max-delivery-attempts&gt;
     &lt;/address-setting&gt;
             </pre><p>If a <tt class="literal">dead-letter-address</tt> is not specified, messages will removed
            after <tt class="literal">max-delivery-attempts</tt> unsuccessful attempts.</p><p>By default, messages are redelivered 10 times at the maximum. Set <tt class="literal">max-delivery-attempts</tt> to -1 for infinite redeliveries.</p><p>For example, a dead letter can be set globally for a set of matching addresses and
            you can set <tt class="literal">max-delivery-attempts</tt> to -1 for a specific address
            setting to allow infinite redeliveries only for this address.</p><p>Address wildcards can be used to configure dead letter settings for a set of
            addresses (see <a href="#wildcard-syntax" title="Chapter&nbsp;13.&nbsp;Understanding the HornetQ Wildcard Syntax">Chapter&nbsp;13, <i>Understanding the HornetQ Wildcard Syntax</i></a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4221"></a>21.2.2.&nbsp;Dead Letter Properties</h3></div></div><div></div></div><p>Dead letter messages which are consumed from a dead letter address have the following
            property:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">_HQ_ORIG_ADDRESS</tt></p><p>a String property containing the <span class="emphasis"><em>original address</em></span> of
                  the dead letter message </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4236"></a>21.2.3.&nbsp;Example</h3></div></div><div></div></div><p>See <a href="#examples.dead-letter" title="11.1.11.&nbsp;Dead Letter">Section&nbsp;11.1.11, &#8220;Dead Letter&#8221;</a> for an example which shows how dead letter
            is configured and used with JMS.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuring.delivery.count.persistence"></a>21.3.&nbsp;Delivery Count Persistence</h2></div></div><div></div></div><p>In normal use, HornetQ does not update delivery count <span class="emphasis"><em>persistently</em></span>
         until a message is rolled back (i.e. the delivery count is not updated
            <span class="emphasis"><em>before</em></span> the message is delivered to the consumer). In most messaging
         use cases, the messages are consumed, acknowledged and forgotten as soon as they are
         consumed. In these cases, updating the delivery count persistently before delivering the
         message would add an extra persistent step <span class="emphasis"><em>for each message delivered</em></span>,
         implying a significant performance penalty.</p><p>However, if the delivery count is not updated persistently before the message delivery
         happens, in the event of a server crash, messages might have been delivered but that will
         not have been reflected in the delivery count. During the recovery phase, the server will
         not have knowledge of that and will deliver the message with <tt class="literal">redelivered</tt>
         set to <tt class="literal">false</tt> while it should be <tt class="literal">true</tt>. </p><p>As this behavior breaks strict JMS semantics, HornetQ allows to persist delivery count
         before message delivery but disabled it by default for performance implications.</p><p>To enable it, set <tt class="literal">persist-delivery-count-before-delivery</tt> to <tt class="literal">true</tt> in <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">
&lt;persist-delivery-count-before-delivery&gt;true&lt;/persist-delivery-count-before-delivery&gt;
      </pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="message-expiry"></a>Chapter&nbsp;22.&nbsp;Message Expiry</h2></div></div><div></div></div><p>Messages can be set with an optional <span class="emphasis"><em>time to live</em></span> when sending
      them.</p><p>HornetQ will not deliver a message to a consumer after it's time to live has been exceeded.
      If the message hasn't been delivered by the time that time to live is reached the server can
      discard it.</p><p>HornetQ's addresses can be assigned a expiry address so that, when messages are expired,
      they are removed from the queue and sent to the expiry address. Many different queues can be
      bound to an expiry address. These <span class="emphasis"><em>expired</em></span> messages can later be consumed
      for further inspection.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4315"></a>22.1.&nbsp;Message Expiry</h2></div></div><div></div></div><p>Using HornetQ Core API, you can set an expiration time directly on the message:</p><pre class="programlisting">
// message will expire in 5000ms from now
message.setExpiration(System.currentTimeMillis() + 5000);         
              </pre><p>JMS MessageProducer allows to set a TimeToLive for the messages it sent:</p><pre class="programlisting">
// messages sent by this producer will be retained for 5s (5000ms) before expiration           
producer.setTimeToLive(5000);
        </pre><p>Expired messages which are consumed from an expiry address have the following
         properties:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">_HQ_ORIG_ADDRESS</tt></p><p>a String property containing the <span class="emphasis"><em>original address</em></span> of the
               expired message </p></li><li><p><tt class="literal">_HQ_ACTUAL_EXPIRY</tt></p><p>a Long property containing the <span class="emphasis"><em>actual expiration time</em></span> of the
               expired message</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-expiry.configuring"></a>22.2.&nbsp;Configuring Expiry Addresses</h2></div></div><div></div></div><p>Expiry address are defined in the address-setting configuration:</p><pre class="programlisting">
&lt;!-- expired messages in exampleQueue will be sent to the expiry address expiryQueue --&gt;
&lt;address-setting match="jms.queue.exampleQueue"&gt;
   &lt;expiry-address&gt;jms.queue.expiryQueue&lt;/expiry-address&gt;
&lt;/address-setting&gt;
        </pre><p>If messages are expired and no expiry address is specified, messages are simply removed
         from the queue and dropped. Address wildcards can be used to configure expiry address for a
         set of addresses (see <a href="#wildcard-syntax" title="Chapter&nbsp;13.&nbsp;Understanding the HornetQ Wildcard Syntax">Chapter&nbsp;13, <i>Understanding the HornetQ Wildcard Syntax</i></a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuring.expiry.reaper"></a>22.3.&nbsp;Configuring The Expiry Reaper Thread</h2></div></div><div></div></div><p>A reaper thread will periodically inspect the queues to check if messages have
         expired.</p><p>The reaper thread can be configured with the following properties in <tt class="literal">hornetq-configuration.xml</tt></p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">message-expiry-scan-period</tt></p><p>How often the queues will be scanned to detect expired messages (in milliseconds,
               default is 30000ms, set to <tt class="literal">-1</tt> to disable the reaper thread)</p></li><li><p><tt class="literal">message-expiry-thread-priority</tt></p><p>The reaper thread priority (it must be between 0 and 9, 9 being the highest
               priority, default is 3)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4383"></a>22.4.&nbsp;Example</h2></div></div><div></div></div><p>See <a href="#examples.expiry" title="11.1.28.&nbsp;Message Expiration">Section&nbsp;11.1.28, &#8220;Message Expiration&#8221;</a> for an example which shows how message expiry is
         configured and used with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="large-messages"></a>Chapter&nbsp;23.&nbsp;Large Messages</h2></div></div><div></div></div><p>HornetQ supports sending and receiving of huge messages, even when the client and server
        are running with limited memory. The only realistic limit to the size of a message that can
        be sent or consumed is the amount of disk space you have available. We have tested sending
        and consuming messages up to 8 GiB in size with a client and server running in just 50MiB of
        RAM!</p><p>To send a large message, the user can set an <tt class="literal">InputStream</tt> on a message
        body, and when that message is sent, HornetQ will read the <tt class="literal">InputStream</tt>. A
            <tt class="literal">FileInputStream</tt> could be used for example to send a huge message from
        a huge file on disk.</p><p>As the <tt class="literal">InputStream</tt> is read the data is sent to the server as a stream
        of fragments. The server persists these fragments to disk as it receives them and when the
        time comes to deliver them to a consumer they are read back of the disk, also in fragments
        and sent down the wire. When the consumer receives a large message it initially receives
        just the message with an empty body, it can then set an <tt class="literal">OutputStream</tt> on
        the message to stream the huge message body to a file on disk or elsewhere. At no time is
        the entire message body stored fully in memory, either on the client or the server.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="large.message.configuring"></a>23.1.&nbsp;Configuring the server</h2></div></div><div></div></div><p>Large messages are stored on a disk directory on the server side, as configured on the
            main configuration file.</p><p>The configuration property <tt class="literal">large-messages-directory</tt> specifies where
            large messages are stored.</p><pre class="programlisting">&lt;configuration xmlns="urn:hornetq"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="urn:hornetq /schema/hornetq-configuration.xsd"&gt;

...

&lt;large-message-directory&gt;/data/large-messages&lt;/large-message-directory&gt;

...

&lt;/configuration</pre><p>By default the large message directory is <tt class="literal">data/largemessages</tt></p><p>For the best performance we recommend large messages directory is stored on a
            different physical volume to the message journal or paging directory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4449"></a>23.2.&nbsp;Setting the limits</h2></div></div><div></div></div><p>Any message larger than a certain size is considered a large message. Large messages
            will be split up and sent in fragments. This is determined by the parameter <tt class="literal">min-large-message-size</tt></p><p>The default value is 100KiB.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="large-messages.core.config"></a>23.2.1.&nbsp;Using Core API</h3></div></div><div></div></div><p>If the HornetQ Core API is used, the minimal large message size is specified by
                    <tt class="literal">ClientSessionFactory.setMinLargeMessageSize</tt>.</p><pre class="programlisting">ClientSessionFactory factory = 
            HornetQClient.createClientSessionFactory(new 
            TransportConfiguration(NettyConnectorFactory.class.getName()), null);
factory.setMinLargeMessageSize(25 * 1024);</pre><p><a href="#configuring-transports.client.side" title="16.3.&nbsp;Configuring the transport directly from the client side.">Section&nbsp;16.3, &#8220;Configuring the transport directly from the client side.&#8221;</a> will provide more information
                on how to instantiate the session factory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4471"></a>23.2.2.&nbsp;Using JMS</h3></div></div><div></div></div><p>If JNDI is used to look up the connection factory, the minimum large message size
                is specified in <tt class="literal">hornetq-jms.xml</tt></p><pre class="programlisting">...
&lt;connection-factory name="ConnectionFactory"&gt;
&lt;connectors&gt;
   &lt;connector-ref connector-name="netty"/&gt;
&lt;/connectors&gt;
&lt;entries&gt;
   &lt;entry name="ConnectionFactory"/&gt;
   &lt;entry name="XAConnectionFactory"/&gt;
&lt;/entries&gt;
                
&lt;min-large-message-size&gt;250000&lt;/min-large-message-size&gt;
&lt;/connection-factory&gt;
...</pre><p>If the connection factory is being instantiated directly, the minimum large
                message size is specified by <tt class="literal">HornetQConnectionFactory.setMinLargeMessageSize</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4485"></a>23.3.&nbsp;Streaming large messages</h2></div></div><div></div></div><p>HornetQ supports setting the body of messages using input and output streams (<tt class="literal">java.lang.io</tt>)</p><p>These streams are then used directly for sending (input streams) and receiving (output
            streams) messages.</p><p>When receiving messages there are 2 ways to deal with the output stream; you may
            choose to block while the output stream is recovered using the method <tt class="literal">ClientMessage.saveOutputStream</tt> or alternatively using the method <tt class="literal">ClientMessage.setOutputstream</tt> which will asynchronously write the message
            to the stream. If you choose the latter the consumer must be kept alive until the
            message has been fully received.</p><p>You can use any kind of stream you like. The most common use case is to send files
            stored in your disk, but you could also send things like JDBC Blobs, <tt class="literal">SocketInputStream</tt>, things you recovered from <tt class="literal">HTTPRequests</tt> etc. Anything as long as it implements <tt class="literal">java.io.InputStream</tt> for sending messages or <tt class="literal">java.io.OutputStream</tt> for receiving them.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4517"></a>23.3.1.&nbsp;Streaming over Core API</h3></div></div><div></div></div><p>The following table shows a list of methods available at <tt class="literal">ClientMessage</tt> which are also available through JMS by the use of
                object properties.</p><div class="table"><a name="large-messages.ClientMessageAPI"></a><p class="title"><b>Table&nbsp;23.1.&nbsp;org.hornetq.api.core.client.ClientMessage API</b></p><table summary="org.hornetq.api.core.client.ClientMessage API" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Name</th><th>Description</th><th>JMS Equivalent Property</th></tr></thead><tbody><tr><td>setBodyInputStream(InputStream)</td><td>Set the InputStream used to read a message body when sending
                                it.</td><td>JMS_HQ_InputStream</td></tr><tr><td>setOutputStream(OutputStream)</td><td>Set the OutputStream that will receive the body of a message.
                                This method does not block.</td><td>JMS_HQ_OutputStream</td></tr><tr><td>saveOutputStream(OutputStream)</td><td>Save the body of the message to the <tt class="literal">OutputStream</tt>. It will block until the entire content
                                is transferred to the <tt class="literal">OutputStream</tt>.</td><td>JMS_HQ_SaveStream</td></tr></tbody></table></div><p>To set the output stream when receiving a core message: </p><pre class="programlisting">
...
ClientMessage msg = consumer.receive(...);


// This will block here until the stream was transferred
msg.saveOutputStream(someOutputStream); 

ClientMessage msg2 = consumer.receive(...);

// This will not wait the transfer to finish
msg.setOutputStream(someOtherOutputStream); 
...
                
            </pre><p> Set the input stream when sending a core message: </p><pre class="programlisting">
...
ClientMessage msg = session.createMessage();
msg.setInputStream(dataInputStream);
...
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="large-messages.streaming.over.jms"></a>23.3.2.&nbsp;Streaming over JMS</h3></div></div><div></div></div><p>When using JMS, HornetQ maps the streaming methods on the core API (see <a href="#large-messages.ClientMessageAPI" title="Table&nbsp;23.1.&nbsp;org.hornetq.api.core.client.ClientMessage API">Table&nbsp;23.1, &#8220;org.hornetq.api.core.client.ClientMessage API&#8221;</a>) by setting object properties . You
                can use the method <tt class="literal">Message.setObjectProperty</tt> to set the input and
                output streams.</p><p>The <tt class="literal">InputStream</tt> can be defined through the JMS Object Property
                JMS_HQ_InputStream on messages being sent:</p><pre class="programlisting">
BytesMessage message = session.createBytesMessage();

FileInputStream fileInputStream = new FileInputStream(fileInput);

BufferedInputStream bufferedInput = new BufferedInputStream(fileInputStream);

message.setObjectProperty("JMS_HQ_InputStream", bufferedInput);

someProducer.send(message);</pre><p>The <tt class="literal">OutputStream</tt> can be set through the JMS Object Property
                JMS_HQ_SaveStream on messages being received in a blocking way.</p><pre class="programlisting">
BytesMessage messageReceived = (BytesMessage)messageConsumer.receive(120000);
                
File outputFile = new File("huge_message_received.dat");
                
FileOutputStream fileOutputStream = new FileOutputStream(outputFile);
                
BufferedOutputStream bufferedOutput = new BufferedOutputStream(fileOutputStream);
                
// This will block until the entire content is saved on disk
messageReceived.setObjectProperty("JMS_HQ_SaveStream", bufferedOutput);
            </pre><p>Setting the <tt class="literal">OutputStream</tt> could also be done in a non blocking
                way using the property JMS_HQ_OutputStream.</p><pre class="programlisting">
// This won't wait the stream to finish. You need to keep the consumer active.
messageReceived.setObjectProperty("JMS_HQ_OutputStream", bufferedOutput);
            </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When using JMS, Streaming large messages are only supported on <tt class="literal">StreamMessage</tt> and <tt class="literal">BytesMessage</tt>.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4616"></a>23.4.&nbsp;Streaming Alternative</h2></div></div><div></div></div><p>If you choose not to use the <tt class="literal">InputStream</tt> or <tt class="literal">OutputStream</tt> capability of HornetQ You could still access the data
            directly in an alternative fashion.</p><p>On the Core API just get the bytes of the body as you normally would.</p><pre class="programlisting">ClientMessage msg = consumer.receive();
         
byte[] bytes = new byte[1024];
for (int i = 0 ;  i &lt; msg.getBodySize(); i += bytes.length)
{
   msg.getBody().readBytes(bytes);
   // Whatever you want to do with the bytes
}</pre><p>If using JMS API, <tt class="literal">BytesMessage</tt> and <tt class="literal">StreamMessage</tt>
            also supports it transparently.</p><pre class="programlisting">BytesMessage rm = (BytesMessage)cons.receive(10000);

byte data[] = new byte[1024];

for (int i = 0; i &lt; rm.getBodyLength(); i += 1024)
{
   int numberOfBytes = rm.readBytes(data);
   // Do whatever you want with the data
}        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="large-messages.cache.client"></a>23.5.&nbsp;Cache Large Messages on client</h2></div></div><div></div></div><p>Large messages are transferred by streaming from server to client. The message is
            broken into smaller packets and as the message is read more packets will be received.
            Because of that the body of the large message can be read only once, and by consequence
            a received message can be sent to another producer only once. The JMS Bridge for
            instance won't be able to resend a large message in case of failure</p><p>To solve this problem, you can enable the property <tt class="literal">cache-large-message-client</tt> on the connection factory. If you enable this
            property the client consumer will create a temporary file to hold the large message
            content, so it would be possible to resend large messages.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>Use this option on the connection factory used by the JMS Bridge if the JMS Bridge is
            being used for large messages.</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="large-messages.example"></a>23.6.&nbsp;Large message example</h2></div></div><div></div></div><p>Please see <a href="#examples.large-message" title="11.1.22.&nbsp;Large Message">Section&nbsp;11.1.22, &#8220;Large Message&#8221;</a> for an example which shows how
            large message is configured and used with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="paging"></a>Chapter&nbsp;24.&nbsp;Paging</h2></div></div><div></div></div><p>HornetQ transparently supports huge queues containing millions of messages while the
        server is running with limited memory.</p><p>In such a situation it's not possible to store all of the queues in memory at any one
        time, so HornetQ transparently <span class="emphasis"><em>pages</em></span> messages into and out of memory as
        they are needed, thus allowing massive queues with a low memory footprint.</p><p>HornetQ will start paging messages to disk, when the size of all messages in memory for an
        address exceeds a configured maximum size.</p><p>By default, HornetQ does not page messages - this must be explicitly configured to
        activate it.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4691"></a>24.1.&nbsp;Page Files</h2></div></div><div></div></div><p>Messages are stored per address on the file system. Each address has an individual
            folder where messages are stored in multiple files (page files). Each file will contain
            messages up to a max configured size (<tt class="literal">page-size-bytes</tt>). When reading
            page-files all messages on the page-file are read, routed and the file is deleted as
            soon as the messages are recovered.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paging.main.config"></a>24.2.&nbsp;Configuration</h2></div></div><div></div></div><p>You can configure the location of the paging folder</p><p>Global paging parameters are specified on the main configuration file (<tt class="literal">hornetq-configuration.xml</tt>).</p><pre class="programlisting">&lt;configuration xmlns="urn:hornetq"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="urn:hornetq /schema/hornetq-configuration.xsd"&gt;
            
            ...
            
            &lt;paging-directory&gt;/somewhere/paging-directory&lt;/paging-directory&gt;
            
            ...        </pre><p>
            </p><div class="table"><a name="d0e4713"></a><p class="title"><b>Table&nbsp;24.1.&nbsp;Paging Configuration Parameters</b></p><table summary="Paging Configuration Parameters" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><tt class="literal">paging-directory</tt></td><td>Where page files are stored. HornetQ will create one folder for
                                each address being paged under this configured location.</td><td>data/paging</td></tr></tbody></table></div><p>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="paging.mode"></a>24.3.&nbsp;Paging Mode</h2></div></div><div></div></div><p>As soon as messages delivered to an address exceed the configured size, that address
            alone goes into page mode.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Paging is done individually per address. If you configure a max-size-bytes for an
                address, that means each matching address will have a maximum size that you
                specified. It DOES NOT mean that the total overall size of all matching addresses is
                limited to max-size-bytes.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4746"></a>24.3.1.&nbsp;Configuration</h3></div></div><div></div></div><p>Configuration is done at the address settings, done at the main configuration file
                    (<tt class="literal">hornetq-configuration.xml</tt>).</p><pre class="programlisting">  &lt;address-settings&gt;
      &lt;address-setting match="jms.someaddress"&gt;
         &lt;max-size-bytes&gt;104857600&lt;/max-size-bytes&gt;
         &lt;page-size-bytes&gt;10485760&lt;/page-size-bytes&gt;
         &lt;address-full-policy&gt;PAGE&lt;/address-full-policy&gt;
      &lt;/address-setting&gt;
   &lt;/address-settings&gt;
        </pre><p>This is the list of available parameters on the address settings.</p><p>
                </p><div class="table"><a name="d0e4760"></a><p class="title"><b>Table&nbsp;24.2.&nbsp;Paging Address Settings</b></p><table summary="Paging Address Settings" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><tt class="literal">max-size-bytes</tt></td><td>What's the max memory the address could have before entering
                                    on page mode.</td><td>-1 (disabled)</td></tr><tr><td><tt class="literal">page-size-bytes</tt></td><td>The size of each page file used on the paging system</td><td>10MiB (10 * 1024 * 1024 bytes)</td></tr><tr><td><tt class="literal">address-full-policy</tt></td><td>This must be set to PAGE for paging to enable. If the value
                                    is PAGE then further messages will be paged to disk. If the
                                    value is DROP then further messages will be silently dropped. If
                                    the value is BLOCK then client message producers will block when
                                    they try and send further messages.</td><td>PAGE</td></tr></tbody></table></div><p>
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4801"></a>24.4.&nbsp;Dropping messages</h2></div></div><div></div></div><p>Instead of paging messages when the max size is reached, an address can also be
            configured to just drop messages when the address is full.</p><p>To do this just set the <tt class="literal">address-full-policy</tt> to <tt class="literal">DROP</tt> in the address settings</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4814"></a>24.5.&nbsp;Blocking producers</h2></div></div><div></div></div><p>Instead of paging messages when the max size is reached, an address can also be
            configured to block producers from sending further messages when the address is full,
            thus preventing the memory being exhausted on the server.</p><p>When memory is freed up on the server, producers will automatically unblock and be
            able to continue sending.</p><p>To do this just set the <tt class="literal">address-full-policy</tt> to <tt class="literal">BLOCK</tt> in the address settings</p><p>In the default configuration, all addresses are configured to block producers after 10 MiB of data are in the address.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4831"></a>24.6.&nbsp;Caution with Addresses with Multiple Queues</h2></div></div><div></div></div><p>When a message is routed to an address that has multiple queues bound to it, e.g. a
            JMS subscription, there is only 1 copy of the message in memory. Each queue only deals
            with a reference to this. Because of this the memory is only freed up once all queues
            referencing the message have delivered it. This means that if not all queues deliver the
            message we can end up in a state where messages are not delivered. </p><p>For example:</p><div class="itemizedlist"><ul type="disc"><li><p>An address has 10 queues </p></li><li><p>One of the queues does not deliver its messages (maybe because of a slow
                    consumer).</p></li><li><p>Messages continually arrive at the address and paging is started.</p></li><li><p>The other 9 queues are empty even though messages have been sent.</p></li></ul></div><p>In this example we have to wait until the last queue has delivered some of its
            messages before we depage and the other queues finally receive some more
            messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4853"></a>24.7.&nbsp;Paging and message selectors</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Please note that message selectors will only operate on messages in memory. If you
                have a large amount of messages paged to disk and a selector that only matches some
                of the paged messages, then those messages won't be consumed until the messages in
                memory have been consumed. HornetQ does not scan through page files on disk to
                locate matching messages. To do this efficiently would mean implementing and
                managing indexes amongst other things. Effectively we would be writing a relational
                database! This is not the primary role of a messaging system. If you find yourself
                using selectors which only select small subsets of messages in very large queues
                which are too large to fit in memory at any one time, then you probably want a
                relational database not a messaging system - you're effectively executing queries
                over tables.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4859"></a>24.8.&nbsp;Paging and browsers</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Please note that message browsers only operate over messages in memory. They do
                not operate over messages paged to disk. Messages are paged to disk
                    <span class="emphasis"><em>before</em></span> they are routed to any queues, so when they are
                paged, they are not in any queues, so will not appear when browsing any queues.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4868"></a>24.9.&nbsp;Paging and unacknowledged messages</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> Please note that until messages are acknowledged they are still in memory on the
                server, so they contribute to the size of messages on a particular address. If
                messages are paged to disk for an address, and are being consumed, they will be
                depaged from disk when enough memory has been freed up in that address after
                messages have been consumed and acknowledged. However if messages are not
                acknowledged then more messages will not be depaged since there is no free space in
                memory. In this case message consumption can appear to hang. If not acknowledging
                explictly messages are acknowledged according to the <tt class="literal">ack-batch-size</tt> setting. Be careful not to set your paging max size to
                a figure lower than ack-batch-size or your system may appear to hang! </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4877"></a>24.10.&nbsp;Example</h2></div></div><div></div></div><p>See <a href="#examples.paging" title="11.1.34.&nbsp;Paging">Section&nbsp;11.1.34, &#8220;Paging&#8221;</a> for an example which shows how to use paging
            with HornetQ.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="queue-attributes"></a>Chapter&nbsp;25.&nbsp;Queue Attributes</h2></div></div><div></div></div><p>Queue attributes can be set in one of two ways. Either by configuring them using the
        configuration file or by using the core API. This chapter will explain how to configure each
        attribute and what effect the attribute has.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="predefined.queues"></a>25.1.&nbsp;Predefined Queues</h2></div></div><div></div></div><p>Queues can be predefined via configuration at a core level or at a JMS level. Firstly
            lets look at a JMS level.</p><p>The following shows a queue predefined in the <tt class="literal">hornetq-jms.xml</tt>
            configuration file.</p><pre class="programlisting">&lt;queue name="selectorQueue"&gt;
      &lt;entry name="/queue/selectorQueue"/&gt;
      &lt;selector string="color='red'"/&gt;
      &lt;durable&gt;true&lt;/durable&gt;
&lt;/queue&gt;</pre><p>This name attribute of queue defines the name of the queue. When we do this at a jms
            level we follow a naming convention so the actual name of the core queue will be
                <tt class="literal">jms.queue.selectorQueue</tt>.</p><p>The entry element configures the name that will be used to bind the queue to JNDI.
            This is a mandatory element and the queue can contain multiple of these to bind the same
            queue to different names.</p><p>The selector element defines what JMS message selector the predefined queue will have.
            Only messages that match the selector will be added to the queue. This is an optional
            element with a default of null when omitted.</p><p>The durable element specifies whether the queue will be persisted. This again is
            optional and defaults to true if omitted.</p><p>Secondly a queue can be predefined at a core level in the <tt class="literal">hornetq-configuration.xml</tt> file. The following is an example.</p><pre class="programlisting">&lt;queues&gt;     
   	&lt;queue name="jms.queue.selectorQueue"&gt;
   	    &lt;address&gt;jms.queue.selectorQueue&lt;/address&gt;
   	    &lt;filter string="color='red'"/&gt;
       &lt;durable&gt;true&lt;/durable&gt;
   	&lt;/queue&gt;
&lt;/queues&gt;</pre><p>This is very similar to the JMS configuration, with 3 real differences which
            are.</p><div class="orderedlist"><ol type="1"><li><p>The name attribute of queue is the actual name used for the queue with no
                    naming convention as in JMS.</p></li><li><p>The address element defines what address is used for routing messages.</p></li><li><p>There is no entry element.</p></li><li><p>The filter uses the <span class="emphasis"><em>Core filter syntax</em></span> (described in
                        <a href="#filter-expressions" title="Chapter&nbsp;14.&nbsp;Filter Expressions">Chapter&nbsp;14, <i>Filter Expressions</i></a>), <span class="emphasis"><em>not</em></span> the JMS
                    selector syntax.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4959"></a>25.2.&nbsp;Using the API</h2></div></div><div></div></div><p>Queues can also be created using the core API or the management API.</p><p>For the core API, queues can be created via the <tt class="literal">org.hornetq.api.core.client.ClientSession</tt> interface. There are multiple
                <tt class="literal">createQueue</tt> methods that support setting all of the previously
            mentioned attributes. There is one extra attribute that can be set via this API which is
                <tt class="literal">temporary</tt>. setting this to true means that the queue will be
            deleted once the session is disconnected.</p><p>Take a look at <a href="#management" title="Chapter&nbsp;30.&nbsp;Management">Chapter&nbsp;30, <i>Management</i></a> for a description of the management API
            for creating queues.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="queue-attributes.address-settings"></a>25.3.&nbsp;Configuring Queues Via Address Settings</h2></div></div><div></div></div><p>There are some attributes that are defined against an address wildcard rather than a
            specific queue. Here an example of an <tt class="literal">address-setting</tt> entry that
            would be found in the <tt class="literal">hornetq-configuration.xml</tt> file.</p><pre class="programlisting">&lt;address-settings&gt;
    &lt;address-setting match="jms.queue.exampleQueue"&gt;
        &lt;dead-letter-address&gt;jms.queue.deadLetterQueue&lt;/dead-letter-address&gt;
        &lt;max-delivery-attempts&gt;3&lt;/max-delivery-attempts&gt;
        &lt;redelivery-delay&gt;5000&lt;/redelivery-delay&gt;
        &lt;expiry-address&gt;jms.queue.expiryQueue&lt;/expiry-address&gt;
        &lt;last-value-queue&gt;true&lt;/last-value-queue&gt;        
        &lt;max-size-bytes&gt;100000&lt;/max-size-bytes&gt;
        &lt;page-size-bytes&gt;20000&lt;/page-size-bytes&gt;
        &lt;redistribution-delay&gt;0&lt;/redistribution-delay&gt;
        &lt;send-to-dla-on-no-route&gt;true&lt;/send-to-dla-on-no-route&gt;
        &lt;address-full-policy&gt;PAGE&lt;/address-full-policy&gt;
     &lt;/address-setting&gt;
&lt;/address-settings&gt;</pre><p>The idea with address settings, is you can provide a block of settings which will be
            applied against any adresses that match the string in the <tt class="literal">match</tt> attribute. In the
            above example the settings would only be applied to any addresses which exactly match
            the address <tt class="literal">jms.queue.exampleQueue</tt>, but you can also use wildcards to apply sets of
            configuration against many addresses. The wildcard syntax used is described <a href="#wildcard-syntax" title="Chapter&nbsp;13.&nbsp;Understanding the HornetQ Wildcard Syntax">here</a>.</p><p>For example, if you used the <tt class="literal">match</tt> string <tt class="literal">jms.queue.#</tt> the settings would be applied
        to all addresses which start with <tt class="literal">jms.queue.</tt> which would be all JMS queues.</p><p>The meaning of the specific settings are explained fully throughout the user manual, however here is a brief
            description with a link to the appropriate chapter if available. </p><p><tt class="literal">max-delivery-attempts</tt> defines how many time a cancelled message can
            be redelivered before sending to the <tt class="literal">dead-letter-address</tt>. A full
            explanation can be found <a href="#undelivered-messages.configuring" title="21.2.1.&nbsp;Configuring Dead Letter Addresses">here</a>.</p><p><tt class="literal">redelivery-delay</tt> defines how long to wait before attempting
            redelivery of a cancelled message. see <a href="#undelivered-messages.delay" title="21.1.1.&nbsp;Configuring Delayed Redelivery">here</a>.</p><p><tt class="literal">expiry-address</tt> defines where to send a message that has expired.
            see <a href="#message-expiry.configuring" title="22.2.&nbsp;Configuring Expiry Addresses">here</a>.</p><p><tt class="literal">last-value-queue</tt> defines whether a queue only uses last values or
            not. see <a href="#last-value-queues" title="Chapter&nbsp;27.&nbsp;Last-Value Queues">here</a>.</p><p><tt class="literal">max-size-bytes</tt> and <tt class="literal">page-size-bytes</tt> are used to
            set paging on an address. This is explained <a href="#paging" title="Chapter&nbsp;24.&nbsp;Paging">here</a>.</p><p><tt class="literal">redistribution-delay</tt> defines how long to wait when the last
            consumer is closed on a queue before redistributing any messages. see <a href="#clusters.message-redistribution" title="38.6.&nbsp;Message Redistribution">here</a>.</p><p><tt class="literal">send-to-dla-on-no-route</tt>. If a message is sent to an address, but the server does not route it to any queues,
        for example, there might be no queues bound to that address, or none of the queues have filters that match, then normally that message
        would be discarded. However if this parameter is set to true for that address, if the message is not routed to any queues it will instead
        be sent to the dead letter address (DLA) for that address, if it exists.</p><p><tt class="literal">address-full-policy</tt>. This attribute can have one of the following values: PAGE, DROP or BLOCK and determines what happens when
            an address where <tt class="literal">max-size-bytes</tt> is specified becomes full. The default value is PAGE. If the value is PAGE then further messages will be paged to disk.
            If the value is DROP then further messages will be silently dropped. 
            If the value is BLOCK then client message producers will block when they try and send further messages.
        
        See the following chapters for more info <a href="#flow-control" title="Chapter&nbsp;19.&nbsp;Flow Control">Chapter&nbsp;19, <i>Flow Control</i></a>, <a href="#paging" title="Chapter&nbsp;24.&nbsp;Paging">Chapter&nbsp;24, <i>Paging</i></a>.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="scheduled-messages"></a>Chapter&nbsp;26.&nbsp;Scheduled Messages</h2></div></div><div></div></div><p>Scheduled messages differ from normal messages in that they won't be delivered until a
      specified time in the future, at the earliest.</p><p>To do this, a special property is set on the message before sending it.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5103"></a>26.1.&nbsp;Scheduled Delivery Property</h2></div></div><div></div></div><p>The property name used to identify a scheduled message is <tt class="literal">"_HQ_SCHED_DELIVERY"</tt> (or the constant <tt class="literal">Message.HDR_SCHEDULED_DELIVERY_TIME</tt>).</p><p>The specified value must be a positive <tt class="literal">long</tt> corresponding to the time the
         message must be delivered (in milliseconds). An example of sending a scheduled message
         using the JMS API is as follows.</p><pre class="programlisting">
  TextMessage message = 
   session.createTextMessage("This is a scheduled message message which will be delivered
     in 5 sec.");
  message.setLongProperty("_HQ_SCHED_DELIVERY", System.currentTimeMillis() + 5000);
  producer.send(message);

  ...
         
  // message will not be received immediately but 5 seconds later
  TextMessage messageReceived = (TextMessage) consumer.receive();
      </pre><p>Scheduled messages can also be sent using the core API, by setting the same property on
         the core message before sending.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5123"></a>26.2.&nbsp;Example</h2></div></div><div></div></div><p>See <a href="#examples.scheduled-message" title="11.1.43.&nbsp;Scheduled Message">Section&nbsp;11.1.43, &#8220;Scheduled Message&#8221;</a> for an example which shows how
         scheduled messages can be used with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="last-value-queues"></a>Chapter&nbsp;27.&nbsp;Last-Value Queues</h2></div></div><div></div></div><p>Last-Value queues are special queues which discard any messages when a newer message with
      the same value for a well-defined Last-Value property is put in the queue. In other words, a
      Last-Value queue only retains the last value.</p><p>A typical example for Last-Value queue is for stock prices, where you are only interested
      by the latest value for a particular stock.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5154"></a>27.1.&nbsp;Configuring Last-Value Queues</h2></div></div><div></div></div><p>Last-value queues are defined in the address-setting configuration:</p><pre class="programlisting">
&lt;address-setting match="jms.queue.lastValueQueue"&gt;
    &lt;last-value-queue&gt;true&lt;/last-value-queue&gt;
&lt;/address-setting&gt;
            </pre><p>By default, <tt class="literal">last-value-queue</tt> is false. Address wildcards can be used
         to configure Last-Value queues for a set of addresses (see <a href="#wildcard-syntax" title="Chapter&nbsp;13.&nbsp;Understanding the HornetQ Wildcard Syntax">Chapter&nbsp;13, <i>Understanding the HornetQ Wildcard Syntax</i></a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5168"></a>27.2.&nbsp;Using Last-Value Property</h2></div></div><div></div></div><p>The property name used to identify the last value is <tt class="literal">"_HQ_LVQ_NAME"</tt>
         (or the constant <tt class="literal">Message.HDR_LAST_VALUE_NAME</tt> from the Core API).</p><p>For example, if two messages with the same value for the Last-Value property are sent to
         a Last-Value queue, only the latest message will be kept in the queue:</p><pre class="programlisting">
// send 1st message with Last-Value property set to STOCK_NAME
TextMessage message = 
  session.createTextMessage("1st message with Last-Value property set");
message.setStringProperty("_HQ_LVQ_NAME", "STOCK_NAME");
producer.send(message);

// send 2nd message with Last-Value property set to STOCK_NAME             
message = 
  session.createTextMessage("2nd message with Last-Value property set");
message.setStringProperty("_HQ_LVQ_NAME", "STOCK_NAME");
producer.send(message);
       
...
       
// only the 2nd message will be received: it is the latest with 
// the Last-Value property set
TextMessage messageReceived = (TextMessage)messageConsumer.receive(5000);
System.out.format("Received message: %s\n", messageReceived.getText());             
            </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5183"></a>27.3.&nbsp;Example</h2></div></div><div></div></div><p>See <a href="#examples.last-value-queue" title="11.1.23.&nbsp;Last-Value Queue">Section&nbsp;11.1.23, &#8220;Last-Value Queue&#8221;</a> for an example which shows how last
         value queues are configured and used with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="message-grouping"></a>Chapter&nbsp;28.&nbsp;Message Grouping</h2></div></div><div></div></div><p>Message groups are sets of messages that have the following characteristics:</p><div class="itemizedlist"><ul type="disc"><li><p>Messages in a message group share the same group id, i.e. they have same group
            identifier property (<tt class="literal">JMSXGroupID</tt> for JMS, <tt class="literal">_HQ_GROUP_ID</tt> for HornetQ Core API).</p></li><li><p>Messages in a message group are always consumed by the same consumer, even if there
            are many consumers on a queue. They pin all messages with the same group id to the same
            consumer. If that consumer closes another consumer is chosen and will receive all
            messages with the same group id.</p></li></ul></div><p>Message groups are useful when you want all messages for a certain value of the property to
      be processed serially by the same consumer.</p><p>An example might be orders for a certain stock. You may want orders for any particular
      stock to be processed serially by the same consumer. To do this you can create a pool of
      consumers (perhaps one for each stock, but less will work too), then set the stock name as the
      value of the _HQ_GROUP_ID property.</p><p>This will ensure that all messages for a particular stock will always be processed by the
      same consumer.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5231"></a>28.1.&nbsp;Using Core API</h2></div></div><div></div></div><p>The property name used to identify the message group is <tt class="literal">"_HQ_GROUP_ID"</tt> (or the constant <tt class="literal">MessageImpl.HDR_GROUP_ID</tt>). Alternatively, you can set <tt class="literal">autogroup</tt> to true on the <tt class="literal">SessionFactory</tt> which will pick a
         random unique id. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="message-grouping.jmsconfigure"></a>28.2.&nbsp;Using JMS</h2></div></div><div></div></div><p>The property name used to identify the message group is <tt class="literal">JMSXGroupID</tt>.</p><pre class="programlisting">
 // send 2 messages in the same group to ensure the same
 // consumer will receive both
 Message message = ...
 message.setStringProperty("JMSXGroupID", "Group-0");
 producer.send(message);

 message = ...
 message.setStringProperty("JMSXGroupID", "Group-0");
 producer.send(message);          
       </pre><p>Alternatively, you can set <tt class="literal">autogroup</tt> to true on the <tt class="literal">HornetQConnectonFactory</tt> which will pick a random unique id. This can also be
         set in the <tt class="literal">hornetq-jms.xml</tt> file like this:</p><pre class="programlisting">&lt;connection-factory name="ConnectionFactory"&gt;
      &lt;connectors&gt;
         &lt;connector-ref connector-name="netty-connector"/&gt;
      &lt;/connectors&gt;
      &lt;entries&gt;
         &lt;entry name="ConnectionFactory"/&gt;
      &lt;/entries&gt;
      &lt;autogroup&gt;true&lt;/autogroup&gt;
&lt;/connection-factory&gt;</pre><p>Alternatively you can set the group id via the connection factory. All messages sent
         with producers created via this connection factory will set the <tt class="literal">JMSXGroupID</tt> to the specified value on all messages sent. To configure the
         group id set it on the connection factory in the <tt class="literal">hornetq-jms.xml</tt> config
         file as follows
         </p><pre class="programlisting">
         &lt;connection-factory name="ConnectionFactory"&gt;
      &lt;connectors&gt;
         &lt;connector-ref connector-name="netty-connector"/&gt;
      &lt;/connectors&gt;
      &lt;entries&gt;
         &lt;entry name="ConnectionFactory"/&gt;
      &lt;/entries&gt;
      &lt;group-id&gt;Group-0&lt;/group-id&gt;
   &lt;/connection-factory&gt;
      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5281"></a>28.3.&nbsp;Example</h2></div></div><div></div></div><p>See <a href="#examples.message-group" title="11.1.29.&nbsp;Message Group">Section&nbsp;11.1.29, &#8220;Message Group&#8221;</a> for an example which shows how message
         groups are configured and used with JMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5288"></a>28.4.&nbsp;Example</h2></div></div><div></div></div><p>See <a href="#examples.message-group2" title="11.1.30.&nbsp;Message Group">Section&nbsp;11.1.30, &#8220;Message Group&#8221;</a> for an example which shows how message
         groups are configured via a connection factory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5295"></a>28.5.&nbsp; Clustered Grouping</h2></div></div><div></div></div><p>Using message groups in a cluster is a bit more complex. This is because messages with a
         particular group id can arrive on any node so each node needs to know about which group
         id's are bound to which consumer on which node. The consumer handling messages for a
         particular group id may be on a different node of the cluster, so each node needs to know
         this information so it can route the message correctly to the node which has that consumer. </p><p>To solve this there is the notion of a grouping handler. Each node will have its own
         grouping handler and when a messages is sent with a group id assigned, the handlers will
         decide between them which route the message should take.</p><p>There are 2 types of handlers; Local and Remote. Each cluster should choose 1 node to
         have a local grouping handler and all the other nodes should have remote handlers- it's the
         local handler that actually makes the decsion as to what route should be used, all the
         other remote handlers converse with this. Here is a sample config for both types of
         handler, this should be configured in the <span class="italic">hornetq-configuration.xml</span>
         file.</p><pre class="programlisting">   &lt;grouping-handler name="my-grouping-handler"&gt;
      &lt;type&gt;LOCAL&lt;/type&gt;
      &lt;address&gt;jms&lt;/address&gt;
      &lt;timeout&gt;5000&lt;/timeout&gt;
   &lt;/grouping-handler&gt;

   &lt;grouping-handler name="my-grouping-handler"&gt;
      &lt;type&gt;REMOTE&lt;/type&gt;
      &lt;address&gt;jms&lt;/address&gt;
      &lt;timeout&gt;5000&lt;/timeout&gt;
   &lt;/grouping-handler&gt;</pre><p>The <span class="italic">address</span> attribute refers to a cluster connection
         and the address it uses, refer to the clustering section on how to configure clusters. The
            <span class="italic">timeout</span> attribute referes to how long to wait for a
         decision to be made, an exception will be thrown during the send if this timeout is
         reached, this ensures that strict ordering is kept.</p><p>The decision as to where a message should be routed to is initially proposed by the node
         that receives the message. The node will pick a suitable route as per the normal clustered
         routing conditions, i.e. round robin available queues, use a local queue first and choose a
         queue that has a consumer. If the proposal is accepted by the grouping handlers the node
         will route messages to this queue from that point on, if rejected an alternative route will
         be offered and the node will again route to that queue indefinitely. All other nodes will
         also route to the queue chosen at proposal time. Once the message arrives at the queue then
         normal single server message group semantics take over and the message is pinned to a
         consumer on that queue.</p><p>You may have noticed that there is a single point of failure with the single local
         handler. If this node crashes then no decisions will be able to be made. Any messages sent
         will be not be delivered and an exception thrown. To avoid this happening Local Handlers
         can be replicated on another backup node. Simple create your back up node and configure it
         with the same Local handler.</p><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5322"></a>28.5.1.&nbsp;Clustered Grouping Best Practices</h3></div></div><div></div></div><p>Some best practices should be followed when using clustered grouping:</p><div class="orderedlist"><ol type="1"><li><p>Make sure your consumers are distributed evenly across the different nodes
                     if possible. This is only an issue if you are creating and closing consumers
                     regularly. Since messages are always routed to the same queue once pinned,
                     removing a consumer from this queue may leave it with no consumers meaning the
                     queue will just keep receiving the messages. Avoid closing consumers or make
                     sure that you always have plenty of consumers, i.e., if you have 3 nodes have 3
                     consumers.</p></li><li><p>Use durable queues if possible. If queues are removed once a group is bound
                     to it, then it is possible that other nodes may still try to route messages to
                     it. This can be avoided by making sure that the queue is deleted by the session
                     that is sending the messages. This means that when the next message is sent it
                     is sent to the node where the queue was deleted meaning a new proposal can
                     succesfully take place. Alternatively you could just start using a different
                     group id.</p></li><li><p>Always make sure that the node that has the Local Grouping Handler is
                     replicated. These means that on failover grouping will still occur.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5337"></a>28.5.2.&nbsp;Clustered Grouping Example</h3></div></div><div></div></div><p>See <a href="#examples.clustered.grouping" title="11.1.6.&nbsp;Clustered Grouping">Section&nbsp;11.1.6, &#8220;Clustered Grouping&#8221;</a> for an example of how to configure
            message groups with a HornetQ cluster</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="pre-acknowledge"></a>Chapter&nbsp;29.&nbsp;Pre-Acknowledge Mode</h2></div></div><div></div></div><p>JMS specifies 3 acknowledgement modes:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">AUTO_ACKNOWLEDGE</tt></p></li><li><p><tt class="literal">CLIENT_ACKNOWLEDGE</tt></p></li><li><p><tt class="literal">DUPS_OK_ACKNOWLEDGE</tt></p></li></ul></div><p>However there is another case which is not supported by JMS: In some cases you can afford
      to lose messages in event of failure, so it would make sense to acknowledge the message on the
      server <span class="emphasis"><em>before</em></span> delivering it to the client.</p><p>This extra mode is supported by HornetQ and will call it
         <span class="emphasis"><em>pre-acknowledge</em></span> mode.</p><p>The disadvantage of acknowledging on the server before delivery is that the message will be
      lost if the system crashes <span class="emphasis"><em>after</em></span> acknowledging the message on the server
      but <span class="emphasis"><em>before</em></span> it is delivered to the client. In that case, the message is
      lost and will not be recovered when the system restart.</p><p>Depending on your messaging case, <tt class="literal">pre-acknowledgement</tt> mode can avoid
      extra network traffic and CPU at the cost of coping with message loss.</p><p>An example of a use case for pre-acknowledgement is for stock price update messages. With
      these messages it might be reasonable to lose a message in event of crash, since the next
      price update message will arrive soon, overriding the previous price. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Please note, that if you use pre-acknowledge mode, then you will lose transactional
         semantics for messages being consumed, since clearly they are being acknowledged first on
         the server, not when you commit the transaction. This may be stating the obvious but we
         like to be clear on these things to avoid confusion!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pre-acknowledge.configure"></a>29.1.&nbsp;Using PRE_ACKNOWLEDGE</h2></div></div><div></div></div><p>This can be configured in the <tt class="literal">hornetq-jms.xml</tt> file on the <tt class="literal">connection factory</tt> like this:</p><pre class="programlisting">&lt;connection-factory name="ConnectionFactory"&gt;
      &lt;connectors&gt;
         &lt;connector-ref connector-name="netty-connector"/&gt;
      &lt;/connectors&gt;
      &lt;entries&gt;
         &lt;entry name="ConnectionFactory"/&gt;
      &lt;/entries&gt;
      &lt;pre-acknowledge&gt;true&lt;/pre-acknowledge&gt;
&lt;/connection-factory&gt;</pre><p>Alternatively, to use pre-acknowledgement mode using the JMS API, create a JMS Session
         with the <tt class="literal">HornetQSession.PRE_ACKNOWLEDGE</tt> constant.</p><pre class="programlisting">
// messages will be acknowledge on the server *before* being delivered to the client
Session session = connection.createSession(false, HornetQSession.PRE_ACKNOWLEDGE);
      </pre><p>Or you can set pre-acknowledge directly on the <tt class="literal">HornetQConnectionFactory</tt> instance using the setter method.</p><p>To use pre-acknowledgement mode using the core API you can set it directly on the
            <tt class="literal">ClientSessionFactory</tt> instance using the setter method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5437"></a>29.2.&nbsp;Example</h2></div></div><div></div></div><p>See <a href="#examples.pre-acknowledge" title="11.1.35.&nbsp;Pre-Acknowledge">Section&nbsp;11.1.35, &#8220;Pre-Acknowledge&#8221;</a> for an example which shows how to use
         pre-acknowledgement mode with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="management"></a>Chapter&nbsp;30.&nbsp;Management</h2></div></div><div></div></div><p>HornetQ has an extensive management API that allows a user to modify a server
      configuration, create new resources (e.g. JMS queues and topics), inspect these resources
      (e.g. how many messages are currently held in a queue) and interact with it (e.g. to remove
      messages from a queue). All the operations allows a client to <span class="emphasis"><em>manage</em></span>
      HornetQ. It also allows clients to subscribe to management notifications.</p><p>There are 3 ways to manage HornetQ:</p><div class="itemizedlist"><ul type="disc"><li><p>Using JMX -- JMX is the standard way to manage Java applications</p></li><li><p>Using the core API -- management operations are sent to HornetQ server using
               <span class="emphasis"><em>core messages</em></span></p></li><li><p>Using the JMS API -- management operations are sent to HornetQ server using
               <span class="emphasis"><em>JMS messages</em></span></p></li></ul></div><p>Although there are 3 different ways to manage HornetQ each API supports the same
      functionality. If it is possible to manage a resource using JMX it is also possible to achieve
      the same result using Core messages or JMS messages.</p><p>This choice depends on your requirements, your application settings and your environment to
      decide which way suits you best.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5489"></a>30.1.&nbsp;The Management API</h2></div></div><div></div></div><p>Regardless of the way you <span class="emphasis"><em>invoke</em></span> management operations, the
         management API is the same.</p><p>For each <span class="emphasis"><em>managed resource</em></span>, there exists a Java interface describing
         what can be invoked for this type of resource.</p><p>HornetQ exposes its managed resources in 2 packages:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Core</em></span> resources are located in the <tt class="literal">org.hornetq.api.core.management</tt> package</p></li><li><p><span class="emphasis"><em>JMS</em></span> resources are located in the <tt class="literal">org.hornetq.api.jms.management</tt> package</p></li></ul></div><p>The way to invoke a <span class="emphasis"><em>management operations</em></span> depends whether JMX, core
         messages, or JMS messages are used.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A few management operations requires a <tt class="literal">filter</tt> parameter to chose
            which messages are involved by the operation. Passing <tt class="literal">null</tt> or an
            empty string means that the management operation will be performed on <span class="emphasis"><em>all
               messages</em></span>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5538"></a>30.1.1.&nbsp;Core Management API</h3></div></div><div></div></div><p>HornetQ defines a core management API to manage core resources. For full details of
            the API please consult the javadoc. In summary:</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5543"></a>30.1.1.1.&nbsp;Core Server Management</h4></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Listing, creating, deploying and destroying queues</p><p>A list of deployed core queues can be retrieved using the <tt class="literal">getQueueNames()</tt> method.</p><p>Core queues can be created or destroyed using the management operations
                        <tt class="literal">createQueue()</tt> or <tt class="literal">deployQueue()</tt> or
                        <tt class="literal">destroyQueue()</tt>)on the <tt class="literal">HornetQServerControl</tt> (with the ObjectName <tt class="literal">org.hornetq:module=Core,type=Server</tt> or the resource name <tt class="literal">core.server</tt>)</p><p><tt class="literal">createQueue</tt> will fail if the queue already exists while
                        <tt class="literal">deployQueue</tt> will do nothing.</p></li><li><p>Pausing and resuming Queues</p><p>The <tt class="literal">QueueControl</tt> can pause and resume the underlying
                     queue. When a queue is paused, it will receive messages but will not deliver
                     them. When it's resumed, it'll begin delivering the queued messages, if any.
                  </p></li><li><p>Listing and closing remote connections</p><p>Client's remote addresses can be retrieved using <tt class="literal">listRemoteAddresses()</tt>. It is also possible to close the
                     connections associated with a remote address using the <tt class="literal">closeConnectionsForAddress()</tt> method.</p><p>Alternatively, connection IDs can be listed using <tt class="literal">listConnectionIDs()</tt> and all the sessions for a given connection
                     ID can be listed using <tt class="literal">listSessions()</tt>.</p></li><li><p>Transaction heuristic operations</p><p>In case of a server crash, when the server restarts, it it possible that
                     some transaction requires manual intervention. The <tt class="literal">listPreparedTransactions()</tt> method lists the transactions which
                     are in the prepared states (the transactions are represented as opaque Base64
                     Strings.) To commit or rollback a given prepared transaction, the <tt class="literal">commitPreparedTransaction()</tt> or <tt class="literal">rollbackPreparedTransaction()</tt> method can be used to resolve
                     heuristic transactions. Heuristically completed transactions can be listed
                     using the <tt class="literal">listHeuristicCommittedTransactions()</tt> and <tt class="literal">listHeuristicRolledBackTransactions</tt> methods.</p></li><li><p>Enabling and resetting Message counters</p><p>Message counters can be enabled or disabled using the <tt class="literal">enableMessageCounters()</tt> or <tt class="literal">disableMessageCounters()</tt> method. To reset message counters, it is
                     possible to invoke <tt class="literal">resetAllMessageCounters()</tt> and <tt class="literal">resetAllMessageCounterHistories()</tt> methods.</p></li><li><p>Retrieving the server configuration and attributes</p><p>The <tt class="literal">HornetQServerControl</tt> exposes HornetQ server
                     configuration through all its attributes (e.g. <tt class="literal">getVersion()</tt>
                     method to retrieve the server's version, etc.)</p></li><li><p>Listing, creating and destroying Core bridges and diverts</p><p>A list of deployed core bridges (resp. diverts) can be retrieved using the <tt class="literal">getBridgeNames()</tt> (resp. <tt class="literal">getDivertNames()</tt>) method.</p><p>Core bridges (resp. diverts) can be created or destroyed using the management operations
                        <tt class="literal">createBridge()</tt> and <tt class="literal">destroyBridge()</tt> 
                        (resp. <tt class="literal">createDivert()</tt> and <tt class="literal">destroyDivert()</tt>) on the <tt class="literal">HornetQServerControl</tt> (with the ObjectName <tt class="literal">org.hornetq:module=Core,type=Server</tt> or the resource name <tt class="literal">core.server</tt>).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5691"></a>30.1.1.2.&nbsp;Core Address Management</h4></div></div><div></div></div><p>Core addresses can be managed using the <tt class="literal">AddressControl</tt> class
               (with the ObjectName <tt class="literal">org.hornetq:module=Core,type=Address,name="&lt;the
                  address name&gt;"</tt> or the resource name <tt class="literal">core.address.&lt;the
                  address name&gt;</tt>). </p><div class="itemizedlist"><ul type="disc"><li><p>Modifying roles and permissions for an address</p><p>You can add or remove roles associated to a queue using the <tt class="literal">addRole()</tt> or <tt class="literal">removeRole()</tt> methods. You can
                     list all the roles associated to the queue with the <tt class="literal">getRoles()</tt> method</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5720"></a>30.1.1.3.&nbsp;Core Queue Management</h4></div></div><div></div></div><p>The bulk of the core management API deals with core queues. The <tt class="literal">QueueControl</tt> class defines the Core queue management operations (with
               the ObjectName <tt class="literal">org.hornetq:module=Core,type=Queue,address="&lt;the bound
                  address&gt;",name="&lt;the queue name&gt;"</tt> or the resource name <tt class="literal">core.queue.&lt;the queue name&gt;</tt>).</p><p>Most of the management operations on queues take either a single message ID (e.g.
               to remove a single message) or a filter (e.g. to expire all messages with a given
               property.)</p><div class="itemizedlist"><ul type="disc"><li><p>Expiring, sending to a dead letter address and moving messages</p><p>Messages can be expired from a queue by using the <tt class="literal">expireMessages()</tt> method. If an expiry address is defined,
                     messages will be sent to it, otherwise they are discarded. The queue's
                     expiry address can be set with the <tt class="literal">setExpiryAddress()</tt>
                     method.</p><p>Messages can also be sent to a dead letter address with the <tt class="literal">sendMessagesToDeadLetterAddress()</tt> method. It returns the number
                     of messages which are sent to the dead letter address. If a dead letter address
                     is not defined, message are removed from the queue and discarded. The queue's
                     dead letter address can be set with the <tt class="literal">setDeadLetterAddress()</tt> method.</p><p>Messages can also be moved from a queue to another queue by using the
                        <tt class="literal">moveMessages()</tt> method.</p></li><li><p>Listing and removing messages</p><p>Messages can be listed from a queue by using the <tt class="literal">listMessages()</tt> method which returns an array of <tt class="literal">Map</tt>, one <tt class="literal">Map</tt> for each message.</p><p>Messages can also be removed from the queue by using the <tt class="literal">removeMessages()</tt> method which returns a <tt class="literal">boolean</tt> for the single message ID variant or the number of
                     removed messages for the filter variant. The <tt class="literal">removeMessages()</tt> method takes a <tt class="literal">filter</tt>
                     argument to remove only filtered messages. Setting the filter to an empty
                     string will in effect remove all messages.</p></li><li><p>Counting messages</p><p>The number of messages in a queue is returned by the <tt class="literal">getMessageCount()</tt> method. Alternatively, the <tt class="literal">countMessages()</tt> will return the number of messages in the queue
                     which <span class="emphasis"><em>match a given filter</em></span></p></li><li><p>Changing message priority</p><p>The message priority can be changed by using the <tt class="literal">changeMessagesPriority()</tt> method which returns a <tt class="literal">boolean</tt> for the single message ID variant or the number of
                     updated messages for the filter variant.</p></li><li><p>Message counters</p><p>Message counters can be listed for a queue with the <tt class="literal">listMessageCounter()</tt> and <tt class="literal">listMessageCounterHistory()</tt> methods (see <a href="#management.message-counters" title="30.6.&nbsp;Message Counters">Section&nbsp;30.6, &#8220;Message Counters&#8221;</a>). The message counters can also be
                     reset for a single queue using the <tt class="literal">resetMessageCounter()</tt>
                     method.</p></li><li><p>Retrieving the queue attributes</p><p>The <tt class="literal">QueueControl</tt> exposes Core queue settings through its
                     attributes (e.g. <tt class="literal">getFilter()</tt> to retrieve the queue's filter
                     if it was created with one, <tt class="literal">isDurable()</tt> to know whether the
                     queue is durable or not, etc.)</p></li><li><p>Pausing and resuming Queues</p><p>The <tt class="literal">QueueControl</tt> can pause and resume the underlying
                     queue. When a queue is paused, it will receive messages but will not deliver
                     them. When it's resume, it'll begin delivering the queued messages, if any.
                  </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5851"></a>30.1.1.4.&nbsp;Other Core Resources Management</h4></div></div><div></div></div><p>HornetQ allows to start and stop its remote resources (acceptors, diverts,
               bridges, etc.) so that a server can be taken off line for a given period of time
               without stopping it completely (e.g. if other management operations must be performed
               such as resolving heuristic transactions). These resources are:</p><div class="itemizedlist"><ul type="disc"><li><p>Acceptors</p><p>They can be started or stopped using the <tt class="literal">start()</tt> or.
                        <tt class="literal">stop()</tt> method on the <tt class="literal">AcceptorControl</tt>
                     class (with the ObjectName <tt class="literal">org.hornetq:module=Core,type=Acceptor,name="&lt;the acceptor
                        name&gt;"</tt> or the resource name <tt class="literal">core.acceptor.&lt;the
                        address name&gt;</tt>). The acceptors parameters can be retrieved using
                     the <tt class="literal">AcceptorControl</tt> attributes (see <a href="#configuring-transports.acceptors" title="16.1.&nbsp;Understanding Acceptors">Section&nbsp;16.1, &#8220;Understanding Acceptors&#8221;</a>)</p></li><li><p>Diverts</p><p>They can be started or stopped using the <tt class="literal">start()</tt> or
                        <tt class="literal">stop()</tt> method on the <tt class="literal">DivertControl</tt>
                     class (with the ObjectName <tt class="literal">org.hornetq:module=Core,type=Divert,name=&lt;the divert name&gt;</tt>
                     or the resource name <tt class="literal">core.divert.&lt;the divert name&gt;</tt>).
                     Diverts parameters can be retrieved using the <tt class="literal">DivertControl</tt>
                     attributes (see <a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">Chapter&nbsp;35, <i>Diverting and Splitting Message Flows</i></a>)</p></li><li><p>Bridges</p><p>They can be started or stopped using the <tt class="literal">start()</tt> (resp.
                        <tt class="literal">stop()</tt>) method on the <tt class="literal">BridgeControl</tt>
                     class (with the ObjectName <tt class="literal">org.hornetq:module=Core,type=Bridge,name="&lt;the bridge
                        name&gt;"</tt> or the resource name <tt class="literal">core.bridge.&lt;the bridge
                        name&gt;</tt>). Bridges parameters can be retrieved using the <tt class="literal">BridgeControl</tt> attributes (see <a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">Chapter&nbsp;36, <i>Core Bridges</i></a>)</p></li><li><p>Broadcast groups</p><p>They can be started or stopped using the <tt class="literal">start()</tt> or
                        <tt class="literal">stop()</tt> method on the <tt class="literal">BroadcastGroupControl</tt> class (with the ObjectName <tt class="literal">org.hornetq:module=Core,type=BroadcastGroup,name="&lt;the broadcast group
                        name&gt;"</tt> or the resource name <tt class="literal">core.broadcastgroup.&lt;the broadcast group name&gt;</tt>). Broadcast
                     groups parameters can be retrieved using the <tt class="literal">BroadcastGroupControl</tt> attributes (see <a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">Section&nbsp;38.2.1, &#8220;Broadcast Groups&#8221;</a>)</p></li><li><p>Discovery groups</p><p>They can be started or stopped using the <tt class="literal">start()</tt> or
                        <tt class="literal">stop()</tt> method on the <tt class="literal">DiscoveryGroupControl</tt> class (with the ObjectName <tt class="literal">org.hornetq:module=Core,type=DiscoveryGroup,name="&lt;the discovery group
                        name&gt;"</tt> or the resource name <tt class="literal">core.discovery.&lt;the
                        discovery group name&gt;</tt>). Discovery groups parameters can be
                     retrieved using the <tt class="literal">DiscoveryGroupControl</tt> attributes (see
                        <a href="#clusters.discovery-groups" title="38.2.2.&nbsp;Discovery Groups">Section&nbsp;38.2.2, &#8220;Discovery Groups&#8221;</a>)</p></li><li><p>Cluster connections</p><p>They can be started or stopped using the <tt class="literal">start()</tt> or
                        <tt class="literal">stop()</tt> method on the <tt class="literal">ClusterConnectionControl</tt> class (with the ObjectName <tt class="literal">org.hornetq:module=Core,type=ClusterConnection,name="&lt;the cluster
                        connection name&gt;"</tt> or the resource name <tt class="literal">core.clusterconnection.&lt;the cluster connection name&gt;</tt>).
                     Cluster connections parameters can be retrieved using the <tt class="literal">ClusterConnectionControl</tt> attributes (see <a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">Section&nbsp;38.3.1, &#8220;Configuring Cluster Connections&#8221;</a>)</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6007"></a>30.1.2.&nbsp;JMS Management API</h3></div></div><div></div></div><p>HornetQ defines a JMS Management API to manage JMS <span class="emphasis"><em>administrated
               objects</em></span> (i.e. JMS queues, topics and connection factories).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6015"></a>30.1.2.1.&nbsp;JMS Server Management</h4></div></div><div></div></div><p>JMS Resources (connection factories and destinations) can be created using the
                  <tt class="literal">JMSServerControl</tt> class (with the ObjectName <tt class="literal">org.hornetq:module=JMS,type=Server</tt> or the resource name <tt class="literal">jms.server</tt>).</p><div class="itemizedlist"><ul type="disc"><li><p>Listing, creating, destroying connection factories</p><p>Names of the deployed connection factories can be retrieved by the <tt class="literal">getConnectionFactoryNames()</tt> method.</p><p>JMS connection factories can be created or destroyed using the <tt class="literal">createConnectionFactory()</tt> methods or <tt class="literal">destroyConnectionFactory()</tt> methods. These connection factories
                     are bound to JNDI so that JMS clients can look them up. If a graphical console
                     is used to create the connection factories, the transport parameters are
                     specified in the text field input as a comma-separated list of key=value (e.g.
                        <tt class="literal">key1=10, key2="value", key3=false</tt>). If there are multiple
                     transports defined, you need to enclose the key/value pairs between curly
                     braces. For example <tt class="literal">{key=10}, {key=20}</tt>. In that case, the
                     first <tt class="literal">key</tt> will be associated to the first transport
                     configuration and the second <tt class="literal">key</tt> will be associated to the
                     second transport configuration (see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a>
                     for a list of the transport parameters)</p></li><li><p>Listing, creating, destroying queues</p><p>Names of the deployed JMS queues can be retrieved by the <tt class="literal">getQueueNames()</tt> method.</p><p>JMS queues can be created or destroyed using the <tt class="literal">createQueue()</tt> methods or <tt class="literal">destroyQueue()</tt>
                     methods. These queues are bound to JNDI so that JMS clients can look them
                     up</p></li><li><p>Listing, creating/destroying topics</p><p>Names of the deployed topics can be retrieved by the <tt class="literal">getTopicNames()</tt> method.</p><p>JMS topics can be created or destroyed using the <tt class="literal">createTopic()</tt> or <tt class="literal">destroyTopic()</tt> methods. These
                     topics are bound to JNDI so that JMS clients can look them up</p></li><li><p>Listing and closing remote connections</p><p>JMS Clients remote addresses can be retrieved using <tt class="literal">listRemoteAddresses()</tt>. It is also possible to close the
                     connections associated with a remote address using the <tt class="literal">closeConnectionsForAddress()</tt> method.</p><p>Alternatively, connection IDs can be listed using <tt class="literal">listConnectionIDs()</tt> and all the sessions for a given connection
                     ID can be listed using <tt class="literal">listSessions()</tt>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6111"></a>30.1.2.2.&nbsp;JMS ConnectionFactory Management</h4></div></div><div></div></div><p>JMS Connection Factories can be managed using the <tt class="literal">ConnectionFactoryControl</tt> class (with the ObjectName <tt class="literal">org.hornetq:module=JMS,type=ConnectionFactory,name="&lt;the connection factory
                  name&gt;"</tt> or the resource name <tt class="literal">jms.connectionfactory.&lt;the
                  connection factory name&gt;</tt>).</p><div class="itemizedlist"><ul type="disc"><li><p>Retrieving connection factory attributes</p><p>The <tt class="literal">ConnectionFactoryControl</tt> exposes JMS
                     ConnectionFactory configuration through its attributes (e.g. <tt class="literal">getConsumerWindowSize()</tt> to retrieve the consumer window size for
                     flow control, <tt class="literal">isBlockOnNonDurableSend()</tt> to know whether the
                     producers created from the connection factory will block or not when sending
                     non-durable messages, etc.)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6140"></a>30.1.2.3.&nbsp;JMS Queue Management</h4></div></div><div></div></div><p>JMS queues can be managed using the <tt class="literal">JMSQueueControl</tt> class (with
               the ObjectName <tt class="literal">org.hornetq:module=JMS,type=Queue,name="&lt;the queue
                  name&gt;"</tt> or the resource name <tt class="literal">jms.queue.&lt;the queue
                  name&gt;</tt>). </p><p><span class="emphasis"><em>The management operations on a JMS queue are very similar to the
                  operations on a core queue. </em></span></p><div class="itemizedlist"><ul type="disc"><li><p>Expiring, sending to a dead letter address and moving messages</p><p>Messages can be expired from a queue by using the <tt class="literal">expireMessages()</tt> method. If an expiry address is defined,
                     messages will be sent to it, otherwise they are discarded. The queue's
                     expiry address can be set with the <tt class="literal">setExpiryAddress()</tt>
                     method.</p><p>Messages can also be sent to a dead letter address with the <tt class="literal">sendMessagesToDeadLetterAddress()</tt> method. It returns the number
                     of messages which are sent to the dead letter address. If a dead letter address
                     is not defined, message are removed from the queue and discarded. The queue's
                     dead letter address can be set with the <tt class="literal">setDeadLetterAddress()</tt> method.</p><p>Messages can also be moved from a queue to another queue by using the
                        <tt class="literal">moveMessages()</tt> method.</p></li><li><p>Listing and removing messages</p><p>Messages can be listed from a queue by using the <tt class="literal">listMessages()</tt> method which returns an array of <tt class="literal">Map</tt>, one <tt class="literal">Map</tt> for each message.</p><p>Messages can also be removed from the queue by using the <tt class="literal">removeMessages()</tt> method which returns a <tt class="literal">boolean</tt> for the single message ID variant or the number of
                     removed messages for the filter variant. The <tt class="literal">removeMessages()</tt> method takes a <tt class="literal">filter</tt>
                     argument to remove only filtered messages. Setting the filter to an empty
                     string will in effect remove all messages.</p></li><li><p>Counting messages</p><p>The number of messages in a queue is returned by the <tt class="literal">getMessageCount()</tt> method. Alternatively, the <tt class="literal">countMessages()</tt> will return the number of messages in the queue
                     which <span class="emphasis"><em>match a given filter</em></span></p></li><li><p>Changing message priority</p><p>The message priority can be changed by using the <tt class="literal">changeMessagesPriority()</tt> method which returns a <tt class="literal">boolean</tt> for the single message ID variant or the number of
                     updated messages for the filter variant.</p></li><li><p>Message counters</p><p>Message counters can be listed for a queue with the <tt class="literal">listMessageCounter()</tt> and <tt class="literal">listMessageCounterHistory()</tt> methods (see <a href="#management.message-counters" title="30.6.&nbsp;Message Counters">Section&nbsp;30.6, &#8220;Message Counters&#8221;</a>)</p></li><li><p>Retrieving the queue attributes</p><p>The <tt class="literal">JMSQueueControl</tt> exposes JMS queue settings through
                     its attributes (e.g. <tt class="literal">isTemporary()</tt> to know whether the queue
                     is temporary or not, <tt class="literal">isDurable()</tt> to know whether the queue is
                     durable or not, etc.)</p></li><li><p>Pausing and resuming queues</p><p>The <tt class="literal">JMSQueueControl</tt> can pause and resume the underlying
                     queue. When the queue is paused it will continue to receive messages but will
                     not deliver them. When resumed again it will deliver the enqueued messages, if
                     any. </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6269"></a>30.1.2.4.&nbsp;JMS Topic Management</h4></div></div><div></div></div><p>JMS Topics can be managed using the <tt class="literal">TopicControl</tt> class (with
               the ObjectName <tt class="literal">org.hornetq:module=JMS,type=Topic,name="&lt;the topic
                  name&gt;"</tt> or the resource name <tt class="literal">jms.topic.&lt;the topic
                  name&gt;</tt>).</p><div class="itemizedlist"><ul type="disc"><li><p>Listing subscriptions and messages</p><p>JMS topics subscriptions can be listed using the <tt class="literal">listAllSubscriptions()</tt>, <tt class="literal">listDurableSubscriptions()</tt>, <tt class="literal">listNonDurableSubscriptions()</tt> methods. These methods return
                     arrays of <tt class="literal">Object</tt> representing the subscriptions information
                     (subscription name, client ID, durability, message count, etc.). It is also
                     possible to list the JMS messages for a given subscription with the <tt class="literal">listMessagesForSubscription()</tt> method.</p></li><li><p>Dropping subscriptions</p><p>Durable subscriptions can be dropped from the topic using the <tt class="literal">dropDurableSubscription()</tt> method.</p></li><li><p>Counting subscriptions messages</p><p>The <tt class="literal">countMessagesForSubscription()</tt> method can be used to
                     know the number of messages held for a given subscription (with an optional
                     message selector to know the number of messages matching the selector)</p></li></ul></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="management.jmx"></a>30.2.&nbsp;Using Management Via JMX</h2></div></div><div></div></div><p>HornetQ can be managed using <a href="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/" target="_top">JMX</a>. </p><p>The management API is exposed by HornetQ using MBeans interfaces. HornetQ registers its
         resources with the domain <tt class="literal">org.hornetq</tt>.</p><p>For example, the <tt class="literal">ObjectName</tt> to manage a JMS Queue <tt class="literal">exampleQueue</tt> is:</p><pre class="programlisting">
   org.hornetq:module=JMS,type=Queue,name="exampleQueue"   
      </pre><p>and the MBean is:</p><pre class="programlisting">
   org.hornetq.api.jms.management.JMSQueueControl   
      </pre><p>The MBean's <tt class="literal">ObjectName</tt> are built using the helper class <tt class="literal">org.hornetq.api.core.management.ObjectNameBuilder</tt>. You can also use <tt class="literal">jconsole</tt> to find the <tt class="literal">ObjectName</tt> of the MBeans you want to
         manage. </p><p>Managing HornetQ using JMX is identical to management of any Java Applications using
         JMX. It can be done by reflection or by creating proxies of the MBeans.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="management.jmx.configuration"></a>30.2.1.&nbsp;Configuring JMX</h3></div></div><div></div></div><p>By default, JMX is enabled to manage HornetQ. It can be disabled by setting <tt class="literal">jmx-management-enabled</tt> to <tt class="literal">false</tt> in <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">
&lt;!-- false to disable JMX management for HornetQ --&gt;
&lt;jmx-management-enabled&gt;false&lt;/jmx-management-enabled&gt;            
         </pre><p>If JMX is enabled, HornetQ can be managed locally using <tt class="literal">jconsole</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Remote connections to JMX are not enabled by default for security reasons. Please refer
            to <a href="http://java.sun.com/j2se/1.5.0/docs/guide/management/agent.html#remote" target="_top">Java Management guide</a> to configure the server for remote management (system
            properties must be set in <tt class="literal">run.sh</tt> or <tt class="literal">run.bat</tt>
            scripts).</p></div><p>By default, HornetQ server uses the JMX domain "org.hornetq". To manage several
            HornetQ servers from the <span class="emphasis"><em>same</em></span> MBeanServer, the JMX domain can be
            configured for each individual HornetQ server by setting <tt class="literal">jmx-domain</tt>
            in <tt class="literal">hornetq-configuration.xml</tt>: </p><pre class="programlisting">
&lt;!-- use a specific JMX domain for HornetQ MBeans --&gt;
&lt;jmx-domain&gt;my.org.hornetq&lt;/jmx-domain&gt;            
         </pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6409"></a>30.2.1.1.&nbsp;MBeanServer configuration</h4></div></div><div></div></div><p>When HornetQ is run in standalone, it uses the Java Virtual Machine's <tt class="literal">Platform MBeanServer</tt> to register its MBeans. This is configured in
               JBoss Microcontainer Beans file (see <a href="#server.microcontainer.configuration" title="6.7.&nbsp;JBoss Microcontainer Beans File">Section&nbsp;6.7, &#8220;JBoss Microcontainer Beans File&#8221;</a>):</p><pre class="programlisting">&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="java.lang.management.ManagementFactory"
                         factoryMethod="getPlatformMBeanServer" /&gt;
&lt;/bean&gt;            
            </pre><p>When it is integrated in JBoss AS 5+, it uses the Application Server's own MBean
               Server so that it can be managed using AS 5's jmx-console:</p><pre class="programlisting">&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="org.jboss.mx.util.MBeanServerLocator"
                         factoryMethod="locateJBoss" /&gt;
&lt;/bean&gt;            
            </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6425"></a>30.2.2.&nbsp;Example</h3></div></div><div></div></div><p>See <a href="#examples.jmx" title="11.1.21.&nbsp;JMX Management">Section&nbsp;11.1.21, &#8220;JMX Management&#8221;</a> for an example which shows how to use a remote
            connection to JMX and MBean proxies to manage HornetQ.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6432"></a>30.3.&nbsp;Using Management Via Core API</h2></div></div><div></div></div><p>The core management API in HornetQ is called by sending Core messages to a special
         address, the <span class="emphasis"><em>management address</em></span>.</p><p><span class="emphasis"><em>Management messages</em></span> are regular Core messages with well-known
         properties that the server needs to understand to interact with the management API:</p><div class="itemizedlist"><ul type="disc"><li><p>The name of the managed resource</p></li><li><p>The name of the management operation</p></li><li><p>The parameters of the management operation</p></li></ul></div><p>When such a management message is sent to the management address, HornetQ server will
         handle it, extract the information, invoke the operation on the managed resources and send
         a <span class="emphasis"><em>management reply</em></span> to the management message's reply-to address
         (specified by <tt class="literal">ClientMessageImpl.REPLYTO_HEADER_NAME</tt>). </p><p>A <tt class="literal">ClientConsumer</tt> can be used to consume the management reply and
         retrieve the result of the operation (if any) stored in the reply's body. For portability,
         results are returned as a <a href="http://json.org" target="_top">JSON</a> String rather than Java
         Serialization (the <tt class="literal">org.hornetq.api.core.management.ManagementHelper</tt> can
         be used to convert the JSON string to Java objects).</p><p>These steps can be simplified to make it easier to invoke management operations using
         Core messages:</p><div class="orderedlist"><ol type="1"><li><p>Create a <tt class="literal">ClientRequestor</tt> to send messages to the management
               address and receive replies</p></li><li><p>Create a <tt class="literal">ClientMessage</tt></p></li><li><p>Use the helper class <tt class="literal">org.hornetq.api.core.management.ManagementHelper</tt> to fill the message
               with the management properties</p></li><li><p>Send the message using the <tt class="literal">ClientRequestor</tt></p></li><li><p>Use the helper class <tt class="literal">org.hornetq.api.core.management.ManagementHelper</tt> to retrieve the
               operation result from the management reply</p></li></ol></div><p>For example, to find out the number of messages in the core queue <tt class="literal">exampleQueue</tt>:</p><pre class="programlisting">
   ClientSession session = ...
   ClientRequestor requestor = new ClientRequestor(session, "jms.queue.hornetq.management");
   ClientMessage message = session.createMessage(false);
   ManagementHelper.putAttribute(message, "core.queue.exampleQueue", "messageCount");
   ClientMessage reply = requestor.request(m);
   int count = (Integer) ManagementHelper.getResult(reply);
   System.out.println("There are " + count + " messages in exampleQueue");
      </pre><p>Management operation name and parameters must conform to the Java interfaces defined in
         the <tt class="literal">management</tt> packages.</p><p>Names of the resources are built using the helper class <tt class="literal">org.hornetq.api.core.management.ResourceNames</tt> and are straightforward
            (<tt class="literal">core.queue.exampleQueue</tt> for the Core Queue <tt class="literal">exampleQueue</tt>, <tt class="literal">jms.topic.exampleTopic</tt> for the JMS Topic
            <tt class="literal">exampleTopic</tt>, etc.).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="management.core.configuration"></a>30.3.1.&nbsp;Configuring Core Management</h3></div></div><div></div></div><p>The management address to send management messages is configured in <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">
   &lt;management-address&gt;jms.queue.hornetq.management&lt;/management-address&gt;
         </pre><p>By default, the address is <tt class="literal">jms.queue.hornetq.management</tt> (it is
            prepended by "jms.queue" so that JMS clients can also send management messages).</p><p>The management address requires a <span class="emphasis"><em>special</em></span> user permission
               <tt class="literal">manage</tt> to be able to receive and handle management messages. This
            is also configured in hornetq-configuration.xml:</p><pre class="programlisting">
   &lt;!-- users with the admin role will be allowed to manage --&gt; 
   &lt;!-- HornetQ using management messages        --&gt;
   &lt;security-setting match="jms.queue.hornetq.management"&gt;
      &lt;permission type="manage" roles="admin" /&gt;
   &lt;/security-setting&gt;
         </pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="management.jms"></a>30.4.&nbsp;Using Management Via JMS</h2></div></div><div></div></div><p>Using JMS messages to manage HornetQ is very similar to using core API.</p><p>An important difference is that JMS requires a JMS queue to send the messages to
         (instead of an address for the core API).</p><p>The <span class="emphasis"><em>management queue</em></span> is a special queue and needs to be
         instantiated directly by the client:</p><pre class="programlisting">
   Queue managementQueue = HornetQJMSClient.createQueue("hornetq.management");
      </pre><p>All the other steps are the same than for the Core API but they use JMS API
         instead:</p><div class="orderedlist"><ol type="1"><li><p>create a <tt class="literal">QueueRequestor</tt> to send messages to the management
               address and receive replies</p></li><li><p>create a <tt class="literal">Message</tt></p></li><li><p>use the helper class <tt class="literal">org.hornetq.api.jms.management.JMSManagementHelper</tt> to fill the message
               with the management properties</p></li><li><p>send the message using the <tt class="literal">QueueRequestor</tt></p></li><li><p>use the helper class <tt class="literal">org.hornetq.api.jms.management.JMSManagementHelper</tt> to retrieve the
               operation result from the management reply</p></li></ol></div><p>For example, to know the number of messages in the JMS queue <tt class="literal">exampleQueue</tt>:</p><pre class="programlisting">
   Queue managementQueue = HornetQJMSClient.createQueue("hornetq.management");   
   
   QueueSession session = ...      
   QueueRequestor requestor = new QueueRequestor(session, managementQueue);
   connection.start();
   Message message = session.createMessage();
   JMSManagementHelper.putAttribute(message, "jms.queue.exampleQueue", "messageCount");
   Message reply = requestor.request(message);
   int count = (Integer)JMSManagementHelper.getResult(reply);
   System.out.println("There are " + count + " messages in exampleQueue");
      </pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6610"></a>30.4.1.&nbsp;Configuring JMS Management</h3></div></div><div></div></div><p>Whether JMS or the core API is used for management, the configuration steps are the
            same (see <a href="#management.core.configuration" title="30.3.1.&nbsp;Configuring Core Management">Section&nbsp;30.3.1, &#8220;Configuring Core Management&#8221;</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6617"></a>30.4.2.&nbsp;Example</h3></div></div><div></div></div><p>See <a href="#examples.management" title="11.1.25.&nbsp;Management">Section&nbsp;11.1.25, &#8220;Management&#8221;</a> for an example which shows how to use JMS
            messages to manage HornetQ server.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="management.notifications"></a>30.5.&nbsp;Management Notifications</h2></div></div><div></div></div><p>HornetQ emits <span class="emphasis"><em>notifications</em></span> to inform listeners of potentially
         interesting events (creation of new resources, security violation, etc.).</p><p>These notifications can be received by 3 different ways:</p><div class="itemizedlist"><ul type="disc"><li><p>JMX notifications</p></li><li><p>Core messages</p></li><li><p>JMS messages</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6644"></a>30.5.1.&nbsp;JMX Notifications</h3></div></div><div></div></div><p>If JMX is enabled (see <a href="#management.jmx.configuration" title="30.2.1.&nbsp;Configuring JMX">Section&nbsp;30.2.1, &#8220;Configuring JMX&#8221;</a>), JMX
            notifications can be received by subscribing to 2 MBeans:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">org.hornetq:module=Core,type=Server</tt> for notifications on
                     <span class="emphasis"><em>Core</em></span> resources</p></li><li><p><tt class="literal">org.hornetq:module=JMS,type=Server</tt> for notifications on
                     <span class="emphasis"><em>JMS</em></span> resources</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6668"></a>30.5.2.&nbsp;Core Messages Notifications</h3></div></div><div></div></div><p>HornetQ defines a special <span class="emphasis"><em>management notification address</em></span>. Core
            queues can be bound to this address so that clients will receive management
            notifications as Core messages</p><p>A Core client which wants to receive management notifications must create a core
            queue bound to the management notification address. It can then receive the
            notifications from its queue.</p><p>Notifications messages are regular core messages with additional properties
            corresponding to the notification (its type, when it occurred, the resources which were
            concerned, etc.).</p><p>Since notifications are regular core messages, it is possible to use message
            selectors to filter out notifications and receives only a subset of all the
            notifications emitted by the server.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="management.notifications.core.configuration"></a>30.5.2.1.&nbsp;Configuring The Core Management Notification Address</h4></div></div><div></div></div><p>The management notification address to receive management notifications is
               configured in <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">
               &lt;management-notification-address&gt;hornetq.notifications&lt;/management-notification-address&gt;
            </pre><p>By default, the address is <tt class="literal">hornetq.notifications</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6697"></a>30.5.3.&nbsp;JMS Messages Notifications</h3></div></div><div></div></div><p>HornetQ's notifications can also be received using JMS messages.</p><p>It is similar to receiving notifications using Core API but an important difference
            is that JMS requires a JMS Destination to receive the messages (preferably a
            Topic).</p><p>To use a JMS Destination to receive management notifications, you must change the server's
            management notification address to start with <tt class="literal">jms.queue</tt> if it is a JMS Queue
            or <tt class="literal">jms.topic</tt> if it is a JMS Topic:</p><pre class="programlisting">
            &lt;!-- notifications will be consumed from "notificationsTopic" JMS Topic --&gt; 
            &lt;management-notification-address&gt;jms.topic.notificationsTopic&lt;/management-notification-address&gt;
         </pre><p>Once the notification topic is created, you can receive messages from it or set a
               <tt class="literal">MessageListener</tt>:</p><pre class="programlisting">
   Topic notificationsTopic = HornetQJMSClient.createTopic("notificationsTopic");

   Session session = ...
   MessageConsumer notificationConsumer = session.createConsumer(notificationsTopic);
      notificationConsumer.setMessageListener(new MessageListener()
      {
         public void onMessage(Message notif)
         {
            System.out.println("------------------------");
            System.out.println("Received notification:");
            try
            {
               Enumeration propertyNames = notif.getPropertyNames();
               while (propertyNames.hasMoreElements())
               {
                  String propertyName = (String)propertyNames.nextElement();
                  System.out.format("  %s: %s\n", propertyName, notif.getObjectProperty(propertyName));
               }
            }
            catch (JMSException e)
            {
            }
            System.out.println("------------------------");
         }            
      });            
         </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6721"></a>30.5.4.&nbsp;Example</h3></div></div><div></div></div><p>See <a href="#examples.management-notifications" title="11.1.26.&nbsp;Management Notification">Section&nbsp;11.1.26, &#8220;Management Notification&#8221;</a> for an example which shows
            how to use a JMS <tt class="literal">MessageListener</tt> to receive management notifications
            from HornetQ server.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="management.message-counters"></a>30.6.&nbsp;Message Counters</h2></div></div><div></div></div><p>Message counters can be used to obtain information on queues <span class="emphasis"><em>over
            time</em></span> as HornetQ keeps a history on queue metrics.</p><p>They can be used to show <span class="emphasis"><em>trends</em></span> on queues. For example, using the
         management API, it would be possible to query the number of messages in a queue at regular
         interval. However, this would not be enough to know if the queue is used: the number of
         messages can remain constant because nobody is sending or receiving messages from the queue
         or because there are as many messages sent to the queue than messages consumed from it. The
         number of messages in the queue remains the same in both cases but its use is widely
         different.</p><p>Message counters gives additional information about the queues:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">count</tt></p><p>The <span class="emphasis"><em>total</em></span> number of messages added to the queue since the
               server was started</p></li><li><p><tt class="literal">countDelta</tt></p><p>the number of messages added to the queue <span class="emphasis"><em>since the last message counter
                  update</em></span></p></li><li><p><tt class="literal">depth</tt></p><p>The <span class="emphasis"><em>current</em></span> number of messages in the queue</p></li><li><p><tt class="literal">depthDelta</tt></p><p>The <span class="emphasis"><em>overall</em></span> number of messages added/removed from the queue
                  <span class="emphasis"><em>since the last message counter update</em></span>. For example, if
                  <tt class="literal">depthDelta</tt> is equal to <tt class="literal">-10</tt> this means that
               overall 10 messages have been removed from the queue (e.g. 2 messages were added and
               12 were removed)</p></li><li><p><tt class="literal">lastAddTimestamp</tt></p><p>The timestamp of the last time a message was added to the queue</p></li><li><p><tt class="literal">udpateTimestamp</tt></p><p>The timestamp of the last message counter update</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="configuring.message.counters"></a>30.6.1.&nbsp;Configuring Message Counters</h3></div></div><div></div></div><p>By default, message counters are disabled as it might have a small negative effect on
            memory.</p><p>To enable message counters, you can set it to <tt class="literal">true</tt> in <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">
&lt;message-counter-enabled&gt;true&lt;/message-counter-enabled&gt;
         </pre><p>Message counters keeps a history of the queue metrics (10 days by default) and
            samples all the queues at regular interval (10 seconds by default). If message counters
            are enabled, these values should be configured to suit your messaging use case in
               <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">
&lt;!-- keep history for a week --&gt;
&lt;message-counter-max-day-history&gt;7&lt;/message-counter-max-day-history&gt;            
&lt;!-- sample the queues every minute (60000ms) --&gt;
&lt;message-counter-sample-period&gt;60000&lt;/message-counter-sample-period&gt;
         </pre><p>Message counters can be retrieved using the Management API. For example, to retrieve
            message counters on a JMS Queue using JMX:</p><pre class="programlisting">
// retrieve a connection to HornetQ's MBeanServer
MBeanServerConnection mbsc = ...
JMSQueueControlMBean queueControl = (JMSQueueControl)MBeanServerInvocationHandler.newProxyInstance(mbsc,
   on,
   JMSQueueControl.class,
   false);
// message counters are retrieved as a JSON String                                                                                                      
String counters = queueControl.listMessageCounter();
// use the MessageCounterInfo helper class to manipulate message counters more easily
MessageCounterInfo messageCounter = MessageCounterInfo.fromJSON(counters);         
System.out.format("%s message(s) in the queue (since last sample: %s)\n",
   counter.getDepth(),
   counter.getDepthDelta());
         </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6829"></a>30.6.2.&nbsp;Example</h3></div></div><div></div></div><p>See <a href="#examples.message-counters" title="11.1.27.&nbsp;Message Counter">Section&nbsp;11.1.27, &#8220;Message Counter&#8221;</a> for an example which shows how to use
            message counters to retrieve information on a JMS <tt class="literal">Queue</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6839"></a>30.7.&nbsp;Administering HornetQ Resources Using The JBoss AS Admin Console</h2></div></div><div></div></div><p>Its possible to create and configure HornetQ resources via the admin console within the JBoss Application Server.</p><p>The Admin Console will allow you to create destinations (JMS Topics and Queues) and JMS Connection Factories.</p><p>Once logged in to the admin console you will see a JMS Manager item in the left hand tree. All HornetQ resources
      will be configured via this. This will have a child items for JMS Queues, Topics and Connection Factories, clicking
         on each node will reveal which resources are currently available. The following sections explain how to create
         and configure each resource in turn.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6848"></a>30.7.1.&nbsp;JMS Queues</h3></div></div><div></div></div><p>To create a new JMS Queue click on the JMS Queues item to reveal the available queues. On the right hand
            panel you will see an add a new resource button, click on this and then choose the default(JMS Queue) template
         and click continue. The important things to fill in here are the name of the queue and the JNDI name of the
            queue. The JNDI name is what you will use to look up the queue in JNDI from your client. For most queues this
            will be the only info you will need to provide as sensible defaults are provided for the others. You will also
            see a security roles section near the bottom. If you do not provide any roles for this queue then the servers
         default security configuration will be used, after you have created the queue these will be shown in the configuration.
         All configuration values, except the name and JNDI name, can be changed via the configuration tab after clicking
            on the queue in the admin console. The following section explains these in more detail</p><p>After highlighting the configuration you will see the following screen</p><p>
            </p><div align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="500"><tr><td align="center"><img src="images/console1.png" align="middle" width="500"></td></tr></table></div><p>
        </p><p>The name and JNDI name cant be changed, if you want to change these recreate the queue with the appropriate
         settings. The rest of the configuration options, apart from security roles, relate to address settings for a particular
         address. The default address settings are picked up from the servers configuration, if you change any of these
         settings or create a queue via the console a new Address Settings enrty will be added. For a full explanation on
         Address Settings see <a href="#queue-attributes.address-settings" title="25.3.&nbsp;Configuring Queues Via Address Settings">Section&nbsp;25.3, &#8220;Configuring Queues Via Address Settings&#8221;</a></p><p>To delete a queue simply click on the delete button beside the queue name in the main JMS Queues screen.
         This will also delete any address settings or security settings previously created for the queues address</p><p>The last part of the configuration options are security roles. If non are provided on creation then the
            servers default security settings will be shown. If these are changed or updated then new securty settings are
         created for the address of this queue. For more information on securuty setting see <a href="#security" title="Chapter&nbsp;31.&nbsp;Security">Chapter&nbsp;31, <i>Security</i></a> </p><p>It is also possible via the metrics tab to view statistics for this queue. This will show statistics such
            as message count, consumer count etc.</p><p>Operations can be performed on a queue via the control tab. This will allow you to start and stop the queue,
         list,move,expire and delete messages from the queue and other useful operations. To invoke an operation click on
         the button for the operation you want, this will take you to a screen where you can parameters for the opertion can be set.
         Once set clicking the ok button will invoke the operation, results appear at the bottom of the screen.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6872"></a>30.7.2.&nbsp;JMS Topics</h3></div></div><div></div></div><p>Creating and configuring JMS Topics is almost identical to creating queues. The only difference is that the
         configuration will be applied to the queue representing a subscription.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6877"></a>30.7.3.&nbsp;JMS Connection Factories</h3></div></div><div></div></div><p>The format for creating connection factories is the same as for JMS Queues and topics apart from the configuration
         being different. For as list of all the connection factory settings see the configuration index </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="security"></a>Chapter&nbsp;31.&nbsp;Security</h2></div></div><div></div></div><p>This chapter describes how security works with HornetQ and how you can configure it. To
        disable security completely simply set the <tt class="literal">security-enabled</tt> property to
        false in the <tt class="literal">hornetq-configuration.xml</tt> file.</p><p>For performance reasons security is cached and invalidated every so long. To change this
        period set the property <tt class="literal">security-invalidation-interval</tt>, which is in
        milliseconds. The default is <tt class="literal">10000</tt> ms.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security.settings.roles"></a>31.1.&nbsp;Role based security for addresses</h2></div></div><div></div></div><p>HornetQ contains a flexible role-based security model for applying security to queues,
            based on their addresses.</p><p>As explained in <a href="#using-core" title="Chapter&nbsp;8.&nbsp;Using Core">Chapter&nbsp;8, <i>Using Core</i></a>, HornetQ core consists mainly of sets of
            queues bound to addresses. A message is sent to an address and the server looks up the
            set of queues that are bound to that address, the server then routes the message to
            those set of queues.</p><p>HornetQ allows sets of permissions to be defined against the queues based on their
            address. An exact match on the address can be used or a wildcard match can be used using
            the wildcard characters '<tt class="literal">#</tt>' and '<tt class="literal">*</tt>'.</p><p>Seven different permissions can be given to the set of queues which match the address.
            Those permissions are:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">createDurableQueue</tt>. This permission allows the user to
                    create a durable queue under matching addresses.</p></li><li><p><tt class="literal">deleteDurableQueue</tt>. This permission allows the user to
                    delete a durable queue under matching addresses.</p></li><li><p><tt class="literal">createNonDurableQueue</tt>. This permission allows the user to create
                    a non-durable queue under matching addresses.</p></li><li><p><tt class="literal">deleteNonDurableQueue</tt>. This permission allows the user to delete
                    a non-durable queue under matching addresses.</p></li><li><p><tt class="literal">send</tt>. This permission allows the user to send a message to
                    matching addresses.</p></li><li><p><tt class="literal">consume</tt>. This permission allows the user to consume a
                    message from a queue bound to matching addresses.</p></li><li><p><tt class="literal">manage</tt>. This permission allows the user to invoke
                    management operations by sending management messages to the management
                    address.</p></li></ul></div><p>For each permission, a list of roles who are granted that permission is specified. If
            the user has any of those roles, he/she will be granted that permission for that set of
            addresses.</p><p>Let's take a simple example, here's a security block from <tt class="literal">hornetq-configuration.xml</tt> or <tt class="literal">hornetq-queues.xml</tt>
            file:</p><pre class="programlisting">
&lt;security-setting match="globalqueues.europe.#"&gt;
    &lt;permission type="createDurableQueue" roles="admin"/&gt;
    &lt;permission type="deleteDurableQueue" roles="admin"/&gt;
    &lt;permission type="createNonDurableQueue" roles="admin, guest, europe-users"/&gt;
    &lt;permission type="deleteNonDurableQueue" roles="admin, guest, europe-users"/&gt;
    &lt;permission type="send" roles="admin, europe-users"/&gt;
    &lt;permission type="consume" roles="admin, europe-users"/&gt;
&lt;/security-setting&gt;            
        </pre><p>The '<tt class="literal">#</tt>' character signifies "any sequence of words". Words are
            delimited by the '<tt class="literal">.</tt>' character. For a full description of the
            wildcard syntax please see <a href="#wildcard-syntax" title="Chapter&nbsp;13.&nbsp;Understanding the HornetQ Wildcard Syntax">Chapter&nbsp;13, <i>Understanding the HornetQ Wildcard Syntax</i></a>. The above security block
            applies to any address that starts with the string "globalqueues.europe.":</p><p>Only users who have the <tt class="literal">admin</tt> role can create or delete durable
            queues bound to an address that starts with the string "globalqueues.europe."</p><p>Any users with the roles <tt class="literal">admin</tt>, <tt class="literal">guest</tt>, or
                <tt class="literal">europe-users</tt> can create or delete temporary queues bound to an
            address that starts with the string "globalqueues.europe."</p><p>Any users with the roles <tt class="literal">admin</tt> or <tt class="literal">europe-users</tt>
            can send messages to these addresses or consume messages from queues bound to an address
            that starts with the string "globalqueues.europe."</p><p>The mapping between a user and what roles they have is handled by the security
            manager. HornetQ ships with a user manager that reads user credentials from a file on
            disk, and can also plug into JAAS or JBoss Application Server security.</p><p>For more information on configuring the security manager, please see <a href="#change-security-manager" title="31.4.&nbsp;Changing the security manager">Section&nbsp;31.4, &#8220;Changing the security manager&#8221;</a>.</p><p>There can be zero or more <tt class="literal">security-setting</tt> elements in each xml
            file. Where more than one match applies to a set of addresses the <span class="emphasis"><em>more
                specific</em></span> match takes precedence.</p><p>Let's look at an example of that, here's another <tt class="literal">security-setting</tt>
            block:</p><pre class="programlisting">
&lt;security-setting match="globalqueues.europe.orders.#"&gt;
    &lt;permission type="send" roles="europe-users"/&gt;
    &lt;permission type="consume" roles="europe-users"/&gt;
&lt;/security-setting&gt;            
        </pre><p>In this <tt class="literal">security-setting</tt> block the match
            'globalqueues.europe.orders.#' is more specific than the previous match
            'globalqueues.europe.#'. So any addresses which match 'globalqueues.europe.orders.#'
            will take their security settings <span class="emphasis"><em>only</em></span> from the latter
            security-setting block.</p><p>Note that settings are not inherited from the former block. All the settings will be
            taken from the more specific matching block, so for the address
            'globalqueues.europe.orders.plastics' the only permissions that exist are <tt class="literal">send</tt> and <tt class="literal">consume</tt> for the role europe-users. The
            permissions <tt class="literal">createDurableQueue</tt>, <tt class="literal">deleteDurableQueue</tt>, <tt class="literal">createNonDurableQueue</tt>, <tt class="literal">deleteNonDurableQueue</tt> are not inherited from the other security-setting
            block.</p><p>By not inheriting permissions, it allows you to effectively deny permissions in more
            specific security-setting blocks by simply not specifying them. Otherwise it would not
            be possible to deny permissions in sub-groups of addresses.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7070"></a>31.2.&nbsp;Secure Sockets Layer (SSL) Transport</h2></div></div><div></div></div><p>When messaging clients are connected to servers, or servers are connected to other
            servers (e.g. via bridges) over an untrusted network then HornetQ allows that traffic to
            be encrypted using the Secure Sockets Layer (SSL) transport.</p><p>For more information on configuring the SSL transport, please see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7079"></a>31.3.&nbsp;Basic user credentials</h2></div></div><div></div></div><p>HornetQ ships with a security manager implementation that reads user credentials, i.e.
            user names, passwords and role information from an xml file on the classpath called
                <tt class="literal">hornetq-users.xml</tt>. This is the default security manager.</p><p>If you wish to use this security manager, then users, passwords and roles can easily
            be added into this file.</p><p>Let's take a look at an example file:</p><pre class="programlisting">
&lt;configuration xmlns="urn:hornetq" 
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:hornetq ../schemas/hornetq-users.xsd "&gt;
    
    &lt;defaultuser name="guest" password="guest"&gt;
        &lt;role name="guest"/&gt;
    &lt;/defaultuser&gt;
    
    &lt;user name="tim" password="marmite"&gt;
        &lt;role name="admin"/&gt;      
    &lt;/user&gt;
    
    &lt;user name="andy" password="doner_kebab"&gt;
        &lt;role name="admin"/&gt;
        &lt;role name="guest"/&gt;
    &lt;/user&gt;
    
    &lt;user name="jeff" password="camembert"&gt;
        &lt;role name="europe-users"/&gt;
        &lt;role name="guest"/&gt;
    &lt;/user&gt;
    
&lt;/configuration&gt;
        </pre><p>The first thing to note is the element <tt class="literal">defaultuser</tt>. This defines
            what user will be assumed when the client does not specify a username/password when
            creating a session. In this case they will be the user <tt class="literal">guest</tt> and have
            the role also called <tt class="literal">guest</tt>. Multiple roles can be specified for a
            default user.</p><p>We then have three more users, the user <tt class="literal">tim</tt> has the role <tt class="literal">admin</tt>. The user <tt class="literal">andy</tt> has the roles <tt class="literal">admin</tt> and <tt class="literal">guest</tt>, and the user <tt class="literal">jeff</tt>
            has the roles <tt class="literal">europe-users</tt> and <tt class="literal">guest</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="change-security-manager"></a>31.4.&nbsp;Changing the security manager</h2></div></div><div></div></div><p>If you do not want to use the default security manager then you can specify a
            different one by editing the file <tt class="literal">hornetq-beans.xml</tt> (or <tt class="literal">hornetq-jboss-beans.xml</tt> if you're running JBoss Application Server) and
            changing the class for the <tt class="literal">HornetQSecurityManager</tt> bean.</p><p>Let's take a look at a snippet from the default beans file:</p><pre class="programlisting">           
&lt;bean name="HornetQSecurityManager" 
      class="org.hornetq.spi.core.security.HornetQSecurityManagerImpl"&gt;
    &lt;start ignored="true"/&gt;
    &lt;stop ignored="true"/&gt;
&lt;/bean&gt;            
        </pre><p>The class <tt class="literal">org.hornetq.spi.core.security.HornetQSecurityManagerImpl</tt>
            is the default security manager that is used by the standalone server.</p><p>HornetQ ships with two other security manager implementations you can use
            off-the-shelf; one a JAAS security manager and another for integrating with JBoss
            Application Sever security, alternatively you could write your own implementation by
            implementing the <tt class="literal">org.hornetq.core.security.SecurityManager</tt> interface,
            and specifying the classname of your implementation in the file <tt class="literal">hornetq-beans.xml</tt> (or <tt class="literal">hornetq-jboss-beans.xml</tt> if
            you're running JBoss Application Server).</p><p>These two implementations are discussed in the next two sections.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7166"></a>31.5.&nbsp;JAAS Security Manager</h2></div></div><div></div></div><p>JAAS stands for 'Java Authentication and Authorization Service' and is a standard part
            of the Java platform. It provides a common API for security authentication and
            authorization, allowing you to plugin your pre-built implementations.</p><p>To configure the JAAS security manager to work with your pre-built JAAS infrastructure
            you need to specify the security manager as a <tt class="literal">JAASSecurityManager</tt> in
            the beans file. Here's an example:</p><pre class="programlisting">
&amp;lt;bean name="HornetQSecurityManager"
      class="org.hornetq.integration.jboss.security.JAASSecurityManager"&amp;gt;
    &amp;lt;start ignored="true"/&amp;gt;
    &amp;lt;stop ignored="true"/&amp;gt;

    &amp;lt;property name="ConfigurationName"&amp;gt;org.hornetq.jms.example.ExampleLoginModule&amp;lt;/property&amp;gt;
    &amp;lt;property name="Configuration"&amp;gt;
       &amp;lt;inject bean="ExampleConfiguration"/&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name="CallbackHandler"&amp;gt;
       &amp;lt;inject bean="ExampleCallbackHandler"/&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
        </pre><p>Note that you need to feed the JAAS security manager with three properties:</p><div class="itemizedlist"><ul type="disc"><li><p>ConfigurationName: the name of the <tt class="literal">LoginModule</tt>
                    implementation that JAAS must use</p></li><li><p>Configuration: the <tt class="literal">Configuration</tt> implementation used by
                    JAAS</p></li><li><p>CallbackHandler: the <tt class="literal">CallbackHandler</tt> implementation to use
                    if user interaction are required</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7199"></a>31.5.1.&nbsp;Example</h3></div></div><div></div></div><p>See <a href="#examples.jaas" title="11.1.19.&nbsp;JAAS">Section&nbsp;11.1.19, &#8220;JAAS&#8221;</a> for an example which shows how HornetQ can be
                configured to use JAAS.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7206"></a>31.6.&nbsp;JBoss AS Security Manager</h2></div></div><div></div></div><p>The JBoss AS security manager is used when running HornetQ inside the JBoss
            Application server. This allows tight integration with the JBoss Application Server's
            security model.</p><p>The class name of this security manager is <tt class="literal">org.hornetq.integration.jboss.security.JBossASSecurityManager</tt></p><p>Take a look at one of the default <tt class="literal">hornetq-jboss-beans.xml</tt> files for
            JBoss Application Server that are bundled in the distribution for an example of how this
            is configured.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7220"></a>31.6.1.&nbsp;Configuring Client Login</h3></div></div><div></div></div><p>JBoss can be configured to allow client login, basically this is when a JEE component such as a Servlet
             or EJB sets security credentials on the current security context  and these are used throughout the call.
             If you would like these credentials to be used by HornetQ when sending or consuming messages then
          set <tt class="literal">allowClientLogin</tt> to true. This will bypass HornetQ authentication and propgate the
          provided Security Context. If you would like HornetQ to authenticate using the propogated security then set the
          <tt class="literal">authoriseOnClientLogin</tt> to true also.</p><p>There is more info on using the JBoss client login module <a href="http://community.jboss.org/wiki/ClientLoginModule" target="_top">here</a> </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If messages are sent non blocking then there is a chance that these could arrive on the server after
          the calling thread has completed meaning that the security context has been cleared. If this is the case then messages
          will need to be sent blocking</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7239"></a>31.7.&nbsp;Changing the username/password for clustering</h2></div></div><div></div></div><p>In order for cluster connections to work correctly, each node in the cluster must make
            connections to the other nodes. The username/password they use for this should always be
            changed from the installation default to prevent a security risk.</p><p>Please see <a href="#management" title="Chapter&nbsp;30.&nbsp;Management">Chapter&nbsp;30, <i>Management</i></a> for instructions on how to do this.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appserver-integration"></a>Chapter&nbsp;32.&nbsp;Application Server Integration and Java EE</h2></div></div><div></div></div><p>HornetQ can be easily installed in JBoss Application Server 4 or later. For details on
        installing HornetQ in the JBoss Application Server please refer to quick-start guide.</p><p>Since HornetQ also provides a JCA adapter, it is also possible to integrate HornetQ
        as a JMS provider in other JEE compliant app servers. For instructions on how to integrate a
        remote JCA adaptor into another application sever, please consult the other application server's
        instructions.</p><p>A JCA Adapter basically controls the inflow of messages to Message-Driven Beans (MDBs) and the
        outflow of messages sent from other JEE components, e.g. EJBs and Servlets.</p><p>This section explains the basics behind configuring the different JEE components in the
        AS.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7276"></a>32.1.&nbsp;Configuring Message-Driven Beans</h2></div></div><div></div></div><p>The delivery of messages to an MDB using HornetQ is configured on the JCA Adapter via
            a configuration file <tt class="literal">ra.xml</tt> which can be found under the <tt class="literal">jms-ra.rar</tt> directory. By default this is configured to consume
            messages using an InVM connector from the instance of HornetQ running within the
            application server. The configuration properties are listed later in this chapter. </p><p>All MDBs however need to have the destination type and the destination configured.
            The following example shows how this can be done using annotations:</p><pre class="programlisting">@MessageDriven(name = "MDBExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue")
                     })
@ResourceAdapter("hornetq-ra.rar")
public class MDBExample implements MessageListener
{
   public void onMessage(Message message)...
}</pre><p>In this example you can see that the MDB will consume messages from a queue that is
            mapped into JNDI with the binding <tt class="literal">queue/testQueue</tt>. This queue must be
            preconfigured in the usual way using the HornetQ configuration files.</p><p>The <tt class="literal">ResourceAdapter</tt> annotation is used to specify which adaptor
            should be used. To use this you will need to import <tt class="literal">org.jboss.ejb3.annotation.ResourceAdapter</tt> for JBoss AS 5.X and later version which can be found in the
                <tt class="literal">jboss-ejb3-ext-api.jar</tt> which can be found in the JBoss
            repository. For JBoss AS 4.X, the annotation to use is <tt class="literal">org.jboss.annotation.ejb.ResourceAdaptor</tt>.</p><p>
             Alternatively you can add use a deployment descriptor and add something like
            the following to <tt class="literal">jboss.xml</tt></p><pre class="programlisting">&lt;message-driven&gt;
   &lt;ejb-name&gt;ExampleMDB&lt;/ejb-name&gt;
   &lt;resource-adapter-name&gt;hornetq-ra.rar&lt;/resource-adapter-name&gt;
&lt;/message-driven&gt;
</pre><p>You
            can also rename the hornetq-ra.rar directory to jms-ra.rar and neither the annotation or
            the extra descriptor information will be needed. If you do this you will need to edit
            the <tt class="literal">jms-ds.xml</tt> datasource file and change <tt class="literal">rar-name</tt>
            element.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>HornetQ is the default JMS provider for JBoss AS 6. Starting with this AS version, HornetQ resource
              adapter is named <tt class="literal">jms-ra.rar</tt> and you no longer need to annotate the MDB for the resource adapter name.</p></div><p>All the examples shipped with the HornetQ distribution use the annotation.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7331"></a>32.1.1.&nbsp;Using Container-Managed Transactions</h3></div></div><div></div></div><p>When an MDB is using Container-Managed Transactions (CMT), the delivery of the
                message is done within the scope of a JTA transaction. The commit or rollback of
                this transaction is controlled by the container itself. If the transaction is rolled
                back then the message delivery semantics will kick in (by default, it will try to
                redeliver the message up to 10 times before sending to a DLQ). Using annotations
                this would be configured as follows:</p><pre class="programlisting">@MessageDriven(name = "MDB_CMP_TxRequiredExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue")
                     })
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MDB_CMP_TxRequiredExample implements MessageListener
{
   public void onMessage(Message message)...
}</pre><p>The <tt class="literal">TransactionManagement</tt> annotation tells the container to manage the
            transaction. The <tt class="literal">TransactionAttribute</tt> annotation tells the container that a JTA
                transaction is required for this MDB. Note that the only other valid value for this
                is <tt class="literal">TransactionAttributeType.NOT_SUPPORTED</tt> which tells the
                container that this MDB does not support JTA transactions and one should not be
                created.</p><p>It is also possible to inform the container that it must rollback the transaction
                by calling <tt class="literal">setRollbackOnly</tt> on the <tt class="literal">MessageDrivenContext</tt>. The code for this would look something
                like:</p><pre class="programlisting">   @Resource
   MessageDrivenContextContext ctx;

   public void onMessage(Message message)
   {
      try
      {
         //something here fails
      }
      catch (Exception e)
      {
         ctx.setRollbackOnly();
      }
   }</pre><p>If you do not want the overhead of an XA transaction being created every time but
                you would still like the message delivered within a transaction (i.e. you are only
                using a JMS resource) then you can configure the MDB to use a local transaction.
                This would be configured as such:</p><pre class="programlisting">@MessageDriven(name = "MDB_CMP_TxLocalExample",
               activationConfig =
                     {
                           @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                           @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
                           @ActivationConfigProperty(propertyName = "useLocalTx", propertyValue = "true")
                     })
@TransactionManagement(value = TransactionManagementType.CONTAINER)
@TransactionAttribute(value = TransactionAttributeType.NOT_SUPPORTED)
@ResourceAdapter("hornetq-ra.rar")
public class MDB_CMP_TxLocalExample implements MessageListener
{
   public void onMessage(Message message)...
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7363"></a>32.1.2.&nbsp;Using Bean-Managed Transactions</h3></div></div><div></div></div><p>Message-driven beans can also be configured to use Bean-Managed Transactions
                (BMT). In this case a User Transaction is created. This would be configured as
                follows:</p><pre class="programlisting">@MessageDriven(name = "MDB_BMPExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
                        @ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Dups-ok-acknowledge")
                     })
@TransactionManagement(value= TransactionManagementType.BEAN)
@ResourceAdapter("hornetq-ra.rar")
public class MDB_BMPExample implements MessageListener
{
   public void onMessage(Message message)
}</pre><p>When using Bean-Managed Transactions the message delivery to the MDB will occur
                outside the scope of the user transaction and use the acknowledge mode specified by
                the user with the <tt class="literal">acknowledgeMode</tt> property. There are only 2
                acceptable values for this <tt class="literal">Auto-acknowledge</tt> and <tt class="literal">Dups-ok-acknowledge</tt>. Please note that because the message delivery is outside
                the scope of the transaction a failure within the MDB will not cause the message to
                be redelivered.</p><p>A user would control the lifecycle of the transaction something like the
                following:</p><pre class="programlisting">   @Resource
   MessageDrivenContext ctx;

   public void onMessage(Message message)
   {
      UserTransaction tx;
      try
      {
         TextMessage textMessage = (TextMessage)message;

         String text = textMessage.getText();

         UserTransaction tx = ctx.getUserTransaction();

         tx.begin();
         
         //do some stuff within the transaction
         
         tx.commit();

      }
      catch (Exception e)
      {
         tx.rollback();
      }
   }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7385"></a>32.1.3.&nbsp;Using Message Selectors with Message-Driven Beans</h3></div></div><div></div></div><p>It is also possible to use MDBs with message selectors. To do this simple define
                your message selector as follows:</p><pre class="programlisting">@MessageDriven(name = "MDBMessageSelectorExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
                        @ActivationConfigProperty(propertyName = "messageSelector", propertyValue = "color = 'RED'")
                     })
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MDBMessageSelectorExample implements MessageListener
{
   public void onMessage(Message message)....
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7392"></a>32.2.&nbsp;Sending Messages from within JEE components</h2></div></div><div></div></div><p>The JCA adapter can also be used for sending messages. The Connection Factory to use
            is configured by default in the <tt class="literal">jms-ds.xml</tt> file and is mapped to
                <tt class="literal">java:/JmsXA</tt>. Using this from within a JEE component will mean
            that the sending of the message will be done as part of the JTA transaction being used
            by the component.</p><p>This means that if the sending of the message fails the overall transaction would
            rollback and the message be re-sent. Heres an example of this from within an
            MDB:</p><pre class="programlisting">@MessageDriven(name = "MDBMessageSendTxExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue")
                     })
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MDBMessageSendTxExample implements MessageListener
{
   @Resource(mappedName = "java:/JmsXA")
   ConnectionFactory connectionFactory;

   @Resource(mappedName = "queue/replyQueue")
   Queue replyQueue;

   public void onMessage(Message message)
   {
      Connection conn = null;
      try
      {
         //Step 9. We know the client is sending a text message so we cast
         TextMessage textMessage = (TextMessage)message;

         //Step 10. get the text from the message.
         String text = textMessage.getText();

         System.out.println("message " + text);

         conn = connectionFactory.createConnection();

         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

         MessageProducer producer = sess.createProducer(replyQueue);

         producer.send(sess.createTextMessage("this is a reply"));

      }
      catch (Exception e)
      {
         e.printStackTrace();
      }
      finally
      {
         if(conn != null)
         {
            try
            {
               conn.close();
            }
            catch (JMSException e)
            { 
            }
         }
      }
   }
   }</pre><p>In JBoss Application Server you can use the JMS JCA adapter for sending messages from
            EJBs (including Session, Entity and Message-Driven Beans), Servlets (including jsps) and
            custom MBeans.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7409"></a>32.3.&nbsp;MDB and Consumer pool size</h2></div></div><div></div></div><p>Most application servers, including JBoss, allow you to configure how many MDB's there are in a pool. In
         Jboss this is configured via the <tt class="literal">MaxPoolSize</tt> parameter in the ejb3-interceptors-aop.xml file. Configuring
         this has no actual effect on how many sessions/consumers there actually are created. This is because the Resource
      Adaptor implementation knows nothing about the application servers MDB implementation. So even if you set the MDB
         pool size to 1, 15 sessions/consumers will be created (this is the default). If you want to limit how many
         sessions/consumers are created then you need to set the <tt class="literal">maxSession</tt> parameter either on the
      resource adapter itself or via an an Activation Config Property on the MDB itself</p><pre class="programlisting">@MessageDriven(name = "MDBMessageSendTxExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
                        @ActivationConfigProperty(propertyName = "maxSession", propertyValue = "1")
                     })
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MyMDB implements MessageListener
{ ....}
      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7422"></a>32.4.&nbsp;Configuring the JCA Adaptor</h2></div></div><div></div></div><p>The Java Connector Architecture (JCA) Adapter is what allows HornetQ to be integrated
            with JEE components such as MDBs and EJBs. It configures how components such as MDBs
            consume messages from the HornetQ server and also how components such as EJBs or
            Servlets can send messages.</p><p>The HornetQ JCA adapter is deployed via the <tt class="literal">jms-ra.rar</tt> archive. The
            configuration of the adapter is found in this archive under <tt class="literal">META-INF/ra.xml</tt>.</p><p>The configuration will look something like the following:</p><pre class="programlisting">&lt;resourceadapter&gt;
      &lt;resourceadapter-class&gt;org.hornetq.ra.HornetQResourceAdapter&lt;/resourceadapter-class&gt;
      &lt;config-property&gt;
         &lt;description&gt;The transport type&lt;/description&gt;
         &lt;config-property-name&gt;ConnectorClassName&lt;/config-property-name&gt;
         &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
         &lt;config-property-value&gt;org.hornetq.core.remoting.impl.invm.InVMConnectorFactory&lt;/config-property-value&gt;
      &lt;/config-property&gt;
      &lt;config-property&gt;
         &lt;description&gt;The transport configuration. These values must be in the form of key=val;key=val;&lt;/description&gt;
         &lt;config-property-name&gt;ConnectionParameters&lt;/config-property-name&gt;
         &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
         &lt;config-property-value&gt;server-id=0&lt;/config-property-value&gt;
      &lt;/config-property&gt;

      &lt;outbound-resourceadapter&gt;
         &lt;connection-definition&gt;
            &lt;managedconnectionfactory-class&gt;org.hornetq.ra.HornetQRAManagedConnection
            Factory&lt;/managedconnectionfactory-class&gt;

            &lt;config-property&gt;
               &lt;description&gt;The default session type&lt;/description&gt;
               &lt;config-property-name&gt;SessionDefaultType&lt;/config-property-name&gt;
               &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
               &lt;config-property-value&gt;javax.jms.Queue&lt;/config-property-value&gt;
            &lt;/config-property&gt;
            &lt;config-property&gt;
               &lt;description&gt;Try to obtain a lock within specified number of seconds; less
               than or equal to 0 disable this functionality&lt;/description&gt;
               &lt;config-property-name&gt;UseTryLock&lt;/config-property-name&gt;
               &lt;config-property-type&gt;java.lang.Integer&lt;/config-property-type&gt;
               &lt;config-property-value&gt;0&lt;/config-property-value&gt;
            &lt;/config-property&gt;

            &lt;connectionfactory-interface&gt;org.hornetq.ra.HornetQRAConnectionFactory
            &lt;/connectionfactory-interface&gt;
            &lt;connectionfactororg.hornetq.ra.HornetQConnectionFactoryImplonFactoryImpl
            &lt;/connectionfactory-impl-class&gt;
            &lt;connection-interface&gt;javax.jms.Session&lt;/connection-interface&gt;
            &lt;connection-impl-class&gt;org.hornetq.ra.HornetQRASession
            &lt;/connection-impl-class&gt;
         &lt;/connection-definition&gt;
         &lt;transaction-support&gt;XATransaction&lt;/transaction-support&gt;
         &lt;authentication-mechanism&gt;
            &lt;authentication-mechanism-type&gt;BasicPassword
            &lt;/authentication-mechanism-type&gt;
            &lt;credential-interface&gt;javax.resource.spi.security.PasswordCredential
            &lt;/credential-interface&gt;
         &lt;/authentication-mechanism&gt;
         &lt;reauthentication-support&gt;false&lt;/reauthentication-support&gt;
      &lt;/outbound-resourceadapter&gt;

      &lt;inbound-resourceadapter&gt;
         &lt;messageadapter&gt;
            &lt;messagelistener&gt;
               &lt;messagelistener-type&gt;javax.jms.MessageListener&lt;/messagelistener-type&gt;
               &lt;activationspec&gt;
                  &lt;activationspec-class&gt;org.hornetq.ra.inflow.HornetQActivationSpec
                  &lt;/activationspec-class&gt;
                  &lt;required-config-property&gt;
                      &lt;config-property-name&gt;destination&lt;/config-property-name&gt;
                  &lt;/required-config-property&gt;
               &lt;/activationspec&gt;
            &lt;/messagelistener&gt;
         &lt;/messageadapter&gt;
      &lt;/inbound-resourceadapter&gt;

   &lt;/resourceadapter&gt;</pre><p>There are three main parts to this configuration.</p><div class="orderedlist"><ol type="1"><li><p>A set of global properties for the adapter</p></li><li><p>The configuration for the outbound part of the adapter. This is used for
                    creating JMS resources within EE components. </p></li><li><p>The configuration of the inbound part of the adapter. This is used for
                    controlling the consumption of messages via MDBs. </p></li></ol></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7451"></a>32.4.1.&nbsp;Global Properties</h3></div></div><div></div></div><p>The first element you see is <tt class="literal">resourceadapter-class</tt> which should
                be left unchanged. This is the HornetQ resource adapter class.</p><p>After that there is a list of configuration properties. This will be where most of
                the configuration is done. The first two properties configure the transport used by the adapter
                and the rest configure the connection factory itself.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>All connection factory properties will use the defaults if they are not provided, except
                  for the <tt class="literal">reconnectAttempts</tt> which will default to -1. This
                  signifies that the connection should attempt to reconnect on connection
                  failure indefinitely. This is only used when the adapter is configured to
                  connect to a remote server as an InVM connector can never fail.
                </p></div><p>The following table explains what each property is for.</p><div class="table"><a name="d0e7469"></a><p class="title"><b>Table&nbsp;32.1.&nbsp;Global Configuration Properties</b></p><table summary="Global Configuration Properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property Name</th><th>Property Type</th><th>Property Description</th></tr></thead><tbody><tr><td>ConnectorClassName</td><td>String</td><td>The Connector class name (see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a> for more information)</td></tr><tr><td>ConnectionParameters</td><td>String</td><td>The transport configuration. These parameters must be in the form of
                                <tt class="literal">key1=val1;key2=val2;</tt> and will be specific to the connector used</td></tr><tr><td>useLocalTx</td><td>boolean</td><td>True will enable local transaction optimisation.</td></tr><tr><td>UserName</td><td>String</td><td>The user name to use when making a connection </td></tr><tr><td>Password</td><td>String</td><td>The password to use when making a connection</td></tr><tr><td>BackupConnectorClassName</td><td>String</td><td>The backup transport to use in case of failure of the live node</td></tr><tr><td>BackupConnectionParameters</td><td>String</td><td>The backup transport configuration parameters</td></tr><tr><td><a href="#configuration.discovery-group.group-address">DiscoveryAddress</a></td><td>String</td><td>The discovery group address to use to autodetect a server</td></tr><tr><td><a href="#configuration.discovery-group.group-port">DiscoveryPort</a></td><td>Integer</td><td>The port to use for discovery</td></tr><tr><td><a href="#configuration.discovery-group.refresh-timeout">DiscoveryRefreshTimeout</a></td><td>Long</td><td>The timeout, in milliseconds, to refresh.</td></tr><tr><td><a href="#configuration.connection-factory.discovery-initial-wait-timeout">
                                  DiscoveryInitialWaitTimeout
                               </a></td><td>Long</td><td>The initial time to wait for discovery.</td></tr><tr><td><a href="#configuration.connection-factory.connection-load-balancing-policy-class-name">
                                  ConnectionLoadBalancingPolicyClassName</a></td><td>String</td><td>The load balancing policy class to use.</td></tr><tr><td><a href="#configuration.connection-factory.connection-ttl">ConnectionTTL</a></td><td>Long</td><td>The time to live (in milliseconds) for the connection.</td></tr><tr><td><a href="#configuration.connection-factory.call-timeout">CallTimeout</a></td><td>Long</td><td>the call timeout (in milliseconds) for each packet sent.</td></tr><tr><td><a href="#configuration.connection-factory.dups-ok-batch-size">DupsOKBatchSize</a></td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using
                                 DUPS_OK_ACKNOWLEDGE mode</td></tr></tbody></table></div><p>Continued..</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><a href="#configuration.connection-factory.transaction-batch-size">TransactionBatchSize</a></td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using a
                                 transactional session</td></tr><tr><td><a href="#configuration.connection-factory.consumer-window-size">ConsumerWindowSize</a></td><td>Integer</td><td>the window size (in bytes) for consumer flow control</td></tr><tr><td><a href="#configuration.connection-factory.consumer-max-rate">ConsumerMaxRate</a></td><td>Integer</td><td>the fastest rate a consumer may consume messages per second</td></tr><tr><td><a href="#configuration.connection-factory.confirmation-window-size">ConfirmationWindowSize</a></td><td>Integer</td><td>the window size (in bytes) for reattachment confirmations</td></tr><tr><td><a href="#configuration.connection-factory.producer-max-rate">ProducerMaxRate</a></td><td>Integer</td><td>the maximum rate of messages per second that can be sent</td></tr><tr><td><a href="#configuration.connection-factory.min-large-message-size">MinLargeMessageSize</a></td><td>Integer</td><td>the size (in bytes) before a message is treated as large </td></tr><tr><td><a href="#configuration.connection-factory.block-on-acknowledge">BlockOnAcknowledge</a></td><td>Boolean</td><td>whether or not messages are acknowledged synchronously</td></tr><tr><td><a href="#configuration.connection-factory.block-on-non-durable-send">BlockOnNonDurableSend</a></td><td>Boolean</td><td>whether or not non-durable messages are sent synchronously</td></tr><tr><td><a href="#configuration.connection-factory.block-on-durable-send">BlockOnDurableSend</a></td><td>Boolean</td><td>whether or not durable messages are sent synchronously</td></tr><tr><td><a href="#configuration.connection-factory.auto-group">AutoGroup</a></td><td>Boolean</td><td>whether or not message grouping is automatically used</td></tr><tr><td><a href="#configuration.connection-factory.pre-acknowledge">PreAcknowledge</a></td><td>Boolean</td><td>whether messages are pre acknowledged by the server before
                                 sending</td></tr><tr><td><a href="#configuration.connection-factory.reconnect-attempts">ReconnectAttempts</a></td><td>Integer</td><td>maximum number of retry attempts, default for the resource adpater is -1 (infinite attempts)</td></tr><tr><td><a href="#configuration.connection-factory.retry-interval">RetryInterval</a></td><td>Long</td><td>the time (in milliseconds) to retry a connection after failing</td></tr><tr><td><a href="#configuration.connection-factory.retry-interval-multiplier">RetryIntervalMultiplier</a></td><td>Double</td><td>multiplier to apply to successive retry intervals</td></tr><tr><td><a href="#configuration.connection-factory.failover-on-server-shutdown">FailoverOnServerShutdown</a></td><td>Boolean</td><td>If true client will reconnect to another server if
                                available</td></tr><tr><td><a href="#configuration.connection-factory.client-id">ClientID</a></td><td>String</td><td>the pre-configured client ID for the connection factory</td></tr><tr><td><a href="#configuration.connection-factory.client-failure-check-period">ClientFailureCheckPeriod</a></td><td>Long</td><td>the period (in ms) after which the client will consider the
                                 connection failed after not receiving packets from the
                                 server</td></tr><tr><td><a href="#configuration.connection-factory.use-global-pools">UseGlobalPools</a></td><td>Boolean</td><td>whether or not to use a global thread pool for threads</td></tr><tr><td><a href="#configuration.connection-factory.scheduled-thread-pool-max-size">ScheduledThreadPoolMaxSize</a></td><td>Integer</td><td>the size of the <span class="emphasis"><em>scheduled thread</em></span> pool</td></tr><tr><td><a href="#configuration.connection-factory.thread-pool-max-size">ThreadPoolMaxSize</a></td><td>Integer</td><td>the size of the thread pool</td></tr><tr><td>SetupAttempts</td><td>Integer</td><td>Number of attempts to setup a JMS connection (default is 10, -1 means to attempt infinitely). It is possible
                               that the MDB is deployed before the JMS resources are available. In that case, the resource
                               adapter will try to setup several times until the resources are available. This applies only for inbound connections</td></tr><tr><td>SetupInterval</td><td>Long</td><td>Interval in milliseconds between consecutive attemps to setup a JMS connection (default is 2000m). This applies only for inbound connections</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7788"></a>32.4.2.&nbsp;Adapter Outbound Configuration</h3></div></div><div></div></div><p>The outbound configuration should remain unchanged as they define connection
                factories that are used by Java EE components. These Connection Factories can be
                defined inside a configuration file that matches the name <tt class="literal">*-ds.xml</tt>. You'll find a default <tt class="literal">jms-ds.xml</tt>
                configuration under the <tt class="literal">hornetq</tt> directory in the JBoss AS
                deployment. The connection factories defined in this file inherit their
                properties from the main <tt class="literal">ra.xml</tt> configuration but can also be
                overridden. The following example shows how to override them.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Please note that this configuration only applies when HornetQ resource adapter is installed in 
                JBoss Application Server. If you are using another JEE application
                server please refer to your application servers documentation for how to do
                this.</p></div><pre class="programlisting">&lt;tx-connection-factory&gt;
      &lt;jndi-name&gt;RemoteJmsXA&lt;/jndi-name&gt;
      &lt;xa-transaction/&gt;
      &lt;rar-name&gt;jms-ra.rar&lt;/rar-name&gt;
      &lt;connection-definition&gt;org.hornetq.ra.HornetQRAConnectionFactory
&lt;/connection-definition&gt;
      &lt;config-property name="SessionDefaultType" type="String"&gt;javax.jms.Topic
      &lt;/config-property&gt;
      &lt;config-property name="ConnectorClassName" type="String"&gt;
        org.hornetq.core.remoting.impl.netty.NettyConnectorFactory
      &lt;/config-property&gt;
      &lt;config-property name="ConnectionParameters" type="String"&gt;
          port=5445&lt;/config-property&gt;
      &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;
&lt;/tx-connection-factory&gt;</pre><p>In this example the connection factory will be bound to JNDI with the name
                    <tt class="literal">RemoteJmsXA</tt> and can be looked up in the usual way using JNDI
                or defined within the EJB or MDB as such:</p><pre class="programlisting">@Resource(mappedName="java:/RemoteJmsXA")
private ConnectionFactory connectionFactory;</pre><p>The <tt class="literal">config-property</tt> elements are what overrides those in the
                    <tt class="literal">ra.xml</tt> configuration file. Any of the elements pertaining to the
                connection factory can be overridden here.</p><p>The outbound configuration also defines additional properties in addition to the global configuration properties.</p><div class="table"><a name="d0e7827"></a><p class="title"><b>Table&nbsp;32.2.&nbsp;Outbound Configuration Properties</b></p><table summary="Outbound Configuration Properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property Name</th><th>Property Type</th><th>Property Description</th></tr></thead><tbody><tr><td>SessionDefaultType</td><td>String</td><td>the default session type</td></tr><tr><td>UseTryLock</td><td>Integer</td><td>try to obtain a lock within specified number of seconds. less
                            than or equal to 0 disable this functionality</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7857"></a>32.4.3.&nbsp;Adapter Inbound Configuration</h3></div></div><div></div></div><p>The inbound configuration should again remain unchanged. This controls what
                forwards messages onto MDBs. It is possible to override properties on the MDB by
                adding an activation configuration to the MDB itself. This could be used to
                configure the MDB to consume from a different server.</p><p>The inbound configuration also defines additional properties in addition to the global configuration properties.</p><div class="table"><a name="d0e7864"></a><p class="title"><b>Table&nbsp;32.3.&nbsp;Inbound Configuration Properties</b></p><table summary="Inbound Configuration Properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property Name</th><th>Property Type</th><th>Property Description</th></tr></thead><tbody><tr><td>Destination</td><td>String</td><td>JNDI name of the destination</td></tr><tr><td>DestinationType</td><td>String</td><td>type of the destination, either <tt class="literal">javax.jms.Queue</tt> or <tt class="literal">javax.jms.Topic</tt>
                                 (default is javax.jms.Queue)</td></tr><tr><td>AcknowledgeMode</td><td>String</td><td>The Acknowledgment mode, either <tt class="literal">Auto-acknowledge</tt> or <tt class="literal">Dups-ok-acknowledge</tt>
                                (default is Auto-acknowledge). <tt class="literal">AUTO_ACKNOWLEDGE</tt> and <tt class="literal">DUPS_OK_ACKNOWLEDGE</tt> are acceptable values.</td></tr><tr><td>MaxSession</td><td>Integer</td><td>Maximum number of session created by this inbound configuration (default is 15)</td></tr><tr><td>MessageSelector</td><td>String</td><td>the message selector of the consumer</td></tr><tr><td>SubscriptionDurability</td><td>String</td><td>Type of the subscription, either <tt class="literal">Durable</tt> or <tt class="literal">NonDurable</tt></td></tr><tr><td>SubscriptionName</td><td>String</td><td>Name of the subscription</td></tr><tr><td>TransactionTimeout</td><td>Long</td><td>The transaction timeout in milliseconds (default is 0, the transaction does not timeout)</td></tr><tr><td>UseJNDI</td><td>Boolean</td><td>Whether or not use JNDI to look up the destination (default is true)</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7966"></a>32.4.4.&nbsp;Configuring the adapter to use a standalone HornetQ Server</h3></div></div><div></div></div><p>Sometime you may want your messaging server on a different machine or separate from the application server.
          If this is the case you will only need the hornetq client libs installed. This section explains what config to create
          and what jar dependencies are needed.</p><div class="section" lang="en"><div class="titlepage"><div></div><div></div></div><p>There are two configuration files needed to do this, one for the incoming adapter used for MDB's
                and one for outgoing connections managed by the JCA managed connection pool used by outgoing JEE components
             wanting outgoing connections.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e7974"></a>32.4.4.1.1.&nbsp;Configuring the Incoming Adaptor</h5></div></div><div></div></div><p>Firstly you will need to create directory under the
                   <tt class="literal">deploy</tt>
                   directory ending in
                   <tt class="literal">.rar.
                      For this example we will name the directory <tt class="literal">hornetq-ra.rar</tt>. This detail is
                      important as
                      the name of directory is referred to by the MDB's and the outgoing configuration.
                   </tt>
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The jboss default for this is <tt class="literal">jms-ra.rar</tt>, If you don't want to have to
                      configure your
                      MDB's you can use this but you may need to remove the generic adaptor that uses this.
                   </p></div><p>Under the
                   <tt class="literal">hornetq-ra.rar</tt>
                   directory you will need to create a
                   <tt class="literal">META-INF</tt>
                   directory into which you should create an
                   <tt class="literal">ra.xml</tt>
                   configuration file. You can find a template
                   for the
                   <tt class="literal">ra.xml</tt>
                   under the config directory of the HornetQ distribution.
                </p><p>To configure MDB's to consume messages from a remote HornetQ server you need to edit the
                   <tt class="literal">ra.xml</tt>
                   file under
                   <tt class="literal">deploy/hornet-ra.rar/META-INF</tt>
                   and change the transport type to
                   use a netty connector (instead of the invm connector that is defined) and configure its transport
                   params.
                   Heres an example of what this would look like:
                </p><pre class="programlisting">
                   &lt;resourceadapter-class&gt;org.hornetq.ra.HornetQResourceAdapter&lt;/resourceadapter-class&gt;
                   &lt;config-property&gt;
                   &lt;description&gt;The transport type&lt;/description&gt;
                   &lt;config-property-name&gt;ConnectorClassName&lt;/config-property-name&gt;
                   &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
                   &lt;config-property-value&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/config-property-value&gt;
                   &lt;/config-property&gt;
                   &lt;config-property&gt;
                   &lt;description&gt;The transport configuration. These values must be in the form of key=val;key=val;&lt;/description&gt;
                   &lt;config-property-name&gt;ConnectionParameters&lt;/config-property-name&gt;
                   &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
                   &lt;config-property-value&gt;host=127.0.0.1;port=5446&lt;/config-property-value&gt;
                   &lt;/config-property&gt;
                </pre><p>This configures the resource adapter to connect to a server running on localhost listening on port
                   5446
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8020"></a>32.4.4.1.2.&nbsp;Configuring the outgoing adaptor</h5></div></div><div></div></div><p>You will also need to configure the outbound connection by creating a <tt class="literal">hornetq-ds.xml</tt>
                   and placing it under any directory that will be deployed under the <tt class="literal">deploy</tt> directory.
                   In a standard HornetQ jboss configuration this would be under <tt class="literal">horneq</tt> or <tt class="literal">hornetq.sar</tt>
                   but you can place it where ever you like. Actually as long as it ends in <tt class="literal">-ds.xml</tt> you can
                   call it anything you like. You can again find a template for this file under the config directory of the
                   HornetQ distribution but called <tt class="literal">jms-ds.xml</tt> which is the jboss default.
                </p><p>The following example shows a sample configuration</p><pre class="programlisting">
                   &lt;tx-connection-factory&gt;
                   &lt;jndi-name&gt;RemoteJmsXA&lt;/jndi-name&gt;
                   &lt;xa-transaction/&gt;
                   &lt;rar-name&gt;hornetq-ra.rar&lt;/rar-name&gt;
                   &lt;connection-definition&gt;org.hornetq.ra.HornetQRAConnectionFactory&lt;/connection-definition&gt;
                   &lt;config-property name="SessionDefaultType" type="java.lang.String"&gt;javax.jms.Topic&lt;/config-property&gt;
                   &lt;config-property name="ConnectorClassName" type="java.lang.String"&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/config-property&gt;
                   &lt;config-property name="ConnectionParameters" type="java.lang.String"&gt;host=127.0.0.1;port=5446&lt;/config-property&gt;
                   &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;
                   &lt;/tx-connection-factory&gt;
                </pre><p>Again you will see that this uses the netty connector type and will connect to the HornetQ server
                   running on localhost and listening on port 5446. JEE components can access this by using JNDI and looking
                   up the connection factory using JNDI using <tt class="literal">java:/RemoteJmsXA</tt>, you can see that this
                   is defined under the<tt class="literal">jndi-name</tt> attribute. You will also note that the outgoing connection
                   will be created by the resource adaptor configured under the directory <tt class="literal">hornetq-ra.rar</tt> as explained in the last section.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8058"></a>32.4.4.1.3.&nbsp;Jar dependencies</h5></div></div><div></div></div><p>This is a list of the HornetQ and third party jars needed</p><div class="table"><a name="d0e8063"></a><p class="title"><b>Table&nbsp;32.4.&nbsp;Jar Dependencies</b></p><table summary="Jar Dependencies" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Jar Name</th><th>Description</th><th>Location</th></tr></thead><tbody><tr><td>hornetq-ra.jar</td><td>The HornetQ resource adaptor classes</td><td>deploy/hornetq-ra.rar or equivelant</td></tr><tr><td>hornetq-core-client.jar</td><td>The HornetQ core client classes</td><td>either in the config lib, i.e. default/lib or the common lib dir, i.e. $JBOSS_HOME/common lib </td></tr><tr><td>hornetq-jms-client.jar</td><td>The HornetQ JMS classes</td><td>as above</td></tr><tr><td>netty.jar</td><td>The Netty transport classes</td><td>as above</td></tr></tbody></table></div></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8107"></a>32.5.&nbsp;High Availability JNDI (HA-JNDI)</h2></div></div><div></div></div><p>If you are using JNDI to look-up JMS queues, topics and connection factories from a
            cluster of servers, it is likely you will want to use HA-JNDI so that your JNDI look-ups
            will continue to work if one or more of the servers in the cluster fail.</p><p>HA-JNDI is a JBoss Application Server service which allows you to use JNDI from
            clients without them having to know the exact JNDI connection details of every server in
            the cluster. This service is only available if using a cluster of JBoss Application
            Server instances.</p><p>To use it use the following properties when connecting to JNDI.</p><pre class="programlisting">Hashtable&lt;String, String&gt; jndiParameters = new Hashtable&lt;String, String&gt;();
jndiParameters.put("java.naming.factory.initial", 
    "org.jnp.interfaces.NamingContextFactory");
jndiParameters.put("java.naming.factory.url.pkgs=", 
    "org.jboss.naming:org.jnp.interfaces");

initialContext = new InitialContext(jndiParameters);</pre><p>For more information on using HA-JNDI see the <a href="http://www.jboss.org/file-access/default/members/jbossas/freezone/docs/Clustering_Guide/5/html/clustering-jndi.html" target="_top">JBoss Application Server clustering documentation</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xa-recovery"></a>32.6.&nbsp;XA Recovery</h2></div></div><div></div></div><p><span class="emphasis"><em>XA recovery</em></span> deals with system or application failures to ensure
            that of a transaction are applied consistently to all resources affected by the
            transaction, even if any of the application processes or the machine hosting them crash
            or lose network connectivity. For more information on XA Recovery,please refer to <a href="http://www.jboss.org/community/wiki/JBossTransactions" target="_top">JBoss
                Transactions</a>.</p><p>When HornetQ is integrated with JBoss AS, it can take advantage of JBoss Transactions
            to provide recovery of messaging resources. If messages are involved in a XA
            transaction, in the event of a server crash, the recovery manager will ensure that the
            transactions are recovered and the messages will either be committed or rolled back
            (depending on the transaction outcome) when the server is restarted.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8134"></a>32.6.1.&nbsp;XA Recovery Configuration</h3></div></div><div></div></div><p>To enable HornetQ's XA Recovery, the Recovery Manager must be configured to connect
                to HornetQ to recover its resources. The following property must be added to the
                    <tt class="literal">jta</tt> section of <tt class="literal">conf/jbossts-properties.xml</tt>
                of JBoss AS profiles:</p><pre class="programlisting">
&lt;properties depends="arjuna" name="jta"&gt;
   ...
                     
   &lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HornetQ1"
                value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;[connection configuration]"/&gt;
&lt;/properties&gt;
            </pre><p>The <tt class="literal">[connection configuration]</tt> contains all the information
                required to connect to HornetQ node under the form <tt class="literal">[connector factory class
                    name],[user name], [password], [connector parameters]</tt>. </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">[connector factory class name]</tt> corresponds to the name
                        of the <tt class="literal">ConnectorFactory</tt> used to connect to HornetQ.
                        Values can be <tt class="literal">org.hornetq.core.remoting.impl.invm.InVMConnectorFactory</tt> or
                            <tt class="literal">org.hornetq.core.remoting.impl.netty.NettyConnectorFactory</tt></p></li><li><p><tt class="literal">[user name]</tt> is the user name to create a client
                        session. It is optional</p></li><li><p><tt class="literal">[password]</tt> is the password to create a client session.
                        It is mandatory only if the user name is specified</p></li><li><p><tt class="literal">[connector parameters]</tt> is a list of comma-separated
                        key=value pair which are passed to the connector factory (see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a> for a list of the transport
                        parameters).</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>HornetQ must have a valid acceptor which corresponds to the connector
                    specified in <tt class="literal">conf/jbossts-properties.xml</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8192"></a>32.6.1.1.&nbsp;Configuration Settings</h4></div></div><div></div></div><p>If HornetQ is configured with a default in-vm acceptor:</p><pre class="programlisting">
&lt;acceptor name="in-vm"&gt;
    &lt;factory-class&gt;org.hornetq.core.remoting.impl.invm.InVMAcceptorFactory&lt;/factory-class&gt;
&lt;/acceptor&gt;
                </pre><p>the corresponding configuration in <tt class="literal">conf/jbossts-properties.xml</tt> is:</p><pre class="programlisting">
&lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HORNETQ1"
   value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;org.hornetq.core.remoting.impl.invm.InVMConnectorFactory"/&gt;        			
                </pre><p>If it is now configured with a netty acceptor on a non-default port:</p><pre class="programlisting">
&lt;acceptor name="netty"&gt;
    &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
    &lt;param key="port" value="8888"/&gt;
&lt;/acceptor&gt;
                </pre><p>the corresponding configuration in <tt class="literal">conf/jbossts-properties.xml</tt> is:</p><pre class="programlisting">
&lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HORNETQ1"
       value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory, , , port=8888"/&gt;        			                    
                </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Note the additional commas to skip the user and password before connector
                        parameters</p></div><p>If the recovery must use <tt class="literal">admin, adminpass</tt>, the
                    configuration would have been:</p><pre class="programlisting">
                    &lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HORNETQ1"
                           value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory, admin, adminpass, port=8888"/&gt;        			                    
                </pre><p>Configuring HornetQ with an invm acceptor and configuring the Recovery Manager
                    with an invm connector is the recommended way to enable XA Recovery.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8229"></a>32.6.2.&nbsp;Example</h3></div></div><div></div></div><p>See <a href="#xa-recovery-example" title="11.3.9.&nbsp;XA Recovery">Section&nbsp;11.3.9, &#8220;XA Recovery&#8221;</a> which shows how to configure XA Recovery
                and recover messages after a server crash.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jms-bridge"></a>Chapter&nbsp;33.&nbsp;The JMS Bridge</h2></div></div><div></div></div><p>HornetQ includes a fully functional JMS message bridge.</p><p>The function of the bridge is to consume messages from a source queue or topic, and
            send them to a target queue or topic, typically on a different server.</p><p>The source and target servers do not have to be in the same cluster which makes
            bridging suitable for reliably sending messages from one cluster to another, for
            instance across a WAN, and where the connection may be unreliable.</p><p>A bridge can be deployed as a standalone application, with HornetQ standalone server or inside a JBoss AS
            instance. The source and the target can be located in the same virtual machine or another one.</p><p>The bridge can also be used to bridge messages from other non HornetQ JMS servers, as
            long as they are JMS 1.1 compliant.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Do not confuse a JMS bridge with a core
                    bridge. A JMS bridge can be used to bridge any two JMS 1.1 compliant JMS
                    providers and uses the JMS API. A core bridge (described in <a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">Chapter&nbsp;36, <i>Core Bridges</i></a>) is used to bridge any two HornetQ instances and
                    uses the core API. Always use a core bridge if you can in preference to a JMS
                    bridge. The core bridge will typically provide better performance than a JMS
                    bridge. Also the core bridge can provide <span class="emphasis"><em>once and only once</em></span>
                    delivery guarantees without using XA.</p></div><p>The bridge has built-in resilience to failure so if the source or target server
            connection is lost, e.g. due to network failure, the bridge will retry connecting to the
            source and/or target until they come back online. When it comes back online it will
            resume operation as normal.</p><p>The bridge can be configured with an optional JMS selector, so it will only consume
            messages matching that JMS selector</p><p>It can be configured to consume from a queue or a topic. When it consumes from a topic
            it can be configured to consume using a non durable or durable subscription</p><p>Typically, the bridge is deployed by the JBoss Micro Container via a beans configuration file.
            This would typically be deployed inside the JBoss Application Server and the following
            example shows an example of a beans file that bridges 2 destinations which are actually
            on the same server. </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;

       &lt;bean name="JMSBridge" class="org.hornetq.api.jms.bridge.impl.JMSBridgeImpl"&gt;
           &lt;!-- HornetQ must be started before the bridge --&gt;
           &lt;depends&gt;HornetQServer&lt;/depends&gt;
           &lt;constructor&gt;
               &lt;!-- Source ConnectionFactory Factory --&gt;
               &lt;parameter&gt;
                   &lt;inject bean="SourceCFF"/&gt;
               &lt;/parameter&gt;
               &lt;!-- Target ConnectionFactory Factory --&gt;
               &lt;parameter&gt;
                   &lt;inject bean="TargetCFF"/&gt;
               &lt;/parameter&gt;
               &lt;!-- Source DestinationFactory --&gt;
               &lt;parameter&gt;
                   &lt;inject bean="SourceDestinationFactory"/&gt;
               &lt;/parameter&gt;
               &lt;!-- Target DestinationFactory --&gt;
               &lt;parameter&gt;
                   &lt;inject bean="TargetDestinationFactory"/&gt;
               &lt;/parameter&gt;
               &lt;!-- Source User Name (no username here) --&gt;
               &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
               &lt;!-- Source Password (no password here)--&gt;
               &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
               &lt;!-- Target User Name (no username here)--&gt;
               &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
               &lt;!-- Target Password (no password here)--&gt;
               &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
               &lt;!-- Selector --&gt;
               &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
               &lt;!-- Failure Retry Interval (in ms) --&gt;
               &lt;parameter&gt;5000&lt;/parameter&gt;
               &lt;!-- Max Retries --&gt;
               &lt;parameter&gt;10&lt;/parameter&gt;
               &lt;!-- Quality Of Service --&gt;
               &lt;parameter&gt;ONCE_AND_ONLY_ONCE&lt;/parameter&gt;
               &lt;!-- Max Batch Size --&gt;
               &lt;parameter&gt;1&lt;/parameter&gt;
               &lt;!-- Max Batch Time (-1 means infinite) --&gt;
               &lt;parameter&gt;-1&lt;/parameter&gt;
               &lt;!-- Subscription name (no subscription name here)--&gt;
               &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
               &lt;!-- Client ID  (no client ID here)--&gt;
               &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
               &lt;!-- Add MessageID In Header --&gt;
               &lt;parameter&gt;true&lt;/parameter&gt;
               &lt;!-- register the JMS Bridge in the AS MBeanServer --&gt;
               &lt;parameter&gt;
                   &lt;inject bean="MBeanServer"/&gt;
               &lt;/parameter&gt;
               &lt;parameter&gt;org.hornetq:service=JMSBridge&lt;/parameter&gt;
             &lt;/constructor&gt;
           &lt;property name="transactionManager"&gt;
               &lt;inject bean="RealTransactionManager"/&gt;
           &lt;/property&gt;
       &lt;/bean&gt;

       &lt;!-- SourceCFF describes the ConnectionFactory used to connect to the 
            source destination --&gt;
       &lt;bean name="SourceCFF" 
            class="org.hornetq.api.jms.bridge.impl.JNDIConnectionFactoryFactory"&gt;
           &lt;constructor&gt;
               &lt;parameter&gt;
                   &lt;inject bean="JNDI" /&gt;
               &lt;/parameter&gt;
               &lt;parameter&gt;/ConnectionFactory&lt;/parameter&gt;
           &lt;/constructor&gt;  
       &lt;/bean&gt;

       &lt;!-- TargetCFF describes the ConnectionFactory used to connect to the 
        target destination --&gt;
       &lt;bean name="TargetCFF" 
            class="org.hornetq.api.jms.bridge.impl.JNDIConnectionFactoryFactory"&gt;
           &lt;constructor&gt;
               &lt;parameter&gt;
                   &lt;inject bean="JNDI" /&gt;
               &lt;/parameter&gt;
               &lt;parameter&gt;/ConnectionFactory&lt;/parameter&gt;
           &lt;/constructor&gt;  
       &lt;/bean&gt;

       &lt;!-- SourceDestinationFactory describes the Destination used as the source --&gt;
       &lt;bean name="SourceDestinationFactory" 
            class="org.hornetq.api.jms.bridge.impl.JNDIDestinationFactory"&gt;
           &lt;constructor&gt;
               &lt;parameter&gt;
                   &lt;inject bean="JNDI" /&gt;
               &lt;/parameter&gt;
               &lt;parameter&gt;/queue/source&lt;/parameter&gt;
           &lt;/constructor&gt;  
       &lt;/bean&gt;

       &lt;!-- TargetDestinationFactory describes the Destination used as the target --&gt;
       &lt;bean name="TargetDestinationFactory" 
            class="org.hornetq.api.jms.bridge.impl.JNDIDestinationFactory"&gt;
           &lt;constructor&gt;
               &lt;parameter&gt;
                   &lt;inject bean="JNDI" /&gt;
               &lt;/parameter&gt;
               &lt;parameter&gt;/queue/target&lt;/parameter&gt;
           &lt;/constructor&gt;  
       &lt;/bean&gt;
       
       &lt;!-- JNDI is a Hashtable containing the JNDI properties required --&gt;
       &lt;!-- to connect to the sources and targets JMS resrouces         --&gt;       
      &lt;bean name="JNDI" class="java.util.Hashtable"&gt;
         &lt;constructor class="java.util.Map"&gt;
            &lt;map class="java.util.Hashtable" keyClass="String"
                                             valueClass="String"&gt;
               &lt;entry&gt;
                  &lt;key&gt;java.naming.factory.initial&lt;/key&gt;
                  &lt;value&gt;org.jnp.interfaces.NamingContextFactory&lt;/value&gt;
               &lt;/entry&gt;
               &lt;entry&gt;
                  &lt;key&gt;java.naming.provider.url&lt;/key&gt;
                  &lt;value&gt;jnp://localhost:1099&lt;/value&gt;
               &lt;/entry&gt;
               &lt;entry&gt;
                  &lt;key&gt;java.naming.factory.url.pkgs&lt;/key&gt;
                  &lt;value&gt;org.jboss.naming:org.jnp.interfaces"&lt;/value&gt;
               &lt;/entry&gt;
               &lt;entry&gt;
                  &lt;key&gt;jnp.timeout&lt;/key&gt;
                  &lt;value&gt;5000&lt;/value&gt;
               &lt;/entry&gt;
               &lt;entry&gt;
                  &lt;key&gt;jnp.sotimeout&lt;/key&gt;
                  &lt;value&gt;5000&lt;/value&gt;
               &lt;/entry&gt;
            &lt;/map&gt;
         &lt;/constructor&gt;
      &lt;/bean&gt;

      &lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
         &lt;constructor factoryClass="org.jboss.mx.util.MBeanServerLocator"
                      factoryMethod="locateJBoss"/&gt;
      &lt;/bean&gt;
&lt;/deployment&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8284"></a>33.1.&nbsp;JMS Bridge Parameters</h2></div></div><div></div></div><p>The main bean deployed is the <tt class="literal">JMSBridge</tt> bean. The bean is
                configurable by the parameters passed to its constructor.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>To let a parameter be unspecified (for example, if the authentication is
                    anonymous or no message selector is provided), use <tt class="literal">&lt;null
                        /&gt;</tt> for the unspecified parameter value.</p></div><div class="itemizedlist"><ul type="disc"><li><p>Source Connection Factory Factory</p><p>This injects the <tt class="literal">SourceCFF</tt> bean (also defined in the
                        beans file). This bean is used to create the <span class="emphasis"><em>source</em></span>
                        <tt class="literal">ConnectionFactory</tt>
                    </p></li><li><p>Target Connection Factory Factory</p><p>This injects the <tt class="literal">TargetCFF</tt> bean (also defined in the
                        beans file). This bean is used to create the <span class="emphasis"><em>target</em></span>
                        <tt class="literal">ConnectionFactory</tt>
                    </p></li><li><p>Source Destination Factory Factory</p><p>This injects the <tt class="literal">SourceDestinationFactory</tt> bean (also
                        defined in the beans file). This bean is used to create the
                            <span class="emphasis"><em>source</em></span>
                        <tt class="literal">Destination</tt>
                    </p></li><li><p>Target Destination Factory Factory</p><p>This injects the <tt class="literal">TargetDestinationFactory</tt> bean (also
                        defined in the beans file). This bean is used to create the
                            <span class="emphasis"><em>target</em></span>
                        <tt class="literal">Destination</tt>
                    </p></li><li><p>Source User Name</p><p>this parameter is the username for creating the
                            <span class="emphasis"><em>source</em></span> connection</p></li><li><p>Source Password</p><p>this parameter is the parameter for creating the
                            <span class="emphasis"><em>source</em></span> connection</p></li><li><p>Target User Name</p><p>this parameter is the username for creating the
                            <span class="emphasis"><em>target</em></span> connection</p></li><li><p>Target Password</p><p>this parameter is the password for creating the
                            <span class="emphasis"><em>target</em></span> connection</p></li><li><p>Selector</p><p>This represents a JMS selector expression used for consuming messages from
                        the source destination. Only messages that match the selector expression
                        will be bridged from the source to the target destination</p><p>The selector expression must follow the <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/jms/Message.html" target="_top">JMS
                            selector syntax</a></p></li><li><p>Failure Retry Interval</p><p>This represents the amount of time in ms to wait between trying to
                        recreate connections to the source or target servers when the bridge has
                        detected they have failed</p></li><li><p>Max Retries</p><p>This represents the number of times to attempt to recreate connections to
                        the source or target servers when the bridge has detected they have failed.
                        The bridge will give up after trying this number of times. <tt class="literal">-1</tt> represents 'try forever'</p></li><li><p>Quality Of Service</p><p>This parameter represents the desired quality of service mode</p><p>Possible values are:</p><div class="itemizedlist"><ul type="circle"><li><p><tt class="literal">AT_MOST_ONCE</tt></p></li><li><p><tt class="literal">DUPLICATES_OK</tt></p></li><li><p><tt class="literal">ONCE_AND_ONLY_ONCE</tt></p></li></ul></div><p>See <a href="#quality-of-service" title="33.4.&nbsp;Quality Of Service">Section&nbsp;33.4, &#8220;Quality Of Service&#8221;</a> for a explanation of these
                        modes.</p></li><li><p>Max Batch Size</p><p>This represents the maximum number of messages to consume from the source
                        destination before sending them in a batch to the target destination. Its
                        value must <tt class="literal">&gt;= 1</tt>
                    </p></li><li><p>Max Batch Time</p><p>This represents the maximum number of milliseconds to wait before sending
                        a batch to target, even if the number of messages consumed has not reached
                            <tt class="literal">MaxBatchSize</tt>. Its value must be <tt class="literal">-1</tt>
                        to represent 'wait forever', or <tt class="literal">&gt;= 1</tt> to specify an actual
                        time </p></li><li><p>Subscription Name</p><p>If the source destination represents a topic, and you want to consume from
                        the topic using a durable subscription then this parameter represents the
                        durable subscription name</p></li><li><p>Client ID</p><p>If the source destination represents a topic, and you want to consume from
                        the topic using a durable subscription then this attribute represents the
                        the JMS client ID to use when creating/looking up the durable
                        subscription</p></li><li><p>Add MessageID In Header</p><p>If <tt class="literal">true</tt>, then the original message's message ID will be
                        appended in the message sent to the destination in the header <tt class="literal">HORNETQ_BRIDGE_MSG_ID_LIST</tt>. If the message is bridged more
                        than once, each message ID will be appended. This enables a distributed
                        request-response pattern to be used</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>when you receive the message you can send back a response using the
                            correlation id of the first message id, so when the original sender gets
                            it back it will be able to correlate it. </p></div></li><li><p>MBean Server</p><p>To manage the JMS Bridge using JMX, set the MBeanServer where the JMS Bridge MBean
                      must be registered (e.g. the JVM Platform MBeanServer or JBoss AS MBeanServer)</p></li><li><p>ObjectName</p><p>If you set the MBeanServer, you also need to set the ObjectName used to register
                      the JMS Bridge MBean (must be unique)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8489"></a>33.2.&nbsp;Source and Target Connection Factories</h2></div></div><div></div></div><p>The source and target connection factory factories are used to create the
                connection factory used to create the connection for the source or target
                server.</p><p>The configuration example above uses the default implementation provided by
                HornetQ that looks up the connection factory using JNDI. For other Application
                Servers or JMS providers a new implementation may have to be provided. This can
                easily be done by implementing the interface <tt class="literal">org.hornetq.jms.bridge.ConnectionFactoryFactory</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8499"></a>33.3.&nbsp;Source and Target Destination Factories</h2></div></div><div></div></div><p>Again, similarly, these are used to create or lookup up the destinations.</p><p>In the configuration example above, we have used the default provided by HornetQ
                that looks up the destination using JNDI.</p><p>A new implementation can be provided by implementing <tt class="literal">org.hornetq.jms.bridge.DestinationFactory</tt> interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quality-of-service"></a>33.4.&nbsp;Quality Of Service</h2></div></div><div></div></div><p>The quality of service modes used by the bridge are described here in more
                detail.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8516"></a>33.4.1.&nbsp;AT_MOST_ONCE</h3></div></div><div></div></div><p>With this QoS mode messages will reach the destination from the source at most
                    once. The messages are consumed from the source and acknowledged before sending
                    to the destination. Therefore there is a possibility that if failure occurs
                    between removing them from the source and them arriving at the destination they
                    could be lost. Hence delivery will occur at most once.</p><p>This mode is available for both durable and non-durable messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8523"></a>33.4.2.&nbsp;DUPLICATES_OK</h3></div></div><div></div></div><p>With this QoS mode, the messages are consumed from the source and then
                    acknowledged after they have been successfully sent to the destination.
                    Therefore there is a possibility that if failure occurs after sending to the
                    destination but before acknowledging them, they could be sent again when the
                    system recovers. I.e. the destination might receive duplicates after a
                    failure.</p><p>This mode is available for both durable and non-durable messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8530"></a>33.4.3.&nbsp;ONCE_AND_ONLY_ONCE</h3></div></div><div></div></div><p>This QoS mode ensures messages will reach the destination from the source once
                    and only once. (Sometimes this mode is known as "exactly once"). If both the
                    source and the destination are on the same HornetQ server instance then this can
                    be achieved by sending and acknowledging the messages in the same local
                    transaction. If the source and destination are on different servers this is
                    achieved by enlisting the sending and consuming sessions in a JTA transaction.
                    The JTA transaction is controlled by JBoss Transactions JTA * implementation
                    which is a fully recovering transaction manager, thus providing a very high
                    degree of durability. If JTA is required then both supplied connection factories
                    need to be XAConnectionFactory implementations. This is likely to be the slowest
                    mode since it requires extra persistence for the transaction logging.</p><p>This mode is only available for durable messages.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For a specific application it may possible to provide once and only once
                        semantics without using the ONCE_AND_ONLY_ONCE QoS level. This can be done
                        by using the DUPLICATES_OK mode and then checking for duplicates at the
                        destination and discarding them. Some JMS servers provide automatic
                        duplicate message detection functionality, or this may be possible to
                        implement on the application level by maintaining a cache of received
                        message ids on disk and comparing received messages to them. The cache would
                        only be valid for a certain period of time so this approach is not as
                        watertight as using ONCE_AND_ONLY_ONCE but may be a good choice depending on
                        your specific application.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8540"></a>33.4.4.&nbsp;Time outs and the JMS bridge</h3></div></div><div></div></div><p>There is a possibility that the target or source server will not be available at some point in time.
              If this occurs then the bridge will try <tt class="literal">Max Retries</tt> to reconnect every
              <tt class="literal">Failure Retry Interval</tt> milliseconds as specified in the JMS Bridge definition.</p><p>However since a third party JNDI is used, in this case the JBoss naming server, it is possible for the
              JNDI lookup to hang if the network were to disappear during the JNDI lookup. To stop this occuring the JNDI
              definition can be configured to time out if this occurs. To do this set the <tt class="literal">jnp.timeout</tt>
               and the <tt class="literal">jnp.sotimeout</tt> on the Initial Context definition. The first sets the connection
              timeout for the initial connection and the second the read timeout for the socket.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Once the initial JNDI connection has succeeded all calls are made using RMI. If you want to control
                    the timeouts for the RMI connections then this can be done via system properties. JBoss uses Sun's RMI
                 and the properties can be found <a href="http://java.sun.com/j2se/1.5.0/docs/guide/rmi/sunrmiproperties.html" target="_top">here</a>.
                 The default connection timeout is 10 seconds and the default read timeout is 18 seconds.</p></div><p>If you implement your own factories for looking up JMS resources then you will have to bear in mind timeout issues.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8567"></a>33.4.5.&nbsp;Examples</h3></div></div><div></div></div><p>Please see <a href="#examples.javaee.jms-bridge" title="11.3.5.&nbsp;JMS Bridge">Section&nbsp;11.3.5, &#8220;JMS Bridge&#8221;</a> which shows how to configure
                    and use a JMS Bridge with JBoss AS to send messages to the source destination and consume them
                    from the target destination.</p><p>Please see <a href="#examples.jms.jms-bridge" title="11.1.20.&nbsp;JMS Bridge">Section&nbsp;11.1.20, &#8220;JMS Bridge&#8221;</a> which shows how to configure
                    and use a JMS Bridge between two standalone HornetQ servers.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="client-reconnection"></a>Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment</h2></div></div><div></div></div><p>HornetQ clients can be configured to automatically reconnect or re-attach to the server in
        the event that a failure is detected in the connection between the client and the server. </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8600"></a>34.1.&nbsp;100% Transparent session re-attachment</h2></div></div><div></div></div><p>If the failure was due to some transient failure such as a temporary network failure,
            and the target server was not restarted, then the sessions will still be existent on the
            server, asssuming the client hasn't been disconnected for more than connection-ttl <a href="#connection-ttl" title="Chapter&nbsp;17.&nbsp;Detecting Dead Connections">Chapter&nbsp;17, <i>Detecting Dead Connections</i></a>.</p><p>In this scenario, HornetQ will automatically re-attach the client sessions to the
            server sessions when the connection reconnects. This is done 100% transparently and the
            client can continue exactly as if nothing had happened.</p><p>The way this works is as follows:</p><p>As HornetQ clients send commands to their servers they store each sent command in an
            in-memory buffer. In the case that connection failure occurs and the client subsequently
            reattaches to the same server, as part of the reattachment protocol the server informs
            the client during reattachment with the id of the last command it successfully received
            from that client.</p><p>If the client has sent more commands than were received before failover it can replay
            any sent commands from its buffer so that the client and server can reconcile their
            states.</p><p>The size of this buffer is configured by the <tt class="literal">ConfirmationWindowSize</tt>
            parameter, when the server has received <tt class="literal">ConfirmationWindowSize</tt> bytes
            of commands and processed them it will send back a command confirmation to the client,
            and the client can then free up space in the buffer.</p><p>If you are using JMS and you're using the JMS service on the server to load your JMS
            connection factory instances into JNDI then this parameter can be configured in <tt class="literal">hornetq-jms.xml</tt> using the element <tt class="literal">confirmation-window-size</tt> a. If you're using JMS but not using JNDI then
            you can set these values directly on the <tt class="literal">HornetQConnectionFactory</tt>
            instance using the appropriate setter method.</p><p>If you're using core you can set these values directly on the <tt class="literal">ClientSessionFactory</tt> instance using the appropriate setter method.</p><p>The window is specified in bytes.</p><p>Setting this parameter to <tt class="literal">-1</tt> disables any buffering and prevents
            any re-attachment from occurring, forcing reconnect instead. The default value for this
            parameter is <tt class="literal">-1</tt>. (Which means by default no auto re-attachment will occur)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8649"></a>34.2.&nbsp;Session reconnection</h2></div></div><div></div></div><p>Alternatively, the server might have actually been restarted after crashing or being
            stopped. In this case any sessions will no longer be existent on the server and it won't
            be possible to 100% transparently re-attach to them.</p><p>In this case, HornetQ will automatically reconnect the connection and <span class="italic">recreate</span> any sessions and consumers on the server
            corresponding to the sessions and consumers on the client. This process is exactly the
            same as what happens during failover onto a backup server.</p><p>Client reconnection is also used internally by components such as core bridges to
            allow them to reconnect to their target servers.</p><p>Please see the section on failover <a href="#ha.automatic.failover" title="39.2.1.&nbsp;Automatic Client Failover">Section&nbsp;39.2.1, &#8220;Automatic Client Failover&#8221;</a> to get a
            full understanding of how transacted and non-transacted sessions are reconnected during
            failover/reconnect and what you need to do to maintain <span class="italic">once and
                only once </span>delivery guarantees.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8668"></a>34.3.&nbsp;Configuring reconnection/reattachment attributes</h2></div></div><div></div></div><p>Client reconnection is configured using the following parameters:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">retry-interval</tt>. This optional parameter determines the
                    period in milliseconds between subsequent reconnection attempts, if the
                    connection to the target server has failed. The default value is <tt class="literal">2000</tt> milliseconds.</p></li><li><p><tt class="literal">retry-interval-multiplier</tt>. This optional parameter
                    determines determines a multiplier to apply to the time since the last retry to
                    compute the time to the next retry.</p><p>This allows you to implement an <span class="emphasis"><em>exponential backoff</em></span>
                    between retry attempts.</p><p>Let's take an example:</p><p>If we set <tt class="literal">retry-interval</tt> to <tt class="literal">1000</tt> ms and
                    we set <tt class="literal">retry-interval-multiplier</tt> to <tt class="literal">2.0</tt>,
                    then, if the first reconnect attempt fails, we will wait <tt class="literal">1000</tt>
                    ms then <tt class="literal">2000</tt> ms then <tt class="literal">4000</tt> ms between
                    subsequent reconnection attempts.</p><p>The default value is <tt class="literal">1.0</tt> meaning each reconnect attempt is
                    spaced at equal intervals.</p></li><li><p><tt class="literal">max-retry-interval</tt>. This optional parameter determines the
                    maximum retry interval that will be used. When setting <tt class="literal">retry-interval-multiplier</tt> it would otherwise be possible that
                    subsequent retries exponentially increase to ridiculously large values. By
                    setting this parameter you can set an upper limit on that value. The default
                    value is <tt class="literal">2000</tt> milliseconds.</p></li><li><p><tt class="literal">reconnect-attempts</tt>. This optional parameter determines the
                    total number of reconnect attempts to make before giving up and shutting down. A
                    value of <tt class="literal">-1</tt> signifies an unlimited number of attempts. The
                    default value is <tt class="literal">0</tt>.</p></li></ul></div><p>If you're using JMS, and you're using the JMS Service on the server to load your JMS
            connection factory instances directly into JNDI, then you can specify these parameters
            in the xml configuration in <tt class="literal">hornetq-jms.xml</tt>, for example:</p><pre class="programlisting">
&lt;connection-factory name="ConnectionFactory"&gt;
&lt;connectors&gt;
   &lt;connector-ref connector-name="netty"/&gt;
&lt;/connectors&gt;
&lt;entries&gt;
   &lt;entry name="ConnectionFactory"/&gt;
   &lt;entry name="XAConnectionFactory"/&gt;
&lt;/entries&gt;
&lt;retry-interval&gt;1000&lt;/retry-interval&gt;
&lt;retry-interval-multiplier&gt;1.5&lt;/retry-interval-multiplier&gt;
&lt;max-retry-interval&gt;60000&lt;/max-retry-interval&gt;
&lt;reconnect-attempts&gt;1000&lt;/reconnect-attempts&gt;
&lt;/connection-factory&gt;          
    </pre><p>If you're using JMS, but instantiating your JMS connection factory directly, you can
            specify the parameters using the appropriate setter methods on the <tt class="literal">HornetQConnectionFactory</tt> immediately after creating it.</p><p>If you're using the core API and instantiating the <tt class="literal">ClientSessionFactory</tt> instance directly you can also specify the
            parameters using the appropriate setter methods on the <tt class="literal">ClientSessionFactory</tt> immediately after creating it.</p><p>If your client does manage to reconnect but the session is no longer available on the
            server, for instance if the server has been restarted or it has timed out, then the
            client won't be able to re-attach, and any <tt class="literal">ExceptionListener</tt> or
                <tt class="literal">FailureListener</tt> instances registered on the connection or session
            will be called.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="client-reconnection.exceptionlistener"></a>34.4.&nbsp;ExceptionListeners and SessionFailureListeners</h2></div></div><div></div></div><p>Please note, that when a client reconnects or re-attaches, any registered JMS <tt class="literal">ExceptionListener</tt> or core API <tt class="literal">SessionFailureListener</tt>
            will be called.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="diverts"></a>Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows</h2></div></div><div></div></div><p>HornetQ allows you to configure objects called <span class="emphasis"><em>diverts</em></span> with
        some simple server configuration.</p><p>Diverts allow you to transparently divert messages routed to one address to some other
        address, without making any changes to any client application logic.</p><p>Diverts can be <span class="emphasis"><em>exclusive</em></span>, meaning that the message is diverted
        to the new address, and does not go to the old address at all, or they can be
            <span class="emphasis"><em>non-exclusive</em></span> which means the message continues to go the old
        address, and a <span class="emphasis"><em>copy</em></span> of it is also sent to the new address.
        Non-exclusive diverts can therefore be used for <span class="emphasis"><em>splitting</em></span> message
        flows, e.g. there may be a requirement to monitor every order sent to an order queue.</p><p>Diverts can also be configured to have an optional message filter. If specified then only
        messages that match the filter will be diverted.</p><p>Diverts can also be configured to apply a <tt class="literal">Transformer</tt>. If specified,
        all diverted messages will have the opportunity of being transformed by the <tt class="literal">Transformer</tt>.</p><p>A divert will only divert a message to an address on the <span class="emphasis"><em>same server</em></span>,
        however, if you want to divert to an address on a different server, a common pattern would
        be to divert to a local store-and-forward queue, then set up a bridge which consumes from
        that queue and forwards to an address on a different server.</p><p>Diverts are therefore a very sophisticated concept, which when combined with bridges can
        be used to create interesting and complex routings. The set of diverts on a server can be
        thought of as a type of routing table for messages. Combining diverts with bridges allows
        you to create a distributed network of reliable routing connections between multiple
        geographically distributed servers, creating your global messaging mesh.</p><p>Diverts are defined as xml in the <tt class="literal">hornetq-configuration.xml</tt> file. There can
        be zero or more diverts in the file.</p><p>Please see <a href="#divert-example" title="11.1.13.&nbsp;Divert">Section&nbsp;11.1.13, &#8220;Divert&#8221;</a> for a full working
        example showing you how to configure and use diverts.</p><p>Let's take a look at some divert examples:</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8852"></a>35.1.&nbsp;Exclusive Divert</h2></div></div><div></div></div><p>Let's take a look at an exclusive divert. An exclusive divert diverts all matching
            messages that are routed to the old address to the new address. Matching messages do not
            get routed to the old address.</p><p>Here's some example xml configuration for an exclusive divert, it's taken from the
            divert example:</p><pre class="programlisting">
&lt;divert name="prices-divert"&gt;                  
    &lt;address&gt;jms.topic.priceUpdates&lt;/address&gt;
    &lt;forwarding-address&gt;jms.queue.priceForwarding&lt;/forwarding-address&gt;    
    &lt;filter string="office='New York'"/&gt;
    &lt;transformer-class-name&gt;
        org.hornetq.jms.example.AddForwardingTimeTransformer
    &lt;/transformer-class-name&gt;     
    &lt;exclusive&gt;true&lt;/exclusive&gt;
&lt;/divert&gt;                        
        </pre><p>We define a divert called '<tt class="literal">prices-divert</tt>' that will divert any
            messages sent to the address '<tt class="literal">jms.topic.priceUpdates</tt>' (this
            corresponds to any messages sent to a JMS Topic called '<tt class="literal">priceUpdates</tt>') to another local address '<tt class="literal">jms.queue.priceForwarding</tt>' (this corresponds to a local JMS queue called
                '<tt class="literal">priceForwarding</tt>'</p><p>We also specify a message filter string so only messages with the message property
                <tt class="literal">office</tt> with value <tt class="literal">New York</tt> will get diverted,
            all other messages will continue to be routed to the normal address. The filter string
            is optional, if not specified then all messages will be considered matched.</p><p>In this example a transformer class is specified. Again this is optional, and if
            specified the transformer will be executed for each matching message. This allows you to
            change the messages body or properties before it is diverted. In this example the
            transformer simply adds a header that records the time the divert happened.</p><p>This example is actually diverting messages to a local store and forward queue, which
            is configured with a bridge which forwards the message to an address on another HornetQ
            server. Please see the example for more details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8890"></a>35.2.&nbsp;Non-exclusive Divert</h2></div></div><div></div></div><p>Now we'll take a look at a non-exclusive divert. Non exclusive diverts are the same as
            exclusive diverts, but they only forward a <span class="emphasis"><em>copy</em></span> of the message to
            the new address. The original message continues to the old address</p><p>You can therefore think of non-exclusive diverts as <span class="emphasis"><em>splitting</em></span> a
            message flow.</p><p>Non exclusive diverts can be configured in the same way as exclusive diverts with an
            optional filter and transformer, here's an example non-exclusive divert, again from the
            divert example:</p><pre class="programlisting">
&lt;divert name="order-divert"&gt;                 
    &lt;address&gt;jms.queue.orders&lt;/address&gt;
    &lt;forwarding-address&gt;jms.topic.spyTopic&lt;/forwarding-address&gt;         
    &lt;exclusive&gt;false&lt;/exclusive&gt;
&lt;/divert&gt;                       
        </pre><p>The above divert example takes a copy of every message sent to the address '<tt class="literal">jms.queue.orders</tt>' (Which corresponds to a JMS Queue called '<tt class="literal">orders</tt>') and sends it to a local address called '<tt class="literal">jms.topic.SpyTopic</tt>' (which corresponds to a JMS Topic called '<tt class="literal">SpyTopic</tt>').</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="core-bridges"></a>Chapter&nbsp;36.&nbsp;Core Bridges</h2></div></div><div></div></div><p>The function of a bridge is to consume messages from a source queue, and forward them to a
        target address, typically on a different HornetQ server.</p><p>The source and target servers do not have to be in the same cluster which makes bridging
        suitable for reliably sending messages from one cluster to another, for instance across a
        WAN, or internet and where the connection may be unreliable.</p><p>The bridge has built in resilience to failure so if the target server connection is lost,
        e.g. due to network failure, the bridge will retry connecting to the target until it comes
        back online. When it comes back online it will resume operation as normal.</p><p>In summary, bridges are a way to reliably connect two separate HornetQ servers together.
        With a core bridge both source and target servers must be HornetQ servers.</p><p>Bridges can be configured to provide <span class="emphasis"><em>once and only once</em></span> delivery
        guarantees even in the event of the failure of the source or the target server. They do this
        by using duplicate detection (described in <a href="#duplicate-detection" title="Chapter&nbsp;37.&nbsp;Duplicate Message Detection">Chapter&nbsp;37, <i>Duplicate Message Detection</i></a>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Although they have similar function, don't confuse core bridges with JMS
            bridges!</p><p>Core bridges are for linking a HornetQ node with another HornetQ node and do not use
            the JMS API. A JMS Bridge is used for linking any two JMS 1.1 compliant JMS providers.
            So, a JMS Bridge could be used for bridging to or from different JMS compliant messaging
            system. It's always preferable to use a core bridge if you can. Core bridges use
            duplicate detection to provide <span class="emphasis"><em>once and only once</em></span> guarantees. To
            provide the same guarantee using a JMS bridge you would have to use XA which has a
            higher overhead and is more complex to configure.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8964"></a>36.1.&nbsp;Configuring Bridges</h2></div></div><div></div></div><p>Bridges are configured in <tt class="literal">hornetq-configuration.xml</tt>. Let's kick off
            with an example (this is actually from the bridge example):</p><pre class="programlisting">
&lt;bridge name="my-bridge"&gt;
    &lt;queue-name&gt;jms.queue.sausage-factory&lt;/queue-name&gt;
    &lt;forwarding-address&gt;jms.queue.mincing-machine&lt;/forwarding-address&gt;
    &lt;filter-string="name='aardvark'"/&gt;
    &lt;transformer-class-name&gt;
        org.hornetq.jms.example.HatColourChangeTransformer
    &lt;/transformer-class-name&gt;
    &lt;retry-interval&gt;1000&lt;/retry-interval&gt;
    &lt;retry-interval-multiplier&gt;1.0&lt;/retry-interval-multiplier&gt;
    &lt;reconnect-attempts&gt;-1&lt;/reconnect-attempts&gt;
    &lt;failover-on-server-shutdown&gt;false&lt;/failover-on-server-shutdown&gt;
    &lt;use-duplicate-detection&gt;true&lt;/use-duplicate-detection&gt;
    &lt;confirmation-window-size&gt;10000000&lt;/confirmation-window-size&gt;
    &lt;connector-ref connector-name="remote-connector" 
        backup-connector-name="backup-remote-connector"/&gt;     
    &lt;user&gt;foouser&lt;/user&gt;
    &lt;password&gt;foopassword&lt;/password&gt;
&lt;/bridge&gt;                        
        </pre><p>In the above example we have shown all the parameters its possible to configure for a
            bridge. In practice you might use many of the defaults so it won't be necessary to
            specify them all explicitly.</p><p>Let's take a look at all the parameters in turn:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">name</tt> attribute. All bridges must have a unique name in the
                    server.</p></li><li><p><tt class="literal">queue-name</tt>. This is the unique name of the local queue that
                    the bridge consumes from, it's a mandatory parameter.</p><p>The queue must already exist by the time the bridge is instantiated at
                    start-up.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you're using JMS then normally the JMS configuration <tt class="literal">hornetq-jms.xml</tt> is loaded after the core configuration file
                            <tt class="literal">hornetq-configuration.xml</tt> is loaded. If your bridge
                        is consuming from a JMS queue then you'll need to make sure the JMS queue is
                        also deployed as a core queue in the core configuration. Take a look at the
                        bridge example for an example of how this is done.</p></div></li><li><p><tt class="literal">forwarding-address</tt>. This is the address on the target
                    server that the message will be forwarded to. If a forwarding address is not
                    specified, then the original address of the message will be retained.</p></li><li><p><tt class="literal">filter-string</tt>. An optional filter string can be supplied.
                    If specified then only messages which match the filter expression specified in
                    the filter string will be forwarded. The filter string follows the HornetQ
                    filter expression syntax described in <a href="#filter-expressions" title="Chapter&nbsp;14.&nbsp;Filter Expressions">Chapter&nbsp;14, <i>Filter Expressions</i></a>.</p></li><li><p><tt class="literal">transformer-class-name</tt>. An optional transformer-class-name
                    can be specified. This is the name of a user-defined class which implements the
                        <tt class="literal">org.hornetq.core.server.cluster.Transformer</tt>
                    interface.</p><p>If this is specified then the transformer's <tt class="literal">transform()</tt>
                    method will be invoked with the message before it is forwarded. This gives you
                    the opportunity to transform the message's header or body before forwarding
                    it.</p></li><li><p><tt class="literal">retry-interval</tt>. This optional parameter determines the
                    period in milliseconds between subsequent reconnection attempts, if the
                    connection to the target server has failed. The default value is <tt class="literal">2000</tt>milliseconds.</p></li><li><p><tt class="literal">retry-interval-multiplier</tt>. This optional parameter
                    determines determines a multiplier to apply to the time since the last retry to
                    compute the time to the next retry.</p><p>This allows you to implement an <span class="emphasis"><em>exponential backoff</em></span>
                    between retry attempts.</p><p>Let's take an example:</p><p>If we set <tt class="literal">retry-interval</tt>to <tt class="literal">1000</tt> ms and
                    we set <tt class="literal">retry-interval-multiplier</tt> to <tt class="literal">2.0</tt>,
                    then, if the first reconnect attempt fails, we will wait <tt class="literal">1000</tt>
                    ms then <tt class="literal">2000</tt> ms then <tt class="literal">4000</tt> ms between
                    subsequent reconnection attempts.</p><p>The default value is <tt class="literal">1.0</tt> meaning each reconnect attempt is
                    spaced at equal intervals.</p></li><li><p><tt class="literal">reconnect-attempts</tt>. This optional parameter determines the
                    total number of reconnect attempts the bridge will make before giving up and
                    shutting down. A value of <tt class="literal">-1</tt> signifies an unlimited number of
                    attempts. The default value is <tt class="literal">-1</tt>.</p></li><li><p><tt class="literal">failover-on-server-shutdown</tt>. This optional parameter
                    determines whether the bridge will attempt to failover onto a backup server (if
                    specified) when the target server is cleanly shutdown rather than
                    crashed.</p><p>The bridge connector can specify both a live and a backup server, if it
                    specifies a backup server and this parameter is set to <tt class="literal">true</tt>
                    then if the target server is <span class="emphasis"><em>cleanly</em></span> shutdown the bridge
                    connection will attempt to failover onto its backup. If the bridge connector has
                    no backup server configured then this parameter has no effect. </p><p>Sometimes you want a bridge configured with a live and a backup target server,
                    but you don't want to failover to the backup if the live server is simply taken
                    down temporarily for maintenance, this is when this parameter comes in
                    handy.</p><p>The default value for this parameter is <tt class="literal">false</tt>.</p></li><li><p><tt class="literal">use-duplicate-detection</tt>. This optional parameter determines
                    whether the bridge will automatically insert a duplicate id property into each
                    message that it forwards.</p><p>Doing so, allows the target server to perform duplicate detection on messages
                    it receives from the source server. If the connection fails or server crashes,
                    then, when the bridge resumes it will resend unacknowledged messages. This might
                    result in duplicate messages being sent to the target server. By enabling
                    duplicate detection allows these duplicates to be screened out and
                    ignored.</p><p>This allows the bridge to provide a <span class="emphasis"><em>once and only once</em></span>
                    delivery guarantee without using heavyweight methods such as XA (see <a href="#duplicate-detection" title="Chapter&nbsp;37.&nbsp;Duplicate Message Detection">Chapter&nbsp;37, <i>Duplicate Message Detection</i></a> for more information).</p><p>The default value for this parameter is <tt class="literal">true</tt>.</p></li><li><p><tt class="literal">confirmation-window-size</tt>. This optional parameter
                    determines the <tt class="literal">confirmation-window-size</tt> to use for the
                    connection used to forward messages to the target node. This attribute is
                    described in section <a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">Chapter&nbsp;34, <i>Client Reconnection and Session Reattachment</i></a></p><p>
                    </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>When using the bridge to forward messages from a queue which has a
                        max-size-bytes set it's important that confirmation-window-size is less than
                        or equal to <tt class="literal">max-size-bytes</tt> to prevent the flow of
                        messages from ceasing. </div><p>
                </p></li><li><p><tt class="literal">connector-ref</tt>. This mandatory parameter determines which
                        <span class="emphasis"><em>connector</em></span> pair the bridge will use to actually make the
                    connection to the target server.</p><p>A <span class="emphasis"><em>connector</em></span> encapsulates knowledge of what transport to
                    use (TCP, SSL, HTTP etc) as well as the server connection parameters (host, port
                    etc). For more information about what connectors are and how to configure them,
                    please see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a>.</p><p>The <tt class="literal">connector-ref</tt> element can be configured with two
                    attributes:</p><div class="itemizedlist"><ul type="circle"><li><p><tt class="literal">connector-name</tt>. This references the name of a
                            connector defined in the core configuration file <tt class="literal">hornetq-configuration.xml</tt>. The bridge will use this
                            connector to make its connection to the target server. This attribute is
                            mandatory.</p></li><li><p><tt class="literal">backup-connector-name</tt>. This optional parameter also
                            references the name of a connector defined in the core configuration
                            file <tt class="literal">hornetq-configuration.xml</tt>. It represents the
                            connector that the bridge will fail-over onto if it detects the live
                            server connection has failed. If this is specified and <tt class="literal">failover-on-server-shutdown</tt> is set to <tt class="literal">true</tt> then it will also attempt failover onto this
                            connector if the live target server is cleanly shut-down.</p></li></ul></div></li><li><p><tt class="literal">user</tt>. This optional parameter determines the user name to
                    use when creating the bridge connection to the remote server. If it is not
                    specified the default cluster user specified by <tt class="literal">cluster-user</tt>
                    in <tt class="literal">hornetq-configuration.xml</tt> will be used. </p></li><li><p><tt class="literal">password</tt>. This optional parameter determines the password
                    to use when creating the bridge connection to the remote server. If it is not
                    specified the default cluster password specified by <tt class="literal">cluster-password</tt> in <tt class="literal">hornetq-configuration.xml</tt>
                    will be used. </p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="duplicate-detection"></a>Chapter&nbsp;37.&nbsp;Duplicate Message Detection</h2></div></div><div></div></div><p>HornetQ includes powerful automatic duplicate message detection, filtering out
        duplicate messages without you having to code your own fiddly duplicate detection logic at
        the application level. This chapter will explain what duplicate detection is, how HornetQ
        uses it and how and where to configure it.</p><p>When sending messages from a client to a server, or indeed from a server to another
        server, if the target server or connection fails sometime after sending the message, but
        before the sender receives a response that the send (or commit) was processed successfully
        then the sender cannot know for sure if the message was sent successfully to the
        address.</p><p>If the target server or connection failed after the send was received and processed but
        before the response was sent back then the message will have been sent to the address
        successfully, but if the target server or connection failed before the send was received and
        finished processing then it will not have been sent to the address successfully. From the
        senders point of view it's not possible to distinguish these two cases.</p><p>When the server recovers this leaves the client in a difficult situation. It knows the
        target server failed, but it does not know if the last message reached its destination ok.
        If it decides to resend the last message, then that could result in a duplicate message
        being sent to the address. If each message was an order or a trade then this could result in
        the order being fulfilled twice or the trade being double booked. This is clearly not a
        desirable situation.</p><p>Sending the message(s) in a transaction does not help out either. If the server or
        connection fails while the transaction commit is being processed it is also indeterminate
        whether the transaction was successfully committed or not!</p><p>To solve these issues HornetQ provides automatic duplicate messages detection for
        messages sent to addresses.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9237"></a>37.1.&nbsp;Using Duplicate Detection for Message Sending</h2></div></div><div></div></div><p>Enabling duplicate message detection for sent messages is simple: you just need to set
            a special property on the message to a unique value. You can create the value however
            you like, as long as it is unique. When the target server receives the message it will
            check if that property is set, if it is, then it will check in its in memory cache if it
            has already received a message with that value of the header. If it has received a
            message with the same value before then it will ignore the message.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Using duplicate detection to move messages between nodes can give you the same
                    <span class="emphasis"><em>once and only once</em></span> delivery guarantees as if you were using
                an XA transaction to consume messages from source and send them to the target, but
                with less overhead and much easier configuration than using XA.</p></div><p>If you're sending messages in a transaction then you don't have to set the property
            for <span class="emphasis"><em>every</em></span> message you send in that transaction, you only need to
            set it once in the transaction. If the server detects a duplicate message for any
            message in the transaction, then it will ignore the entire transaction.</p><p>The name of the property that you set is given by the value of <tt class="literal">org.hornetq.api.core.HDR_DUPLICATE_DETECTION_ID</tt>, which
            is <tt class="literal">_HQ_DUPL_ID</tt></p><p>The value of the property can be of type <tt class="literal">byte[]</tt> or <tt class="literal">SimpleString</tt> if you're using the core API. If you're using JMS it must be
            a <tt class="literal">String</tt>, and its value should be unique. An easy way of generating
            a unique id is by generating a UUID.</p><p>Here's an example of setting the property using the core API:</p><pre class="programlisting">
...     

ClientMessage message = session.createMessage(true);

SimpleString myUniqueID = "This is my unique id";   // Could use a UUID for this

message.setStringProperty(HDR_DUPLICATE_DETECTION_ID, myUniqueID);

...
        </pre><p>And here's an example using the JMS API:</p><pre class="programlisting">
...     

Message jmsMessage = session.createMessage();

String myUniqueID = "This is my unique id";   // Could use a UUID for this

message.setStringProperty(HDR_DUPLICATE_DETECTION_ID.toString(), myUniqueID);

...
        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="duplicate.id.cache"></a>37.2.&nbsp;Configuring the Duplicate ID Cache</h2></div></div><div></div></div><p>The server maintains caches of received values of the <tt class="literal">org.hornetq.core.message.impl.HDR_DUPLICATE_DETECTION_ID</tt> property
            sent to each address. Each address has its own distinct cache.</p><p>The cache is a circular fixed size cache. If the cache has a maximum size of <tt class="literal">n</tt> elements, then the <tt class="literal">n + 1</tt>th id stored will overwrite
            the <tt class="literal">0</tt>th element in the cache.</p><p>The maximum size of the cache is configured by the parameter <tt class="literal">id-cache-size</tt> in <tt class="literal">hornetq-configuration.xml</tt>, the default
            value is <tt class="literal">2000</tt> elements.</p><p>The caches can also be configured to persist to disk or not. This is configured by the
            parameter <tt class="literal">persist-id-cache</tt>, also in <tt class="literal">hornetq-configuration.xml</tt>. If this is set to <tt class="literal">true</tt> then
            each id will be persisted to permanent storage as they are received. The default value
            for this parameter is <tt class="literal">true</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When choosing a size of the duplicate id cache be sure to set it to a larger
                enough size so if you resend messages all the previously sent ones are in the cache
                not having been overwritten.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9326"></a>37.3.&nbsp;Duplicate Detection and Bridges</h2></div></div><div></div></div><p>Core bridges can be configured to automatically add a unique duplicate id value (if there
            isn't already one in the message) before forwarding the message to it's target. This
            ensures that if the target server crashes or the connection is interrupted and the
            bridge resends the message, then if it has already been received by the target server,
            it will be ignored.</p><p>To configure a core bridge to add the duplicate id header, simply set the <i class="parameter"><tt>use-duplicate-detection</tt></i> to <tt class="literal">true</tt> when configuring a
            bridge in <tt class="literal">hornetq-configuration.xml</tt>.</p><p>The default value for this parameter is <tt class="literal">true</tt>.</p><p>For more information on core bridges and how to configure them, please see 
                <a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">Chapter&nbsp;36, <i>Core Bridges</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9351"></a>37.4.&nbsp;Duplicate Detection and Cluster Connections</h2></div></div><div></div></div><p>Cluster connections internally use core bridges to move messages reliable between
            nodes of the cluster. Consequently they can also be configured to insert the duplicate
            id header for each message they move using their internal bridges.</p><p>To configure a cluster connection to add the duplicate id header, simply set the
                <i class="parameter"><tt>use-duplicate-detection</tt></i> to <tt class="literal">true</tt> when
            configuring a cluster connection in <tt class="literal">hornetq-configuration.xml</tt>.</p><p>The default value for this parameter is <tt class="literal">true</tt>.</p><p>For more information on cluster connections and how to configure them, please see <a href="#clusters" title="Chapter&nbsp;38.&nbsp;Clusters">Chapter&nbsp;38, <i>Clusters</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9376"></a>37.5.&nbsp;Duplicate Detection and Paging</h2></div></div><div></div></div><p>HornetQ also uses duplicate detection when paging messages to storage. This is
            so when a message is depaged from storage and server failure occurs, we do not end up
            depaging the message more than once which could result in duplicate delivery.</p><p>For more information on paging and how to configure it, please see <a href="#paging" title="Chapter&nbsp;24.&nbsp;Paging">Chapter&nbsp;24, <i>Paging</i></a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="clusters"></a>Chapter&nbsp;38.&nbsp;Clusters</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9405"></a>38.1.&nbsp;Clusters Overview</h2></div></div><div></div></div><p>HornetQ clusters allow groups of HornetQ servers to be grouped together in order to
            share message processing load. Each active node in the cluster is an active HornetQ
            server which manages its own messages and handles its own connections. A server must be
            configured to be clustered, you will need to set the <tt class="literal">clustered</tt>
            element in the <tt class="literal">hornetq-configuration.xml</tt> configuration file to
                <tt class="literal">true</tt>, this is <tt class="literal">false</tt> by default.</p><p>The cluster is formed by each node declaring <span class="emphasis"><em>cluster connections</em></span>
            to other nodes in the core configuration file <tt class="literal">hornetq-configuration.xml</tt>. When a node forms a cluster connection to
            another node, internally it creates a <span class="emphasis"><em>core bridge</em></span> (as described in
                <a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">Chapter&nbsp;36, <i>Core Bridges</i></a>) connection between it and the other node, this is
            done transparently behind the scenes - you don't have to declare an explicit bridge for
            each node. These cluster connections allow messages to flow between the nodes of the
            cluster to balance load.</p><p>Nodes can be connected together to form a cluster in many different topologies, we
            will discuss a couple of the more common topologies later in this chapter.</p><p>We'll also discuss client side load balancing, where we can balance client connections
            across the nodes of the cluster, and we'll consider message redistribution where HornetQ
            will redistribute messages between nodes to avoid starvation.</p><p>Another important part of clustering is <span class="emphasis"><em>server discovery</em></span> where
            servers can broadcast their connection details so clients or other servers can connect
            to them with the minimum of configuration.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="clusters.server-discovery"></a>38.2.&nbsp;Server discovery</h2></div></div><div></div></div><p>Server discovery is a mechanism by which servers can broadcast their connection
            settings across the network. This is useful for two purposes:</p><div class="itemizedlist"><ul type="disc"><li><p>Discovery by messaging clients. A messaging client wants to be able to connect
                    to the servers of the cluster without having specific knowledge of which servers
                    in the cluster are up at any one time. Messaging clients
                        <span class="emphasis"><em>can</em></span> be initialised with an explicit list of the servers
                    in a cluster, but this is not flexible or maintainable as servers are added or
                    removed from the cluster.</p></li><li><p>Discovery by other servers. Servers in a cluster want to be able to create
                    cluster connections to each other without having prior knowledge of all the
                    other servers in the cluster. </p></li></ul></div><p>Server discovery uses <a href="http://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_top">UDP</a> multicast to broadcast server connection settings. If UDP is disabled
            on your network you won't be able to use this, and will have to specify servers
            explicitly when setting up a cluster or using a messaging client.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="clusters.broadcast-groups"></a>38.2.1.&nbsp;Broadcast Groups</h3></div></div><div></div></div><p>A broadcast group is the means by which a server broadcasts connectors over the
                network. A connector defines a way in which a client (or other server) can make
                connections to the server. For more information on what a connector is, please see
                    <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a>.</p><p>The broadcast group takes a set of connector pairs, each connector pair contains
                connection settings for a live and (optional) backup server and broadcasts them on
                the network. It also defines the UDP address and port settings. </p><p>Broadcast groups are defined in the server configuration file <tt class="literal">hornetq-configuration.xml</tt>. There can be many broadcast groups per
                HornetQ server. All broadcast groups must be defined in a <tt class="literal">broadcast-groups</tt> element.</p><p>Let's take a look at an example broadcast group from <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">&lt;broadcast-groups&gt;
   &lt;broadcast-group name="my-broadcast-group"&gt;
      &lt;local-bind-address&gt;172.16.9.3&lt;/local-bind-address&gt;
      &lt;local-bind-port&gt;5432&lt;/local-bind-port&gt;
      &lt;group-address&gt;231.7.7.7&lt;/group-address&gt;
      &lt;group-port&gt;9876&lt;/group-port&gt;
      &lt;broadcast-period&gt;2000&lt;/broadcast-period&gt;
      &lt;connector-ref connector-name="netty-connector" 
        backup-connector-name="backup-connector"/&gt;
   &lt;/broadcast-group&gt;
&lt;/broadcast-groups&gt;</pre><p>Some of the broadcast group parameters are optional and you'll normally use the
                defaults, but we specify them all in the above example for clarity. Let's discuss
                each one in turn:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">name</tt> attribute. Each broadcast group in the server must
                        have a unique name. </p></li><li><p><tt class="literal">local-bind-address</tt>. This is the local bind address that
                        the datagram socket is bound to. If you have multiple network interfaces on
                        your server, you would specify which one you wish to use for broadcasts by
                        setting this property. If this property is not specified then the socket
                        will be bound to the wildcard address, an IP address chosen by the
                        kernel.</p></li><li><p><tt class="literal">local-bind-port</tt>. If you want to specify a local port to
                        which the datagram socket is bound you can specify it here. Normally you
                        would just use the default value of <tt class="literal">-1</tt> which signifies
                        that an anonymous port should be used. This parameter is alawys specified in conjunction with
                    <tt class="literal">local-bind-address</tt>.</p></li><li><p><tt class="literal">group-address</tt>. This is the multicast address to which
                        the data will be broadcast. It is a class D IP address in the range <tt class="literal">224.0.0.0</tt> to <tt class="literal">239.255.255.255</tt>, inclusive.
                        The address <tt class="literal">224.0.0.0</tt> is reserved and is not available
                        for use. This parameter is mandatory.</p></li><li><p><tt class="literal">group-port</tt>. This is the UDP port number used for
                        broadcasting. This parameter is mandatory.</p></li><li><p><tt class="literal">broadcast-period</tt>. This is the period in milliseconds
                        between consecutive broadcasts. This parameter is optional, the default
                        value is <tt class="literal">2000</tt> milliseconds.</p></li><li><p><tt class="literal">connector-ref</tt>. This specifies the connector and
                        optional backup connector that will be broadcasted (see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a> for more information on connectors).
                        The connector to be broadcasted is specified by the <tt class="literal">connector-name</tt> attribute, and the backup connector to be
                        broadcasted is specified by the <tt class="literal">backup-connector</tt>
                        attribute. The <tt class="literal">backup-connector</tt> attribute is
                        optional.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="clusters.discovery-groups"></a>38.2.2.&nbsp;Discovery Groups</h3></div></div><div></div></div><p>While the broadcast group defines how connector information is broadcasted from a
                server, a discovery group defines how connector information is received from a
                multicast address.</p><p>A discovery group maintains a list of connector pairs - one for each broadcast by
                a different server. As it receives broadcasts on the multicast group address from a
                particular server it updates its entry in the list for that server.</p><p>If it has not received a broadcast from a particular server for a length of time
                it will remove that server's entry from its list.</p><p>Discovery groups are used in two places in HornetQ:</p><div class="itemizedlist"><ul type="disc"><li><p>By cluster connections so they know what other servers in the cluster they
                        should make connections to.</p></li><li><p>By messaging clients so they can discovery what servers in the cluster
                        they can connect to.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9573"></a>38.2.3.&nbsp;Defining Discovery Groups on the Server</h3></div></div><div></div></div><p>For cluster connections, discovery groups are defined in the server side
                configuration file <tt class="literal">hornetq-configuration.xml</tt>. All discovery
                groups must be defined inside a <tt class="literal">discovery-groups</tt> element. There
                can be many discovery groups defined by HornetQ server. Let's look at an
                example:</p><pre class="programlisting">&lt;discovery-groups&gt;
   &lt;discovery-group name="my-discovery-group"&gt;
      &lt;local-bind-address&gt;172.16.9.7&lt;/local-bind-address&gt;
      &lt;group-address&gt;231.7.7.7&lt;/group-address&gt;
      &lt;group-port&gt;9876&lt;/group-port&gt;
      &lt;refresh-timeout&gt;10000&lt;/refresh-timeout&gt;
   &lt;/discovery-group&gt;
&lt;/discovery-groups&gt;</pre><p>We'll consider each parameter of the discovery group:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">name</tt> attribute. Each discovery group must have a unique
                        name per server.</p></li><li><p><tt class="literal">local-bind-address</tt>. If you are running with multiple network interfaces on the same machine, you 
                    may want to specify that the discovery group listens only only a specific interface. To do this you can specify the interface
                    address with this parameter. This parameter is optional.</p></li><li><p><tt class="literal">group-address</tt>. This is the multicast ip address of the
                        group to listen on. It should match the <tt class="literal">group-address</tt> in
                        the broadcast group that you wish to listen from. This parameter is
                        mandatory.</p></li><li><p><tt class="literal">group-port</tt>. This is the UDP port of the multicast
                        group. It should match the <tt class="literal">group-port</tt> in the broadcast
                        group that you wish to listen from. This parameter is mandatory.</p></li><li><p><tt class="literal">refresh-timeout</tt>. This is the period the discovery group
                        waits after receiving the last broadcast from a particular server before
                        removing that servers connector pair entry from its list. You would normally
                        set this to a value significantly higher than the <tt class="literal">broadcast-period</tt> on the broadcast group otherwise servers
                        might intermittently disappear from the list even though they are still
                        broadcasting due to slight differences in timing. This parameter is
                        optional, the default value is <tt class="literal">10000</tt> milliseconds (10
                        seconds).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="clusters-discovery.groups.clientside"></a>38.2.4.&nbsp;Discovery Groups on the Client Side</h3></div></div><div></div></div><p>Let's discuss how to configure a HornetQ client to use discovery to discover a
                list of servers to which it can connect. The way to do this differs depending on
                whether you're using JMS or the core API.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9631"></a>38.2.4.1.&nbsp;Configuring client discovery using JMS</h4></div></div><div></div></div><p>If you're using JMS and you're also using the JMS Service on the server to
                    load your JMS connection factory instances into JNDI, then you can specify which
                    discovery group to use for your JMS connection factory in the server side xml
                    configuration <tt class="literal">hornetq-jms.xml</tt>. Let's take a look at an
                    example:</p><pre class="programlisting">&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;discovery-group-ref discovery-group-name="my-discovery-group"/&gt;
    &lt;entries&gt;
       &lt;entry name="ConnectionFactory"/&gt;
    &lt;/entries&gt;
&lt;/connection-factory&gt;</pre><p>The element <tt class="literal">discovery-group-ref</tt> specifies the name of a
                    discovery group defined in <tt class="literal">hornetq-configuration.xml</tt>.</p><p>When this connection factory is downloaded from JNDI by a client application
                    and JMS connections are created from it, those connections will be load-balanced
                    across the list of servers that the discovery group maintains by listening on
                    the multicast address specified in the discovery group configuration.</p><p>If you're using JMS, but you're not using JNDI to lookup a connection factory
                    - you're instantiating the JMS connection factory directly then you can specify
                    the discovery group parameters directly when creating the JMS connection
                    factory. Here's an
                    example:</p><pre class="programlisting">final String groupAddress = "231.7.7.7";

final int groupPort = 9876;

ConnectionFactory jmsConnectionFactory = 
        HornetQJMSClient.createConnectionFactory(groupAddress, groupPort);

Connection jmsConnection1 = jmsConnectionFactory.createConnection();

Connection jmsConnection2 = jmsConnectionFactory.createConnection();</pre><p>The <tt class="literal">refresh-timeout</tt> can be set directly on the connection
                    factory by using the setter method <tt class="literal">setDiscoveryRefreshTimeout()</tt> if you
                        want to change the default value.</p><p>There is also a further parameter settable on the connection factory using the
                    setter method <tt class="literal">setDiscoveryInitialWaitTimeout()</tt>. If the connection
                    factory is used immediately after creation then it may not have had enough time
                    to received broadcasts from all the nodes in the cluster. On first usage, the
                    connection factory will make sure it waits this long since creation before
                    creating the first connection. The default value for this parameter is <tt class="literal">10000</tt> milliseconds.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9671"></a>38.2.4.2.&nbsp;Configuring client discovery using Core</h4></div></div><div></div></div><p>If you're using the core API to directly instantiate <tt class="literal">ClientSessionFactory</tt> instances, then you can specify the
                    discovery group parameters directly when creating the session factory. Here's an
                    example:
                    </p><pre class="programlisting">
                    final String groupAddress = "231.7.7.7"; 
                    final int groupPort = 9876;
                    SessionFactory factory = HornetQClient.createClientSessionFactory(groupAddress, groupPort);
                    ClientSession session1 = factory.createClientSession(...); ClientSession
                    session2 = factory.createClientSession(...);
                
                </pre><p>The <tt class="literal">refresh-timeout</tt> can be set directly on the session
                    factory by using the setter method <tt class="literal">setDiscoveryRefreshTimeout()</tt> if you
                        want to change the default value.</p><p>There is also a further parameter settable on the session factory using the
                    setter method <tt class="literal">setDiscoveryInitialWaitTimeout()</tt>. If the session factory
                    is used immediately after creation then it may not have had enough time to
                    received broadcasts from all the nodes in the cluster. On first usage, the
                    session factory will make sure it waits this long since creation before creating
                    the first session. The default value for this parameter is <tt class="literal">10000</tt> milliseconds.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9697"></a>38.3.&nbsp;Server-Side Message Load Balancing</h2></div></div><div></div></div><p>If cluster connections are defined between nodes of a cluster, then HornetQ will load
            balance messages arriving at a particular node from a client.</p><p>Let's take a simple example of a cluster of four nodes A, B, C, and D arranged in a
                <span class="emphasis"><em>symmetric cluster</em></span> (described in <a href="#symmetric-cluster" title="38.7.1.&nbsp;Symmetric cluster">Section&nbsp;38.7.1, &#8220;Symmetric cluster&#8221;</a>). We have a queue called <tt class="literal">OrderQueue</tt>
            deployed on each node of the cluster.</p><p>We have client Ca connected to node A, sending orders to the server. We have also have
            order processor clients Pa, Pb, Pc, and Pd connected to each of the nodes A, B, C, D. If
            no cluster connection was defined on node A, then as order messages arrive on node A
            they will all end up in the <tt class="literal">OrderQueue</tt> on node A, so will only get
            consumed by the order processor client attached to node A, Pa.</p><p>If we define a cluster connection on node A, then as ordered messages arrive on node A
            instead of all of them going into the local <tt class="literal">OrderQueue</tt> instance, they
            are distributed in a round-robin fashion between all the nodes of the cluster. The
            messages are forwarded from the receiving node to other nodes of the cluster. This is
            all done on the server side, the client maintains a single connection to node A.</p><p>For example, messages arriving on node A might be distributed in the following order
            between the nodes: B, D, C, A, B, D, C, A, B, D. The exact order depends on the order
            the nodes started up, but the algorithm used is round robin.</p><p>HornetQ cluster connections can be configured to always blindly load balance messages
            in a round robin fashion irrespective of whether there are any matching consumers on
            other nodes, but they can be a bit cleverer than that and also be configured to only
            distribute to other nodes if they have matching consumers. We'll look at both these
            cases in turn with some examples, but first we'll discuss configuring cluster
            connections in general.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="clusters.cluster-connections"></a>38.3.1.&nbsp;Configuring Cluster Connections</h3></div></div><div></div></div><p>Cluster connections group servers into clusters so that messages can be load
                balanced between the nodes of the cluster. Let's take a look at a typical cluster
                connection. Cluster connections are always defined in <tt class="literal">hornetq-configuration.xml</tt> inside a <tt class="literal">cluster-connection</tt> element. There can be zero or more cluster
                connections defined per HornetQ server.</p><pre class="programlisting">
&lt;cluster-connections&gt;
    &lt;cluster-connection name="my-cluster"&gt;
        &lt;address&gt;jms&lt;/address&gt;
        &lt;retry-interval&gt;500&lt;/retry-interval&gt;
        &lt;use-duplicate-detection&gt;true&lt;/use-duplicate-detection&gt;
        &lt;forward-when-no-consumers&gt;false&lt;/forward-when-no-consumers&gt;
        &lt;max-hops&gt;1&lt;/max-hops&gt;
        &lt;discovery-group-ref discovery-group-name="my-discovery-group"/&gt;
    &lt;/cluster-connection&gt;
&lt;/cluster-connections&gt;                
            </pre><p>In the above cluster connection all parameters have been explicitly specified. In
                practice you might use the defaults for some.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">address</tt>. Each cluster connection only applies to
                        messages sent to an address that starts with this value.</p><p>In this case, this cluster connection will load balance messages sent to
                        address that start with <tt class="literal">jms</tt>. This cluster connection,
                        will, in effect apply to all JMS queue and topic subscriptions since they
                        map to core queues that start with the substring "jms".</p><p>The address can be any value and you can have many cluster connections
                        with different values of <tt class="literal">address</tt>, simultaneously
                        balancing messages for those addresses, potentially to different clusters of
                        servers. By having multiple cluster connections on different addresses a
                        single HornetQ Server can effectively take part in multiple clusters
                        simultaneously.</p><p>Be careful not to have multiple cluster connections with overlapping
                        values of <tt class="literal">address</tt>, e.g. "europe" and "europe.news" since
                        this could result in the same messages being distributed between more than
                        one cluster connection, possibly resulting in duplicate deliveries. </p><p>This parameter is mandatory.</p></li><li><p><tt class="literal">retry-interval</tt>. We mentioned before that, internally,
                        cluster connections cause bridges to be created between the nodes of the
                        cluster. If the cluster connection is created and the target node has not
                        been started, or say, is being rebooted, then the cluster connections from
                        other nodes will retry connecting to the target until it comes back up, in
                        the same way as a bridge does.</p><p>This parameter determines the interval in milliseconds between retry
                        attempts. It has the same meaning as the <tt class="literal">retry-interval</tt>
                        on a bridge (as described in <a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">Chapter&nbsp;36, <i>Core Bridges</i></a>).</p><p>This parameter is optional and its default value is <tt class="literal">500</tt>
                        milliseconds.</p></li><li><p><tt class="literal">use-duplicate-detection</tt>. Internally cluster connections
                        use bridges to link the nodes, and bridges can be configured to add a
                        duplicate id property in each message that is forwarded. If the target node
                        of the bridge crashes and then recovers, messages might be resent from the
                        source node. By enabling duplicate detection any duplicate messages will be
                        filtered out and ignored on receipt at the target node.</p><p>This parameter has the same meaning as <tt class="literal">use-duplicate-detection</tt> on a bridge. For more information on
                        duplicate detection, please see <a href="#duplicate-detection" title="Chapter&nbsp;37.&nbsp;Duplicate Message Detection">Chapter&nbsp;37, <i>Duplicate Message Detection</i></a>.</p><p>This parameter is optional and has a default value of <tt class="literal">true</tt>.</p></li><li><p><tt class="literal">forward-when-no-consumers</tt>. This parameter determines
                        whether messages will be distributed round robin between other nodes of the
                        cluster <span class="emphasis"><em>irrespective</em></span> of whether there are matching or
                        indeed any consumers on other nodes. </p><p>If this is set to <tt class="literal">true</tt> then each incoming message will
                        be round robin'd even though the same queues on the other nodes of the
                        cluster may have no consumers at all, or they may have consumers that have
                        non matching message filters (selectors). Note that HornetQ will
                            <span class="emphasis"><em>not</em></span> forward messages to other nodes if there are no
                            <span class="emphasis"><em>queues</em></span> of the same name on the other nodes, even if
                        this parameter is set to <tt class="literal">true</tt>.</p><p>If this is set to <tt class="literal">false</tt> then HornetQ will only forward
                        messages to other nodes of the cluster if the address to which they are
                        being forwarded has queues which have consumers, and if those consumers have
                        message filters (selectors) at least one of those selectors must match the
                        message.</p><p>This parameter is optional, the default value is <tt class="literal">false</tt>.</p></li><li><p><tt class="literal">max-hops</tt>. When a cluster connection decides the set of
                        nodes to which it might load balance a message, those nodes do not have to
                        be directly connected to it via a cluster connection. HornetQ can be
                        configured to also load balance messages to nodes which might be connected
                        to it only indirectly with other HornetQ servers as intermediates in a
                        chain.</p><p>This allows HornetQ to be configured in more complex topologies and still
                        provide message load balancing. We'll discuss this more later in this
                        chapter.</p><p>The default value for this parameter is <tt class="literal">1</tt>, which means
                        messages are only load balanced to other HornetQ serves which are directly
                        connected to this server. This parameter is optional.</p></li><li><p><tt class="literal">discovery-group-ref</tt>. This parameter determines which
                        discovery group is used to obtain the list of other servers in the cluster
                        that this cluster connection will make connections to.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="clusters.clusteruser"></a>38.3.2.&nbsp;Cluster User Credentials</h3></div></div><div></div></div><p>When creating connections between nodes of a cluster to form a cluster connection,
                HornetQ uses a cluster user and cluster password which is defined in <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">
                &lt;cluster-user&gt;HORNETQ.CLUSTER.ADMIN.USER&lt;/cluster-user&gt;
                &lt;cluster-password&gt;CHANGE ME!!&lt;/cluster-password&gt;
            </pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>It is imperative that these values are changed from their default, or remote
                    clients will be able to make connections to the server using the default values.
                    If they are not changed from the default, HornetQ will detect this and pester
                    you with a warning on every start-up.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="clusters.client.loadbalancing"></a>38.4.&nbsp;Client-Side Load balancing</h2></div></div><div></div></div><p>With HornetQ client-side load balancing, subsequent sessions created using a single
            session factory can be connected to different nodes of the cluster. This allows sessions
            to spread smoothly across the nodes of a cluster and not be "clumped" on any particular
            node.</p><p>The load balancing policy to be used by the client factory is configurable. HornetQ
            provides two out-of-the-box load balancing policies and you can also implement your own
            and use that.</p><p>The out-of-the-box policies are</p><div class="itemizedlist"><ul type="disc"><li><p>Round Robin. With this policy the first node is chosen randomly then each
                    subsequent node is chosen sequentially in the same order.</p><p>For example nodes might be chosen in the order B, C, D, A, B, C, D, A, B or D,
                    A, B, C, A, B, C, D, A or C, D, A, B, C, D, A, B, C, D, A.</p></li><li><p>Random. With this policy each node is chosen randomly.</p></li></ul></div><p>You can also implement your own policy by implementing the interface <tt class="literal">org.hornetq.api.core.client.loadbalance.ConnectionLoadBalancingPolicy</tt></p><p>Specifying which load balancing policy to use differs whether you are using JMS or the
            core API. If you don't specify a policy then the default will be used which is <tt class="literal">org.hornetq.api.core.client.loadbalance.RoundRobinConnectionLoadBalancingPolicy</tt>.</p><p>If you're using JMS, and you're using JNDI on the server to put your JMS connection
            factories into JNDI, then you can specify the load balancing policy directly in the
                <tt class="literal">hornetq-jms.xml</tt> configuration file on the server as follows:
            </p><pre class="programlisting">
&lt;connection-factory name="ConnectionFactory"&gt;
    &lt;discovery-group-ref discovery-group-name="my-discovery-group"/&gt;
    &lt;entries&gt;
        &lt;entry name="ConnectionFactory"/&gt;
    &lt;/entries&gt;
    &lt;connection-load-balancing-policy-class-name&gt;
    org.hornetq.api.core.client.loadbalance.RandomConnectionLoadBalancingPolicy
    &lt;/connection-load-balancing-policy-class-name&gt;
&lt;/connection-factory&gt;            
        </pre><p>The
            above example would deploy a JMS connection factory that uses the random connection load
            balancing policy. </p><p>If you're using JMS but you're instantiating your connection factory directly on the
            client side then you can set the load balancing policy using the setter on the <tt class="literal">HornetQConnectionFactory</tt> before using it:
            </p><pre class="programlisting">
ConnectionFactory jmsConnectionFactory = HornetQJMSClient.createConnectionFactory(...);
jmsConnectionFactory.setLoadBalancingPolicyClassName("com.acme.MyLoadBalancingPolicy");
        </pre><p>If you're using the core API, you can set the load balancing policy directly on the
                <tt class="literal">ClientSessionFactory</tt> instance you are using:
            </p><pre class="programlisting">
ClientSessionFactory factory = HornetQClient.createClientSessionFactory(...);
factory.setLoadBalancingPolicyClassName("com.acme.MyLoadBalancingPolicy");
            </pre><p>The set of servers over which the factory load balances can be determined in one of
            two ways:</p><div class="itemizedlist"><ul type="disc"><li><p>Specifying servers explicitly</p></li><li><p>Using discovery.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9918"></a>38.5.&nbsp;Specifying Members of a Cluster Explicitly</h2></div></div><div></div></div><p>Sometimes UDP is not enabled on a network so it's not possible to use UDP server
            discovery for clients to discover the list of servers in the cluster, or for servers to
            discover what other servers are in the cluster.</p><p>In this case, the list of servers in the cluster can be specified explicitly on each
            node and on the client side. Let's look at how we do this:</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9925"></a>38.5.1.&nbsp;Specify List of Servers on the Client Side</h3></div></div><div></div></div><p>This differs depending on whether you're using JMS or the Core API</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9930"></a>38.5.1.1.&nbsp;Specifying List of Servers using JMS</h4></div></div><div></div></div><p>If you're using JMS, and you're using the JMS Service to load your JMS
                    connection factory instances directly into JNDI on the server, then you can
                    specify the list of servers in the server side configuration file <tt class="literal">hornetq-jms.xml</tt>. Let's take a look at an example:</p><pre class="programlisting">&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="my-connector1" 
           backup-connector-name="my-backup-connector1"/&gt;
      &lt;connector-ref connector-name="my-connector2" 
           backup-connector-name="my-backup-connector2"/&gt;
      &lt;connector-ref connector-name="my-connector3" 
           backup-connector-name="my-backup-connector3"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
&lt;/connection-factory&gt;</pre><p>The <tt class="literal">connection-factory</tt> element can contain zero or more
                        <tt class="literal">connector-ref</tt> elements, each one of which specifies a
                        <tt class="literal">connector-name</tt> attribute and an optional <tt class="literal">backup-connector-name</tt> attribute. The <tt class="literal">connector-name</tt> attribute references a connector defined in
                        <tt class="literal">hornetq-configuration.xml</tt> which will be used as a live
                    connector. The <tt class="literal">backup-connector-name</tt> is optional, and if
                    specified it also references a connector defined in <tt class="literal">hornetq-configuration.xml</tt>. For more information on connectors
                    please see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a>.</p><p>The connection factory thus maintains a list of [connector, backup connector]
                    pairs, these pairs are then used by the client connection load balancing policy
                    on the client side when creating connections to the cluster.</p><p>If you're using JMS but you're not using JNDI then you can also specify the
                    list of [connector, backup connector] pairs directly when instantiating the
                        <tt class="literal">HornetQConnectionFactory</tt>, here's an
                    example:</p><pre class="programlisting">List&lt;Pair&lt;TransportConfiguration, TransportConfiguration&gt;&gt; serverList = 
        new ArrayList&lt;Pair&lt;TransportConfiguration, TransportConfiguration&gt;&gt;();

serverList.add(new Pair&lt;TransportConfiguration, 
        TransportConfiguration&gt;(liveTC0, backupTC0));
serverList.add(new Pair&lt;TransportConfiguration, 
        TransportConfiguration&gt;(liveTC1, backupTC1));
serverList.add(new Pair&lt;TransportConfiguration, 
        TransportConfiguration&gt;(liveTC2, backupTC2));

ConnectionFactory jmsConnectionFactory = HornetQJMSClient.createConnectionFactory(serverList);

Connection jmsConnection1 = jmsConnectionFactory.createConnection();

Connection jmsConnection2 = jmsConnectionFactory.createConnection();</pre><p>In the above snippet we create a list of pairs of <tt class="literal">TransportConfiguration</tt> objects. Each <tt class="literal">TransportConfiguration</tt> object contains knowledge of how to make a
                    connection to a specific server.</p><p>A <tt class="literal">HornetQConnectionFactory</tt> instance is then created passing
                    the list of servers in the constructor. Any connections subsequently created by
                    this factory will create connections according to the client connection load
                    balancing policy applied to that list of servers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9990"></a>38.5.1.2.&nbsp;Specifying List of Servers using the Core API</h4></div></div><div></div></div><p>If you're using the core API you can also specify the list of servers directly
                    when creating the <tt class="literal">ClientSessionFactory</tt> instance. Here's an
                    example:</p><pre class="programlisting">List&lt;Pair&lt;TransportConfiguration, TransportConfiguration&gt;&gt; serverList = 
        new ArrayList&lt;Pair&lt;TransportConfiguration, TransportConfiguration&gt;&gt;();

serverList.add(new Pair&lt;TransportConfiguration, 
        TransportConfiguration&gt;(liveTC0, backupTC0));
serverList.add(new Pair&lt;TransportConfiguration, 
        TransportConfiguration&gt;(liveTC1, backupTC1));
serverList.add(new Pair&lt;TransportConfiguration, 
        TransportConfiguration&gt;(liveTC2, backupTC2));

ClientSessionFactory factory = HornetQClient.createClientSessionFactory(serverList);

ClientSession sesison1 = factory.createClientSession(...);

ClientSession session2 = factory.createClientSession(...);</pre><p>In the above snippet we create a list of pairs of <tt class="literal">TransportConfiguration</tt> objects. Each <tt class="literal">TransportConfiguration</tt> object contains knowledge of how to make a
                    connection to a specific server. For more information on this, please see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a>.</p><p>A <tt class="literal">ClientSessionFactoryImpl</tt> instance is then created passing
                    the list of servers in the constructor. Any sessions subsequently created by
                    this factory will create sessions according to the client connection load
                    balancing policy applied to that list of servers.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="clusters.static.servers"></a>38.5.2.&nbsp;Specifying List of Servers to form a Cluster</h3></div></div><div></div></div><p>Let's take a look at an example where each cluster connection is defined for a
                symmetric cluster, but we're not using discovery for each node to discover its
                neighbours, instead we'll configure each cluster connection to have explicit
                knowledge of all the other nodes in the cluster.</p><p>Here's an example cluster connection definition showing that:</p><pre class="programlisting">&lt;cluster-connections&gt;
    &lt;cluster-connection name="my-explicit-cluster"&gt;
        &lt;address&gt;jms&lt;/address&gt;
        &lt;connector-ref connector-name="my-connector1" 
            backup-connector-name="my-backup-connector1"/&gt;
        &lt;connector-ref connector-name="my-connector2" 
            backup-connector-name="my-backup-connector2"/&gt;
        &lt;connector-ref connector-name="my-connector3" 
            backup-connector-name="my-backup-connector3"/&gt;
    &lt;/cluster-connection&gt;
&lt;/cluster-connections&gt;</pre><p>The <tt class="literal">cluster-connection</tt> element can contain zero or more
                    <tt class="literal">connector-ref</tt> elements, each one of which specifies a
                    <tt class="literal">connector-name</tt> attribute and an optional <tt class="literal">backup-connector-name</tt> attribute. The <tt class="literal">connector-name</tt> attribute references a connector defined in <tt class="literal">hornetq-configuration.xml</tt> which will be used as a live connector. The
                    <tt class="literal">backup-connector-name</tt> is optional, and if specified it also
                references a connector defined in <tt class="literal">hornetq-configuration.xml</tt>. For
                more information on connectors please see <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Due to a limitation in HornetQ 2.0.0, failover is not supported for clusters
                    defined using a static set of nodes. To support failover over cluster nodes,
                    they must be configured to use a discovery group.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="clusters.message-redistribution"></a>38.6.&nbsp;Message Redistribution</h2></div></div><div></div></div><p>Another important part of clustering is message redistribution. Earlier we learned how
            server side message load balancing round robins messages across the cluster. If <tt class="literal">forward-when-no-consumers</tt> is false, then messages won't be forwarded to
            nodes which don't have matching consumers, this is great and ensures that messages don't
            arrive on a queue which has no consumers to consume them, however there is a situation
            it doesn't solve: What happens if the consumers on a queue close after the messages have
            been sent to the node? If there are no consumers on the queue the message won't get
            consumed and we have a <span class="emphasis"><em>starvation</em></span> situation.</p><p>This is where message redistribution comes in. With message redistribution HornetQ can
            be configured to automatically <span class="emphasis"><em>redistribute</em></span> messages from queues
            which have no consumers back to other nodes in the cluster which do have matching
            consumers.</p><p>Message redistribution can be configured to kick in immediately after the last
            consumer on a queue is closed, or to wait a configurable delay after the last consumer
            on a queue is closed before redistributing. By default message redistribution is
            disabled.</p><p>Message redistribution can be configured on a per address basis, by specifying the
            redistribution delay in the address settings, for more information on configuring
            address settings, please see <a href="#queue-attributes" title="Chapter&nbsp;25.&nbsp;Queue Attributes">Chapter&nbsp;25, <i>Queue Attributes</i></a>.</p><p>Here's an address settings snippet from <tt class="literal">hornetq-configuration.xml</tt>
            showing how message redistribution is enabled for a set of queues:</p><pre class="programlisting">&lt;address-settings&gt;     
   &lt;address-setting match="jms.#"&gt;
      &lt;redistribution-delay&gt;0&lt;/redistribution-delay&gt;
   &lt;/address-setting&gt;
 &lt;/address-settings&gt;</pre><p>The above <tt class="literal">address-settings</tt> block would set a <tt class="literal">redistribution-delay</tt> of <tt class="literal">0</tt> for any queue which is bound
            to an address that starts with "jms.". All JMS queues and topic subscriptions are bound
            to addresses that start with "jms.", so the above would enable instant (no delay)
            redistribution for all JMS queues and topic subscriptions.</p><p>The attribute <tt class="literal">match</tt> can be an exact match or it can be a string
            that conforms to the HornetQ wildcard syntax (described in <a href="#wildcard-syntax" title="Chapter&nbsp;13.&nbsp;Understanding the HornetQ Wildcard Syntax">Chapter&nbsp;13, <i>Understanding the HornetQ Wildcard Syntax</i></a>).</p><p>The element <tt class="literal">redistribution-delay</tt> defines the delay in milliseconds
            after the last consumer is closed on a queue before redistributing messages from that
            queue to other nodes of the cluster which do have matching consumers. A delay of zero
            means the messages will be immediately redistributed. A value of <tt class="literal">-1</tt>
            signifies that messages will never be redistributed. The default value is <tt class="literal">-1</tt>.</p><p>It often makes sense to introduce a delay before redistributing as it's a common case
            that a consumer closes but another one quickly is created on the same queue, in such a
            case you probably don't want to redistribute immediately since the new consumer will
            arrive shortly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10115"></a>38.7.&nbsp;Cluster topologies</h2></div></div><div></div></div><p>HornetQ clusters can be connected together in many different topologies, let's
            consider the two most common ones here</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="symmetric-cluster"></a>38.7.1.&nbsp;Symmetric cluster</h3></div></div><div></div></div><p>A symmetric cluster is probably the most common cluster topology, and you'll be
                familiar with if you've had experience of JBoss Application Server
                clustering.</p><p>With a symmetric cluster every node in the cluster is connected to every other
                node in the cluster. In other words every node in the cluster is no more than one
                hop away from every other node.</p><p>To form a symmetric cluster every node in the cluster defines a cluster connection
                with the attribute <tt class="literal">max-hops</tt> set to <tt class="literal">1</tt>.
                Typically the cluster connection will use server discovery in order to know what
                other servers in the cluster it should connect to, although it is possible to
                explicitly define each target server too in the cluster connection if, for example,
                UDP is not available on your network.</p><p>With a symmetric cluster each node knows about all the queues that exist on all
                the other nodes and what consumers they have. With this knowledge it can determine
                how to load balance and redistribute messages around the nodes.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10137"></a>38.7.2.&nbsp;Chain cluster</h3></div></div><div></div></div><p>With a chain cluster, each node in the cluster is not connected to every node in
                the cluster directly, instead the nodes form a chain with a node on each end of the
                chain and all other nodes just connecting to the previous and next nodes in the
                chain.</p><p>An example of this would be a three node chain consisting of nodes A, B and C.
                Node A is hosted in one network and has many producer clients connected to it
                sending order messages. Due to corporate policy, the order consumer clients need to
                be hosted in a different network, and that network is only accessible via a third
                network. In this setup node B acts as a mediator with no producers or consumers on
                it. Any messages arriving on node A will be forwarded to node B, which will in turn
                forward them to node C where they can get consumed. Node A does not need to directly
                connect to C, but all the nodes can still act as a part of the cluster.</p><p>To set up a cluster in this way, node A would define a cluster connection that
                connects to node B, and node B would define a cluster connection that connects to
                node C. In this case we only want cluster connections in one direction since we're
                only moving messages from node A-&gt;B-&gt;C and never from C-&gt;B-&gt;A.</p><p>For this topology we would set <tt class="literal">max-hops</tt> to <tt class="literal">2</tt>. With a value of <tt class="literal">2</tt> the knowledge of what queues and
                consumers that exist on node C would be propagated from node C to node B to node A.
                Node A would then know to distribute messages to node B when they arrive, even
                though node B has no consumers itself, it would know that a further hop away is node
                C which does have consumers.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ha"></a>Chapter&nbsp;39.&nbsp;High Availability and Failover</h2></div></div><div></div></div><p>We define high availability as the <span class="emphasis"><em>ability for the system to continue
            functioning after failure of one or more of the servers</em></span>.</p><p>A part of high availability is <span class="emphasis"><em>failover</em></span> which we define as the
            <span class="emphasis"><em>ability for client connections to migrate from one server to another in event
            of server failure so client applications can continue to operate</em></span>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10190"></a>39.1.&nbsp;Live - Backup Pairs</h2></div></div><div></div></div><p>HornetQ allows pairs of servers to be linked together as <span class="emphasis"><em>live -
                backup</em></span> pairs. In this release there is a single backup server for each
            live server. A backup server is owned by only one live server. Backup servers are not
            operational until failover occurs.</p><p>Before failover, only the live server is serving the HornetQ clients while the backup
            server remains passive. When clients fail over to the backup server, the backup server
            becomes active and starts to service the HornetQ clients.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ha.mode"></a>39.1.1.&nbsp;HA modes</h3></div></div><div></div></div><p>HornetQ provides two different modes for high availability, either by
                    <span class="emphasis"><em>replicating data</em></span> from the live server journal to the backup
                server or using a <span class="emphasis"><em>shared store</em></span> for both servers.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Only persistent message data will survive failover. Any non persistent message
                    data will not be available after failover.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="ha.mode.replicated"></a>39.1.1.1.&nbsp;Data Replication</h4></div></div><div></div></div><p>In this mode, data stored in the HornetQ journal are replicated from the live
                    server's journal to the backup server's journal. Note that we do not replicate
                    the entire server state, we only replicate the journal and other persistent
                    operations.</p><p>Replication is performed in an asynchronous fashion between live and backup
                    server. Data is replicated one way in a stream, and responses that the data has
                    reached the backup is returned in another stream. Pipelining replications and
                    responses to replications in separate streams allows replication throughput to
                    be much higher than if we synchronously replicated data and waited for a
                    response serially in an RPC manner before replicating the next piece of
                    data.</p><p>When the user receives confirmation that a transaction has committed, prepared
                    or rolled back or a durable message has been sent, we can guarantee it has
                    reached the backup server and been persisted.</p><p>Data replication introduces some inevitable performance overhead compared to
                    non replicated operation, but has the advantage in that it requires no expensive
                    shared file system (e.g. a SAN) for failover, in other words it is a <span class="italic">shared-nothing</span> approach to high
                    availability.</p><p>Failover with data replication is also faster than failover using shared
                    storage, since the journal does not have to be reloaded on failover at the
                    backup node.</p><div align="center"><img src="images/ha-replicated-store.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="configuring.live.backup"></a>39.1.1.1.1.&nbsp;Configuration</h5></div></div><div></div></div><p>First, on the live server, in <tt class="literal">hornetq-configuration.xml</tt>, configure the live server with
                        knowledge of its backup server. This is done by specifying a <tt class="literal">backup-connector-ref</tt> element. This element references a
                        connector, also specified on the live server which specifies how to connect
                        to the backup server.</p><p>Here's a snippet from live server's <tt class="literal">hornetq-configuration.xml</tt> configured to connect to its backup
                        server:</p><pre class="programlisting">
  &lt;backup-connector-ref connector-name="backup-connector"/&gt;

  &lt;connectors&gt;
     &lt;!-- This connector specifies how to connect to the backup server    --&gt;
     &lt;!-- backup server is located on host "192.168.0.11" and port "5445" --&gt;
     &lt;connector name="backup-connector"&gt;
       &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/factory-class&gt;
       &lt;param key="host" value="192.168.0.11"/&gt;
       &lt;param key="port" value="5445"/&gt;
     &lt;/connector&gt;
  &lt;/connectors&gt;</pre><p>Secondly, on the backup server, we flag the server as a backup and make
                        sure it has an acceptor that the live server can connect to. We also make
                        sure the shared-store paramater is set to false:</p><pre class="programlisting">
  &lt;backup&gt;true&lt;/backup&gt;
  
  &lt;shared-store&gt;false&lt;shared-store&gt;
  
  &lt;acceptors&gt;
     &lt;acceptor name="acceptor"&gt;
        &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
        &lt;param key="host" value="192.168.0.11"/&gt;
        &lt;param key="port" value="5445"/&gt;
     &lt;/acceptor&gt;
  &lt;/acceptors&gt;               
              </pre><p>For a backup server to function correctly it's also important that it has
                        the same set of bridges, predefined queues, cluster connections, broadcast
                        groups and discovery groups as defined on the live node. The easiest way to
                        ensure this is to copy the entire server side configuration from live to
                        backup and just make the changes as specified above. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e10255"></a>39.1.1.1.2.&nbsp;Synchronizing a Backup Node to a Live Node</h5></div></div><div></div></div><p>In order for live - backup pairs to operate properly, they must be
                        identical replicas. This means you cannot just use any backup server that's
                        previously been used for other purposes as a backup server, since it will
                        have different data in its persistent storage. If you try to do so, you will
                        receive an exception in the logs and the server will fail to start.</p><p>To create a backup server for a live server that's already been used for
                        other purposes, it's necessary to copy the <tt class="literal">data</tt> directory
                        from the live server to the backup server. This means the backup server will
                        have an identical persistent store to the backup server.</p><p>Once a live server has failed over onto a backup server, the old live
                        server becomes invalid and cannot just be restarted. To resynchonize the
                        pair as a working live backup pair again, both servers need to be stopped,
                        the data copied from the live node to the backup node and restarted
                        again.</p><p>The next release of HornetQ will provide functionality for automatically
                        synchronizing a new backup node to a live node without having to temporarily
                        bring down the live node.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="ha.mode.shared"></a>39.1.1.2.&nbsp;Shared Store</h4></div></div><div></div></div><p>When using a shared store, both live and backup servers share the
                        <span class="emphasis"><em>same</em></span> entire data directory using a shared file system.
                    This means the paging directory, journal directory, large messages and binding
                    journal.</p><p>When failover occurs and the backup server takes over, it will load the
                    persistent storage from the shared file system and clients can connect to
                    it.</p><p>This style of high availability differs from data replication in that it
                    requires a shared file system which is accessible by both the live and backup
                    nodes. Typically this will be some kind of high performance Storage Area Network
                    (SAN). We do not recommend you use Network Attached Storage (NAS), e.g. NFS
                    mounts to store any shared journal (NFS is slow).</p><p>The advantage of shared-store high availability is that no replication occurs
                    between the live and backup nodes, this means it does not suffer any performance
                    penalties due to the overhead of replication during normal operation.</p><p>The disadvantage of shared store replication is that it requires a shared file
                    system, and when the backup server activates it needs to load the journal from
                    the shared store which can take some time depending on the amount of data in the
                    store.</p><p>If you require the highest performance during normal operation, have access to
                    a fast SAN, and can live with a slightly slower failover (depending on amount of
                    data), we recommend shared store high availability</p><div align="center"><img src="images/ha-shared-store.png" align="middle"></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="ha/mode.shared.configuration"></a>39.1.1.2.1.&nbsp;Configuration</h5></div></div><div></div></div><p>To configure the live and backup server to share their store, configure
                        both <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">
                   &lt;shared-store&gt;true&lt;shared-store&gt;
                </pre><p>Additionally, the backup server must be flagged explicitly as a
                        backup:</p><pre class="programlisting">
                   &lt;backup&gt;true&lt;/backup&gt;
                     </pre><p>In order for live - backup pairs to operate properly with a shared store,
                        both servers must have configured the location of journal directory to point
                        to the <span class="emphasis"><em>same shared location</em></span> (as explained in <a href="#configuring.message.journal" title="15.3.&nbsp;Configuring the message journal">Section&nbsp;15.3, &#8220;Configuring the message journal&#8221;</a>)</p><p>If clients will use automatic failover with JMS, the live server will need
                        to configure a connector to the backup server and reference it from its
                            <tt class="literal">hornetq-jms.xml</tt> configuration as explained in <a href="#ha.automatic.failover" title="39.2.1.&nbsp;Automatic Client Failover">Section&nbsp;39.2.1, &#8220;Automatic Client Failover&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e10316"></a>39.1.1.2.2.&nbsp;Synchronizing a Backup Node to a Live Node</h5></div></div><div></div></div><p>As both live and backup servers share the same journal, they do not need
                        to be synchronized. However until, both live and backup servers are up and
                        running, high-availability can not be provided with a single server. After
                        failover, at first opportunity, stop the backup server (which is active) and
                        restart the live and backup servers.</p><p>In the next release of HornetQ we will provide functionality to
                        automatically synchronize a new backup server with a running live server
                        without having to temporarily bring the live server down.</p></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="failover"></a>39.2.&nbsp;Failover Modes</h2></div></div><div></div></div><p>HornetQ defines two types of client failover:</p><div class="itemizedlist"><ul type="disc"><li><p>Automatic client failover</p></li><li><p>Application-level client failover</p></li></ul></div><p>HornetQ also provides 100% transparent automatic reattachment of connections to the
            same server (e.g. in case of transient network problems). This is similar to failover,
            except it's reconnecting to the same server and is discussed in <a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">Chapter&nbsp;34, <i>Client Reconnection and Session Reattachment</i></a></p><p>During failover, if the client has consumers on any non persistent or temporary
            queues, those queues will be automatically recreated during failover on the backup node,
            since the backup node will not have any knowledge of non persistent queues.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ha.automatic.failover"></a>39.2.1.&nbsp;Automatic Client Failover</h3></div></div><div></div></div><p>HornetQ clients can be configured with knowledge of live and backup servers, so
                that in event of connection failure at the client - live server connection, the
                client will detect this and reconnect to the backup server. The backup server will
                then automatically recreate any sessions and consumers that existed on each
                connection before failover, thus saving the user from having to hand-code manual
                reconnection logic.</p><p>HornetQ clients detect connection failure when it has not received packets from
                the server within the time given by <tt class="literal">client-failure-check-period</tt>
                as explained in section <a href="#connection-ttl" title="Chapter&nbsp;17.&nbsp;Detecting Dead Connections">Chapter&nbsp;17, <i>Detecting Dead Connections</i></a>. If the client does not
                receive data in good time, it will assume the connection has failed and attempt
                failover.</p><p>HornetQ clients can be configured with the list of live-backup server pairs in a
                number of different ways. They can be configured explicitly or probably the most
                common way of doing this is to use <span class="emphasis"><em>server discovery</em></span> for the
                client to automatically discover the list. For full details on how to configure
                server discovery, please see <a href="#clusters.server-discovery" title="38.2.&nbsp;Server discovery">Section&nbsp;38.2, &#8220;Server discovery&#8221;</a>.
                Alternatively, the clients can explicitly specifies pairs of live-backup server as
                explained in <a href="#clusters.static.servers" title="38.5.2.&nbsp;Specifying List of Servers to form a Cluster">Section&nbsp;38.5.2, &#8220;Specifying List of Servers to form a Cluster&#8221;</a>.</p><p>To enable automatic client failover, the client must be configured to allow
                non-zero reconnection attempts (as explained in <a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">Chapter&nbsp;34, <i>Client Reconnection and Session Reattachment</i></a>).</p><p>Sometimes you want a client to failover onto a backup server even if the live
                server is just cleanly shutdown rather than having crashed or the connection failed.
                To configure this you can set the property <tt class="literal">FailoverOnServerShutdown</tt> to true either on the <tt class="literal">HornetQConnectionFactory</tt> if you're using JMS or in the <tt class="literal">hornetq-jms.xml (failover-on-server-shutdown property)</tt> file when you
                define the connection factory, or if using core by setting the property directly on
                the <tt class="literal">ClientSessionFactoryImpl</tt> instance after creation. The default
                value for this property is <tt class="literal">false</tt>, this means that by default
                    <span class="emphasis"><em>HornetQ clients will not failover to a backup server if the live
                    server is simply shutdown cleanly.</em></span></p><p>
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>By default, cleanly shutting down the server <span class="bold"><b>will
                            not</b></span> trigger failover on the client.</p><p>Using CTRL-C on a HornetQ server or JBoss AS instance causes the server to
                            <span class="bold"><b>cleanly shut down</b></span>, so will not trigger
                        failover on the client. </p><p>If you want the client to failover when its server is cleanly shutdown
                        then you must set the property <tt class="literal">FailoverOnServerShutdown</tt>
                        to true</p></div><p>
            </p><p>By default failover will only occur after at least one connection has been made to
                the live server. In other words, by default, failover will not occur if the client
                fails to make an initial connection to the live server - in this case it will simply
                retry connecting to the live server according to the reconnect-attempts property and
                fail after this number of attempts.</p><p>In some cases, you may want the client to automatically try the backup server it
                fails to make an initial connection to the live server. In this case you can set the
                property <tt class="literal">FailoverOnInitialConnection</tt>, or <tt class="literal">failover-on-initial-connection</tt> in xml, on the <tt class="literal">ClientSessionFactoryImpl</tt> or <tt class="literal">HornetQConnectionFactory</tt>. The default value for this parameter is
                    <tt class="literal">false</tt>. </p><p>For examples of automatic failover with transacted and non-transacted JMS
                sessions, please see <a href="#examples.transaction-failover" title="11.1.57.&nbsp;Transaction Failover With Data Replication">Section&nbsp;11.1.57, &#8220;Transaction Failover With Data Replication&#8221;</a> and <a href="#examples.non-transaction-failover" title="11.1.33.&nbsp;Non-Transaction Failover With Server Data Replication">Section&nbsp;11.1.33, &#8220;Non-Transaction Failover With Server Data Replication&#8221;</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="ha.automatic.failover.noteonreplication"></a>39.2.1.1.&nbsp;A Note on Server Replication</h4></div></div><div></div></div><p>HornetQ does not replicate full server state between live and backup servers.
                    When the new session is automatically recreated on the backup it won't have any
                    knowledge of messages already sent or acknowledged in that session. Any
                    in-flight sends or acknowledgements at the time of failover might also be
                    lost.</p><p>By replicating full server state, theoretically we could provide a 100%
                    transparent seamless failover, which would avoid any lost messages or
                    acknowledgements, however this comes at a great cost: replicating the full
                    server state (including the queues, session, etc.). This would require
                    replication of the entire server state machine; every operation on the live
                    server would have to replicated on the replica server(s) in the exact same
                    global order to ensure a consistent replica state. This is extremely hard to do
                    in a performant and scalable way, especially when one considers that multiple
                    threads are changing the live server state concurrently.</p><p>It is possible to provide full state machine replication using techniques such
                    as <span class="italic">virtual synchrony</span>, but this does not scale
                    well and effectively serializes all operations to a single thread, dramatically
                    reducing concurrency.</p><p>Other techniques for multi-threaded active replication exist such as
                    replicating lock states or replicating thread scheduling but this is very hard
                    to achieve at a Java level.</p><p>Consequently it has decided it was not worth massively reducing performance
                    and concurrency for the sake of 100% transparent failover. Even without 100%
                    transparent failover, it is simple to guarantee <span class="italic">once and
                        only once</span> delivery, even in the case of failure, by using a
                    combination of duplicate detection and retrying of transactions. However this is
                    not 100% transparent to the client code.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="ha.automatic.failover.blockingcalls"></a>39.2.1.2.&nbsp;Handling Blocking Calls During Failover</h4></div></div><div></div></div><p>If the client code is in a blocking call to the server, waiting for a response
                    to continue its execution, when failover occurs, the new session will not have
                    any knowledge of the call that was in progress. This call might otherwise hang
                    for ever, waiting for a response that will never come.</p><p>To prevent this, HornetQ will unblock any blocking calls that were in progress
                    at the time of failover by making them throw a <tt class="literal">javax.jms.JMSException</tt> (if using JMS), or a <tt class="literal">HornetQException</tt> with error code <tt class="literal">HornetQException.UNBLOCKED</tt>. It is up to the client code to catch
                    this exception and retry any operations if desired.</p><p>If the method being unblocked is a call to commit(), or prepare(), then the
                    transaction will be automatically rolled back and HornetQ will throw a <tt class="literal">javax.jms.TransactionRolledBackException</tt> (if using JMS), or a
                        <tt class="literal">HornetQException</tt> with error code <tt class="literal">HornetQException.TRANSACTION_ROLLED_BACK</tt> if using the core
                    API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="ha.automatic.failover.transactions"></a>39.2.1.3.&nbsp;Handling Failover With Transactions</h4></div></div><div></div></div><p>If the session is transactional and messages have already been sent or
                    acknowledged in the current transaction, then the server cannot be sure that
                    messages sent or acknowledgements have not been lost during the failover.</p><p>Consequently the transaction will be marked as rollback-only, and any
                    subsequent attempt to commit it will throw a <tt class="literal">javax.jms.TransactionRolledBackException</tt> (if using JMS), or a
                        <tt class="literal">HornetQException</tt> with error code <tt class="literal">HornetQException.TRANSACTION_ROLLED_BACK</tt> if using the core
                    API.</p><p>It is up to the user to catch the exception, and perform any client side local
                    rollback code as necessary. There is no need to manually rollback the session -
                    it is already rolled back. The user can then just retry the transactional
                    operations again on the same session.</p><p>HornetQ ships with a fully functioning example demonstrating how to do this,
                    please see <a href="#examples.transaction-failover" title="11.1.57.&nbsp;Transaction Failover With Data Replication">Section&nbsp;11.1.57, &#8220;Transaction Failover With Data Replication&#8221;</a></p><p>If failover occurs when a commit call is being executed, the server, as
                    previously described, will unblock the call to prevent a hang, since no response
                    will come back. In this case it is not easy for the client to determine whether
                    the transaction commit was actually processed on the live server before failure
                    occurred.</p><p>To remedy this, the client can simply enable duplicate detection (<a href="#duplicate-detection" title="Chapter&nbsp;37.&nbsp;Duplicate Message Detection">Chapter&nbsp;37, <i>Duplicate Message Detection</i></a>) in the transaction, and retry the
                    transaction operations again after the call is unblocked. If the transaction had
                    indeed been committed on the live server successfully before failover, then when
                    the transaction is retried, duplicate detection will ensure that any durable
                    messages resent in the transaction will be ignored on the server to prevent them
                    getting sent more than once.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>By catching the rollback exceptions and retrying, catching unblocked calls
                        and enabling duplicate detection, once and only once delivery guarantees for
                        messages can be provided in the case of failure, guaranteeing 100% no loss
                        or duplication of messages.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="ha.automatic.failover.nontransactional"></a>39.2.1.4.&nbsp;Handling Failover With Non Transactional Sessions</h4></div></div><div></div></div><p>If the session is non transactional, messages or acknowledgements can be lost
                    in the event of failover.</p><p>If you wish to provide <span class="italic">once and only once</span>
                    delivery guarantees for non transacted sessions too, enabled duplicate
                    detection, and catch unblock exceptions as described in <a href="#ha.automatic.failover.blockingcalls" title="39.2.1.2.&nbsp;Handling Blocking Calls During Failover">Section&nbsp;39.2.1.2, &#8220;Handling Blocking Calls During Failover&#8221;</a></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10515"></a>39.2.2.&nbsp;Getting Notified of Connection Failure</h3></div></div><div></div></div><p>JMS provides a standard mechanism for getting notified asynchronously of
                connection failure: <tt class="literal">java.jms.ExceptionListener</tt>. Please consult
                the JMS javadoc or any good JMS tutorial for more information on how to use
                this.</p><p>The HornetQ core API also provides a similar feature in the form of the class
                    <tt class="literal">org.hornet.core.client.SessionFailureListener</tt></p><p>Any ExceptionListener or SessionFailureListener instance will always be called by
                HornetQ on event of connection failure, <span class="bold"><b>irrespective</b></span> of whether the connection was successfully failed over,
                reconnected or reattached.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10532"></a>39.2.3.&nbsp;Application-Level Failover</h3></div></div><div></div></div><p>In some cases you may not want automatic client failover, and prefer to handle any
                connection failure yourself, and code your own manually reconnection logic in your
                own failure handler. We define this as <span class="emphasis"><em>application-level</em></span>
                failover, since the failover is handled at the user application level.</p><p>To implement application-level failover, if you're using JMS then you need to set
                an <tt class="literal">ExceptionListener</tt> class on the JMS connection. The <tt class="literal">ExceptionListener</tt> will be called by HornetQ in the event that
                connection failure is detected. In your <tt class="literal">ExceptionListener</tt>, you
                would close your old JMS connections, potentially look up new connection factory
                instances from JNDI and creating new connections. In this case you may well be using
                    <a href="http://www.jboss.org/community/wiki/JBossHAJNDIImpl" target="_top">HA-JNDI</a>
                to ensure that the new connection factory is looked up from a different
                server.</p><p>For a working example of application-level failover, please see <a href="#application-level-failover" title="11.1.1.&nbsp;Application-Layer Failover">Section&nbsp;11.1.1, &#8220;Application-Layer Failover&#8221;</a>.</p><p>If you are using the core API, then the procedure is very similar: you would set a
                    <tt class="literal">FailureListener</tt> on the core <tt class="literal">ClientSession</tt>
                instances.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="libaio"></a>Chapter&nbsp;40.&nbsp;Libaio Native Libraries</h2></div></div><div></div></div><p>HornetQ distributes a native library, used as a bridge between HornetQ and linux
        libaio.</p><p><tt class="literal">libaio</tt> is a library, developed as part of the linux kernel project.
        With <tt class="literal">libaio</tt> we submit writes to the operating system where they are
        processed asynchronously. Some time later the OS will call our code back when they have been
        processed.</p><p>We use this in our high performance journal if configured to do so, please see <a href="#persistence" title="Chapter&nbsp;15.&nbsp;Persistence">Chapter&nbsp;15, <i>Persistence</i></a>.</p><p>These are the native libraries distributed by HornetQ:</p><div class="itemizedlist"><ul type="disc"><li><p>libHornetQAIO32.so - x86 32 bits</p></li><li><p>libHornetQAIO64.so - x86 64 bits</p></li></ul></div><p>When using libaio, HornetQ will always try loading these files as long as they are on the
            <a href="#using-server.library.path" title="6.4.&nbsp;Library Path">library path</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10613"></a>40.1.&nbsp;Compiling the native libraries</h2></div></div><div></div></div><p>In the case that you are using Linux on a platform other than x86_32 or x86_64
            (for example Itanium 64 bits or IBM Power) you may need to compile the native library, since we
            do not distribute binaries for those platforms with the release.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10618"></a>40.1.1.&nbsp;Install requirements</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>At the moment the native layer is only available on Linux. If you are in a
                    platform other than Linux the native compilation will not work</p></div><p>The native library uses <a href="http://en.wikipedia.org/wiki/Autoconf" target="_top">autoconf</a> what makes the compilation process easy, however you need to
                install extra packages as a requirement for compilation:</p><div class="itemizedlist"><ul type="disc"><li><p>gcc - C Compiler</p></li><li><p>gcc-c++ or g++ - Extension to gcc with support for C++</p></li><li><p>autoconf - Tool for automating native build process</p></li><li><p>make - Plain old make</p></li><li><p>automake - Tool for automating make generation</p></li><li><p>libtool - Tool for link editing native libraries</p></li><li><p>libaio - library to disk asynchronous IO kernel functions</p></li><li><p>libaio-dev - Compilation support for libaio</p></li><li><p>A full JDK installed with the environment variable JAVA_HOME set to its
                        location</p></li></ul></div><p>To perform this installation on RHEL or Fedora, you can simply type this at a
                command line:</p><pre class="programlisting">sudo yum install automake libtool autoconf gcc-g++ gcc libaio libaio-dev make</pre><p>Or on debian systems:</p><pre class="programlisting">sudo apt-get install automake libtool autoconf gcc-g++ gcc libaio libaio-dev make</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>You could find a slight variation of the package names depending on the
                    version and linux distribution. (for example gcc-c++ on Fedora versus g++ on
                    Debian systems)</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10668"></a>40.1.2.&nbsp;Invoking the compilation</h3></div></div><div></div></div><p>In the distribution, in the <tt class="literal">native-src</tt> directory, execute the
                shell script <tt class="literal">bootstrap</tt>. This script will invoke <tt class="literal">automake</tt> and <tt class="literal">make</tt> what will create all the make
                files and the native library.</p><pre class="programlisting">someUser@someBox:/messaging-distribution/native-src$ ./bootstrap 
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p

...

configure: creating ./config.status
config.status: creating Makefile
config.status: creating ./src/Makefile
config.status: creating config.h
config.status: config.h is unchanged
config.status: executing depfiles commands
config.status: executing libtool commands

...</pre><p>The produced library will be at <tt class="literal">./native-src/src/.libs/libHornetQAIO.so</tt>. Simply move that file over
                    <tt class="literal">bin</tt> on the distribution or the place you have chosen on the
                    <a href="#using-server.library.path" title="6.4.&nbsp;Library Path">library path</a>.</p><p>If you want to perform changes on the HornetQ libaio code, you could just call
                make directly at the <tt class="literal">native-src</tt> directory.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="thread-pooling"></a>Chapter&nbsp;41.&nbsp;Thread management</h2></div></div><div></div></div><p>This chapter describes how HornetQ uses and pools threads and how you can manage
        them.</p><p>First we'll discuss how threads are managed and used on the server side, then we'll look
        at the client side.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10727"></a>41.1.&nbsp;Server-Side Thread Management</h2></div></div><div></div></div><p>Each HornetQ Server maintains a single thread pool for general use, and a scheduled
            thread pool for scheduled use. A Java scheduled thread pool cannot be configured to use
            a standard thread pool, otherwise we could use a single thread pool for both scheduled
            and non scheduled activity.</p><p>When using old (blocking) IO, a separate thread pool is also used to service
            connections. Since old IO requires a thread per connection it does not make sense to get
            them from the standard pool as the pool will easily get exhausted if too many
            connections are made, resulting in the server "hanging" since it has no remaining
            threads to do anything else. If you require the server to handle many concurrent
            connections you should make sure you use NIO, not old IO.</p><p>When using new IO (NIO), HornetQ will, by default, use a number of threads equal to
            three times the number of cores (or hyper-threads) as reported by
            Runtime.getRuntime().availableProcessors() for processing incoming packets. If you want
            to override this value, you can set the number of threads by specifying the parameter
                <tt class="literal">nio-remoting-threads</tt> in the transport configuration. See the
                <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a> for more information on this.</p><p>There are also a small number of other places where threads are used directly, we'll
            discuss each in turn.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="server.scheduled.thread.pool"></a>41.1.1.&nbsp;Server Scheduled Thread Pool</h3></div></div><div></div></div><p>The server scheduled thread pool is used for most activities on the server side
                that require running periodically or with delays. It maps internally to a <tt class="literal">java.util.concurrent.ScheduledThreadPoolExecutor</tt> instance.</p><p>The maximum number of thread used by this pool is configure in <tt class="literal">hornetq-configuration.xml</tt> with the <tt class="literal">scheduled-thread-pool-max-size</tt> parameter. The default value is
                    <tt class="literal">5</tt> threads. A small number of threads is usually sufficient
                for this pool.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10762"></a>41.1.2.&nbsp;General Purpose Server Thread Pool</h3></div></div><div></div></div><p>This general purpose thread pool is used for most asynchronous actions on the
                server side. It maps internally to a <tt class="literal">java.util.concurrent.ThreadPoolExecutor</tt> instance.</p><p>The maximum number of thread used by this pool is configure in <tt class="literal">hornetq-configuration.xml</tt> with the <tt class="literal">thread-pool-max-size</tt> parameter.</p><p>If a value of <tt class="literal">-1</tt> is used this signifies that the thread pool
                has no upper bound and new threads will be created on demand if there are not enough
                threads available to satisfy a request. If activity later subsides then threads are
                timed-out and closed.</p><p>If a value of <tt class="literal">n</tt> where <tt class="literal">n</tt>is a positive integer
                greater than zero is used this signifies that the thread pool is bounded. If more
                requests come in and there are no free threads in the pool and the pool is full then
                requests will block until a thread becomes available. It is recommended that a
                bounded thread pool is used with caution since it can lead to dead-lock situations
                if the upper bound is chosen to be too low.</p><p>The default value for <tt class="literal">thread-pool-max-size</tt> is <tt class="literal">30</tt>.</p><p>See the <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadPoolExecutor.html" target="_top">J2SE javadoc</a> for more information on unbounded (cached), and bounded
                (fixed) thread pools.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10804"></a>41.1.3.&nbsp;Expiry Reaper Thread</h3></div></div><div></div></div><p>A single thread is also used on the server side to scan for expired messages in
                queues. We cannot use either of the thread pools for this since this thread needs to
                run at its own configurable priority.</p><p>For more information on configuring the reaper, please see <a href="#message-expiry" title="Chapter&nbsp;22.&nbsp;Message Expiry">Chapter&nbsp;22, <i>Message Expiry</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10813"></a>41.1.4.&nbsp;Asynchronous IO</h3></div></div><div></div></div><p>Asynchronous IO has a thread pool for receiving and dispatching events out of the
                native layer. You will find it on a thread dump with the prefix
                HornetQ-AIO-poller-pool. HornetQ uses one thread per opened file on the journal
                (there is usually one).</p><p>There is also a single thread used to invoke writes on libaio. We do that to avoid
                context switching on libaio that would cause performance issues. You will find this
                thread on a thread dump with the prefix HornetQ-AIO-writer-pool.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="thread-pooling.client.side"></a>41.2.&nbsp;Client-Side Thread Management</h2></div></div><div></div></div><p>On the client side, HornetQ maintains a single static scheduled thread pool and a
            single static general thread pool for use by all clients using the same classloader in
            that JVM instance.</p><p>The static scheduled thread pool has a maximum size of <tt class="literal">5</tt> threads,
            and the general purpose thread pool has an unbounded maximum size.</p><p>If required HornetQ can also be configured so that each <tt class="literal">ClientSessionFactory</tt> instance does not use these static pools but instead
            maintains its own scheduled and general purpose pool. Any sessions created from that
                <tt class="literal">ClientSessionFactory</tt> will use those pools instead.</p><p>To configure a <tt class="literal">ClientSessionFactory</tt> instance to use its own pools,
            simply use the appropriate setter methods immediately after creation, for
            example:</p><pre class="programlisting">ClientSessionFactory myFactory = HornetQClient.createClientSessionFactory(...);
myFactory.setUseGlobalPools(false);
myFactory.setScheduledThreadPoolMaxSize(10);
myFactory.setThreadPoolMaxSize(-1);   </pre><p>If you're using the JMS API, you can set the same parameters on the
            ClientSessionFactory and use it to create the <tt class="literal">ConnectionFactory</tt>
            instance, for example:</p><pre class="programlisting">ConnectionFactory myConnectionFactory = HornetQJMSClient.createConnectionFactory(myFactory);     </pre><p>If you're using JNDI to instantiate <tt class="literal">HornetQConnectionFactory</tt>
            instances, you can also set these parameters in the <tt class="literal">hornetq-jms.xml</tt>
            file where you describe your connection factory, for example:</p><pre class="programlisting">&lt;connection-factory name="ConnectionFactory"&gt;
    &lt;connectors&gt;
       &lt;connector-ref connector-name="netty"/&gt;
    &lt;/connectors&gt;
    &lt;entries&gt;
        &lt;entry name="ConnectionFactory"/&gt;
        &lt;entry name="XAConnectionFactory"/&gt;
    &lt;/entries&gt;
    &lt;use-global-pools&gt;false&lt;/use-global-pools&gt;
    &lt;scheduled-thread-pool-max-size&gt;10&lt;/scheduled-thread-pool-max-size&gt;
    &lt;thread-pool-max-size&gt;-1&lt;/thread-pool-max-size&gt;
&lt;/connection-factory&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="logging"></a>Chapter&nbsp;42.&nbsp;Logging</h2></div></div><div></div></div><p>HornetQ has its own logging delegate that has no dependencies on any particular logging
        framework. The default delegate delegates all its logs to the standard <a href="http://java.sun.com/j2se/1.4.2/docs/guide/util/logging/" target="_top">JDK logging</a>,
        (a.k.a Java-Util-Logging: JUL). By default the server picks up its JUL configuration from a
            <tt class="literal">logging.properties</tt> file found in the config directories. This is
        configured to use our own HornetQ logging formatter and will log to the console as well as a
        log file. For more information on configuring JUL visit Suns website.</p><p>You can configure a different Logging Delegate programatically or via a System
        Property.</p><p>To do this programatically simply do the
        following</p><pre class="programlisting">org.hornetq.core.logging.Logger.setDelegateFactory(new Log4jLogDelegateFactory())</pre><p>Where <tt class="literal">Log4jLogDelegateFactory</tt> is the implementation of <tt class="literal">org.hornetq.spi.core.logging.LogDelegateFactory </tt>that you would like to
        use.</p><p>To do this via a System Property simply set the property <tt class="literal">org.hornetq.logger-delegate-factory-class-name</tt> to the delegate factory being
        used,
        i.e.</p><pre class="programlisting">-Dorg.hornetq.logger-delegate-factory-class-name=org.hornetq.integration.logging.Log4jLogDelegateFactory</pre><p>As you can see in the above example HornetQ provides some Delegate Factories for your
        convenience. these are</p><div class="orderedlist"><ol type="1"><li><p>org.hornetq.core.logging.impl.JULLogDelegateFactory - the
                    default that uses
                    JUL.</p></li><li><p>org.hornetq.integration.logging.Log4jLogDelegateFactory
                    - which uses Log4J</p></li></ol></div><p>If you configure your client's logging to use the JUL delegate, make sure you provide a
            <tt class="literal">logging.properties</tt> file and set the <tt class="literal">java.util.logging.config.file</tt> property on client startup</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10928"></a>42.1.&nbsp;Logging With The JBoss Application Server</h2></div></div><div></div></div><p>When HornetQ is deployed within the JBoss Application Server version 5.x or above then
            it will still use JUL however the logging is redirected to the default JBoss logger. For
            more information on this refer to the JBoss documentation. In versions before this you
            must specify what logger delegate you want to use.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="embedding-hornetq"></a>Chapter&nbsp;43.&nbsp;Embedding HornetQ</h2></div></div><div></div></div><p>HornetQ is designed as set of simple Plain Old Java Objects (POJOs). This means HornetQ
        can be instantiated and run in any dependency injection framework such as JBoss
        Microcontainer, Spring or Google Guice. It also means that if you have an application that
        could use messaging functionality internally, then it can <span class="emphasis"><em>directly
            instantiate</em></span> HornetQ clients and servers in its own application code to
        perform that functionality. We call this <span class="emphasis"><em>embedding</em></span> HornetQ.</p><p>Examples of applications that might want to do this include any application that needs
        very high performance, transactional, persistent messaging but doesn't want the hassle of
        writing it all from scratch.</p><p>Embedding HornetQ can be done in very few easy steps. Instantiate the configuration
        object, instantiate the server, start it, and you have a HornetQ running in your virtual
        machine. It's as simple and easy as that.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10965"></a>43.1.&nbsp;POJO instantiation</h2></div></div><div></div></div><p>You can follow this step-by-step guide:</p><p>Create the configuration object - this contains configuration information for a
            HornetQ. If you want to configure it from a file on the classpath, use <tt class="literal">FileConfigurationImpl</tt></p><pre class="programlisting">import org.hornetq.core.config.Configuration;
import org.hornetq.core.config.impl.FileConfiguration;

...


Configuration config = new FileConfiguration();
config.setConfigurationUrl(urlToYourconfigfile);
config.start();</pre><p>If you don't need to support a configuration file, just use <tt class="literal">ConfigurationImpl</tt> and change the config parameters accordingly, such as
            adding acceptors. </p><p>The acceptors are configured through <tt class="literal">ConfigurationImpl</tt>. Just add
            the <tt class="literal">NettyAcceptorFactory</tt> on the transports the same way you would
            through the main configuration file.</p><pre class="programlisting">import org.hornetq.core.config.Configuration;
import org.hornetq.core.config.impl.ConfigurationImpl;

...

Configuration config = new ConfigurationImpl();
HashSet&lt;TransportConfiguration&gt; transports = new HashSet&lt;TransportConfiguration&gt;();
      
transports.add(new TransportConfiguration(NettyAcceptorFactory.class.getName()));
transports.add(new TransportConfiguration(InVMAcceptorFactory.class.getName()));

config.setAcceptorConfigurations(transports);</pre><p>You need to instantiate and start HornetQ server. The class <tt class="literal">org.hornetq.api.core.server.HornetQ</tt> has a few static methods for creating
            servers with common configurations.</p><pre class="programlisting">import org.hornetq.api.core.server.HornetQ;
import org.hornetq.core.server.HornetQServer;

...

HornetQServer server = HornetQ.newHornetQServer(config);

server.start();</pre><p>You also have the option of instantiating <tt class="literal">HornetQServerImpl</tt>
            directly:</p><pre class="programlisting">HornetQServer server = 
        new HornetQServerImpl(config);
server.start();</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11005"></a>43.2.&nbsp;Dependency Frameworks</h2></div></div><div></div></div><p>You may also choose to use a dependency injection framework such as <span class="trademark">JBoss
                Micro Container</span>&#8482; or <span class="trademark">Spring Framework</span>&#8482;.</p><p>HornetQ standalone uses JBoss Micro Container as the injection framework. <tt class="literal">HornetQBootstrapServer</tt> and <tt class="literal">hornetq-beans.xml</tt> which are
            part of the HornetQ distribution provide a very complete implementation of what's needed
            to bootstrap the server using JBoss Micro Container. </p><p>When using JBoss Micro Container, you need to provide an XML file declaring the
                <tt class="literal">HornetQServer</tt> and <tt class="literal">Configuration</tt> object, you
            can also inject a security manager and a MBean server if you want, but those are
            optional.</p><p>A very basic XML Bean declaration for the JBoss Micro Container would be:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;
   
   &lt;!-- The core configuration --&gt;
   &lt;bean name="Configuration" 
         class="org.hornetq.core.config.impl.FileConfiguration"&gt;
   &lt;/bean&gt;

   	&lt;!-- The core server --&gt;
   &lt;bean name="HornetQServer" 
         class="org.hornetq.core.server.impl.HornetQServerImpl"&gt;      
      &lt;constructor&gt;
         &lt;parameter&gt;
            &lt;inject bean="Configuration"/&gt;
         &lt;/parameter&gt;            
      &lt;/constructor&gt;         
   &lt;/bean&gt;
   &lt;/deployment&gt;</pre><p><tt class="literal">HornetQBootstrapServer</tt> provides an easy encapsulation of JBoss
            Micro Container.</p><pre class="programlisting">HornetQBootstrapServer bootStrap = 
        new HornetQBootstrapServer(new String[] {"hornetq-beans.xml"});
        bootStrap.run();</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11042"></a>43.3.&nbsp;Connecting to the Embedded HornetQ</h2></div></div><div></div></div><p>To connect clients to HornetQ you just create the factories as normal:</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11047"></a>43.3.1.&nbsp;Core API</h3></div></div><div></div></div><p>If using the core API, just create the <tt class="literal">ClientSessionFactory</tt> and
                use the regular core API.</p><pre class="programlisting">ClientSessionFactory nettyFactory =  HornetQClient.createClientSessionFactory(
                                        new TransportConfiguration(
                                           InVMConnectorFactory.class.getName()));

ClientSession session = factory.createSession();

session.createQueue("example", "example", true);

ClientProducer producer = session.createProducer("example");

ClientMessage message = session.createMessage(true);

message.getBody().writeString("Hello");

producer.send(message);

session.start();

ClientConsumer consumer = session.createConsumer("example");

ClientMessage msgReceived = consumer.receive();

System.out.println("message = " + msgReceived.getBody().readString());

session.close();</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11057"></a>43.3.2.&nbsp;JMS API</h3></div></div><div></div></div><p>Connection on an Embedded HornetQ through JMS is also simple. Just instantiate
                    <tt class="literal">ConnectionFactory</tt> directly. The following example
                illustrates that.</p><pre class="programlisting">ConnectionFactory cf =
    HornetQJMSClient.createConnectionFactory(
       new TransportConfiguration(InVMConnectorFactory.class.getName()));

Connection conn = cf.createConnection();

conn.start();

Session sess = conn.createSession(true, Session.SESSION_TRANSACTED);

MessageProducer prod = sess.createProducer(queue);

TextMessage msg = sess.createTextMessage("Hello!");

prod.send(msg);

sess.commit();

MessageConsumer consumer = sess.createConsumer(queue);

TextMessage txtmsg = (TextMessage)consumer.receive();

System.out.println("Msg = " + txtmsg.getText());

sess.commit();

conn.close();</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11067"></a>43.4.&nbsp;JMS Embedding Example</h2></div></div><div></div></div><p>Please see <a href="#examples.embedded" title="11.2.1.&nbsp;Embedded">Section&nbsp;11.2.1, &#8220;Embedded&#8221;</a> for an example which shows how to setup
            and run HornetQ embedded with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="intercepting-operations"></a>Chapter&nbsp;44.&nbsp;Intercepting Operations</h2></div></div><div></div></div><p>HornetQ supports <span class="emphasis"><em>interceptors</em></span> to intercept packets entering
       the server. Any supplied interceptors would be called for any packet entering 
        the server, this allows custom code to be executed, e.g. for auditing packets,
      filtering or other reasons. Interceptors can change the packets they intercept.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11099"></a>44.1.&nbsp;Implementing The Interceptors</h2></div></div><div></div></div><p>A interceptor must implement the <tt class="literal">Interceptor interface</tt>:</p><pre class="programlisting">
package org.hornetq.api.core.interceptor;

public interface Interceptor
{   
   boolean intercept(Packet packet, RemotingConnection connection) 
                throws HornetQException;
}
         </pre><p>The returned boolean value is important:</p><div class="itemizedlist"><ul type="disc"><li><p>if <tt class="literal">true</tt> is returned, the process continues normally</p></li><li><p>if <tt class="literal">false</tt> is returned, the process is aborted, no other
               interceptors will be called and the packet will not be handled by the server at
               all.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11124"></a>44.2.&nbsp;Configuring The Interceptors</h2></div></div><div></div></div><p>The interceptors are configured in <tt class="literal">hornetq-configuration.xml</tt>:</p><pre class="programlisting">
&lt;remoting-interceptors&gt;
   &lt;class-name&gt;org.hornetq.jms.example.LoginInterceptor&lt;/class-name&gt;
   &lt;class-name&gt;org.hornetq.jms.example.AdditionalPropertyInterceptor&lt;/class-name&gt;
&lt;/remoting-interceptors&gt;
         </pre><p>The interceptors classes (and their dependencies) must be added to the server classpath
         to be properly instantiated and called.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11136"></a>44.3.&nbsp;Interceptors on the Client Side</h2></div></div><div></div></div><p>The interceptors can also be run on the client side to intercept packets
         <span class="emphasis"><em>sent by the server</em></span> by adding the interceptor to the <tt class="code">ClientSessionFactory</tt>
         with the <tt class="code">addInterceptor()</tt> method.</p><p>The interceptors classes (and their dependencies) must be added to the client classpath
         to be properly instantiated and called from the client side.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11152"></a>44.4.&nbsp;Example</h2></div></div><div></div></div><p>See <a href="#examples.interceptor" title="11.1.18.&nbsp;Interceptor">Section&nbsp;11.1.18, &#8220;Interceptor&#8221;</a> for an example which
         shows how to use interceptors to add properties to a message on the server.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="interoperability"></a>Chapter&nbsp;45.&nbsp;Interoperability</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stomp"></a>45.1.&nbsp;Stomp</h2></div></div><div></div></div><p><a href="http://stomp.codehaus.org/" target="_top">Stomp</a> is a text-orientated wire protocol that allows
            Stomp clients to communicate with Stomp Brokers.</p><p><a href="http://stomp.codehaus.org/Clients" target="_top">Stomp clients</a> are available for
        several languages and platforms making it a good choice for interoperability.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="stomp.native"></a>45.1.1.&nbsp;Native Stomp support</h3></div></div><div></div></div><p>HornetQ provides native support for Stomp. To be able to send and receive Stomp messages,
            you must configure a <tt class="literal">NettyAcceptor</tt> with a <tt class="literal">protocol</tt>
            parameter set to <tt class="literal">stomp</tt>:</p><pre class="programlisting">
	&lt;acceptor name="stomp-acceptor"&gt;
		&lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
		&lt;param key="protocol"  value="stomp"/&gt;
		&lt;param key="port"  value="61613"/&gt;
	&lt;/acceptor&gt;
</pre><p>With this configuration, HornetQ will accept Stomp connections on 
            the port <tt class="literal">61613</tt> (which is the default port of the Stomp brokers).</p><p>See the <tt class="literal">stomp</tt> example which shows how to configure a HornetQ server with Stomp.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11216"></a>45.1.1.1.&nbsp;Limitations</h4></div></div><div></div></div><p>Message acknowledgements are not transactional. The ACK frame can not be part of a transaction
              (it will be ignored if its <tt class="literal">transaction</tt> header is set).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11224"></a>45.1.2.&nbsp;Mapping Stomp destinations to HornetQ addresses and queues</h3></div></div><div></div></div><p>Stomp clients deals with <span class="emphasis"><em>destinations</em></span> when sending messages and subscribing.
            Destination names are simply strings which are mapped to some form of destination on the 
            server - how the server translates these is left to the server implementation.</p><p>In HornetQ, these destinations are mapped to <span class="emphasis"><em>addresses</em></span> and <span class="emphasis"><em>queues</em></span>.
            When a Stomp client sends a message (using a <tt class="literal">SEND</tt> frame), the specified destination is mapped
            to an address.
            When a Stomp client subscribes (or unsubscribes) for a destination (using a <tt class="literal">SUBSCRIBE</tt>
            or <tt class="literal">UNSUBSCRIBE</tt> frame), the destination is mapped to a HornetQ queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11249"></a>45.1.3.&nbsp;Stomp and JMS interoperabilty</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11252"></a>45.1.3.1.&nbsp;Using JMS destinations</h4></div></div><div></div></div><p>As explained in <a href="#jms-core-mapping" title="Chapter&nbsp;9.&nbsp;Mapping JMS Concepts to the Core API">Chapter&nbsp;9, <i>Mapping JMS Concepts to the Core API</i></a>, JMS destinations are also mapped to HornetQ addresses and queues.
              If you want to use Stomp to send messages to JMS destinations, the Stomp destinations must follow the same convention:</p><div class="itemizedlist"><ul type="disc"><li><p>send or subscribe to a JMS <span class="emphasis"><em>Queue</em></span> by prepending the queue name by <tt class="literal">jms.queue.</tt>.</p><p>For example, to send a message to the <tt class="literal">orders</tt> JMS Queue, the Stomp client must send the frame:</p><pre class="programlisting">
SEND
destination:jms.queue.orders

hello queue orders
^@
                </pre></li><li><p>send or subscribe to a JMS <span class="emphasis"><em>Topic</em></span> by prepending the topic name by <tt class="literal">jms.topic.</tt>.</p><p>For example to subscribe to the <tt class="literal">stocks</tt> JMS Topic, the Stomp client must send the frame:</p><pre class="programlisting">
SUBSCRIBE
destination:jms.topic.stocks

^@
                </pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11292"></a>45.1.3.2.&nbsp;Send and consuming Stomp message from JMS or HornetQ Core API</h4></div></div><div></div></div><p>Stomp is mainly a text-orientated protocol. To make it simpler to interoperate with JMS and HornetQ Core API, 
               our Stomp implementation checks for presence of the <tt class="literal">content-length</tt> header to decide how to map a Stomp message
               to a JMS Message or a Core message.
             </p><p>If the Stomp message does <span class="emphasis"><em>not</em></span> have a <tt class="literal">content-length</tt> header, it will be mapped to a JMS <span class="emphasis"><em>TextMessage</em></span>
               or a Core message with a <span class="emphasis"><em>single nullable SimpleString in the body buffer</em></span>.</p><p>Alternatively, if the Stomp message <span class="emphasis"><em>has</em></span> a <tt class="literal">content-length</tt> header, 
               it will be mapped to a JMS <span class="emphasis"><em>BytesMessage</em></span>
               or a Core message with a <span class="emphasis"><em>byte[] in the body buffer</em></span>.</p><p>The same logic applies when mapping a JMS message or a Core message to Stomp. A Stomp client can check the presence
                of the <tt class="literal">content-length</tt> header to determine the type of the message body (String or bytes).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="stomp.websockets"></a>45.1.4.&nbsp;Stomp Over Web Sockets</h3></div></div><div></div></div><p>HornetQ also support Stomp over <a href="http://dev.w3.org/html5/websockets/" target="_top">Web Sockets</a>. Modern web browser which support Web Sockets can send and receive
            Stomp messages from HornetQ.</p><p>To enable Stomp over Web Sockets, you must configure a <tt class="literal">NettyAcceptor</tt> with a <tt class="literal">protocol</tt>
            parameter set to <tt class="literal">stomp_ws</tt>:</p><pre class="programlisting">
&lt;acceptor name="stomp-ws-acceptor"&gt;
	&lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
	&lt;param key="protocol" value="stomp_ws"/&gt;
	&lt;param key="port" value="61614"/&gt;
&lt;/acceptor&gt;
         </pre><p>With this configuration, HornetQ will accept Stomp connections over Web Sockets on 
            the port <tt class="literal">61614</tt> with the URL path <tt class="literal">/stomp</tt>.
            Web browser can then connect to <tt class="literal">ws://&lt;server&gt;:61614/stomp</tt> using a Web Socket to send and receive Stomp
            messages.</p><p>A companion JavaScript library to ease client-side development is available from 
            <a href="http://github.com/jmesnil/stomp-websocket" target="_top">GitHub</a> (please see
            its <a href="http://jmesnil.net/stomp-websocket/doc/" target="_top">documentation</a> for a complete description).</p><p>The <tt class="literal">stomp-websockets</tt> example shows how to configure HornetQ server to have web browsers and Java
            applications exchanges messages on a JMS topic.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="stompconnect"></a>45.1.5.&nbsp;StompConnect</h3></div></div><div></div></div><p><a href="http://stomp.codehaus.org/StompConnect" target="_top">StompConnect</a> is a server that
            can act as a Stomp broker and proxy the Stomp protocol to the standard JMS API.
            Consequently, using StompConnect it is possible to turn HornetQ into a Stomp Broker and
            use any of the available stomp clients. These include clients written in C, C++, c# and
            .net etc.</p><p>To run StompConnect first start the HornetQ server and make sure that it is using
            JNDI.</p><p>Stomp requires the file <tt class="literal">jndi.properties</tt> to be available on the
            classpath. This should look something like:</p><pre class="programlisting">java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory
java.naming.provider.url=jnp://localhost:1099
java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces</pre><p>Make sure this file is in the classpath along with the StompConnect jar and the
            HornetQ jars and simply run <tt class="literal">java org.codehaus.stomp.jms.Main</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11399"></a>45.2.&nbsp;REST</h2></div></div><div></div></div><p>REST support coming soon!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11404"></a>45.3.&nbsp;AMQP</h2></div></div><div></div></div><p>AMQP support coming soon!</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="perf-tuning"></a>Chapter&nbsp;46.&nbsp;Performance Tuning</h2></div></div><div></div></div><p>In this chapter we'll discuss how to tune HornetQ for optimum performance.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11431"></a>46.1.&nbsp;Tuning persistence</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Put the message journal on its own physical volume. If the disk is shared with
                    other processes e.g. transaction co-ordinator, database or other journals which
                    are also reading and writing from it, then this may greatly reduce performance
                    since the disk head may be skipping all over the place between the different
                    files. One of the advantages of an append only journal is that disk head
                    movement is minimised - this advantage is destroyed if the disk is shared. If
                    you're using paging or large messages make sure they're ideally put on separate
                    volumes too.</p></li><li><p>Minimum number of journal files. Set <tt class="literal">journal-min-files</tt> to a
                    number of files that would fit your average sustainable rate. If you see new
                    files being created on the journal data directory too often, i.e. lots of data
                    is being persisted, you need to increase the minimal number of files, this way
                    the journal would reuse more files instead of creating new data files.</p></li><li><p>Journal file size. The journal file size should be aligned to the capacity of
                    a cylinder on the disk. The default value 10MiB should be enough on most
                    systems.</p></li><li><p>Use AIO journal. If using Linux, try to keep your journal type as AIO. AIO
                    will scale better than Java NIO.</p></li><li><p>Tune <tt class="literal">journal-buffer-timeout</tt>. The timeout can be increased
                    to increase throughput at the expense of latency.</p></li><li><p>If you're running AIO you might be able to get some better performance by
                    increasing <tt class="literal">journal-max-io</tt>. DO NOT change this parameter if
                    you are running NIO.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11462"></a>46.2.&nbsp;Tuning JMS</h2></div></div><div></div></div><p>There are a few areas where some tweaks can be done if you are using the JMS
            API</p><div class="itemizedlist"><ul type="disc"><li><p>Disable message id. Use the <tt class="literal">setDisableMessageID()</tt> method on
                    the <tt class="literal">MessageProducer</tt> class to disable message ids if you don't
                    need them. This decreases the size of the message and also avoids the overhead
                    of creating a unique ID.</p></li><li><p>Disable message timestamp. Use the <tt class="literal">setDisableMessageTimeStamp()</tt> method on the <tt class="literal">MessageProducer</tt> class to disable message timestamps if you don't
                    need them.</p></li><li><p>Avoid <tt class="literal">ObjectMessage</tt>. <tt class="literal">ObjectMessage</tt> is
                    convenient but it comes at a cost. The body of a <tt class="literal">ObjectMessage</tt> uses Java serialization to serialize it to bytes.
                    The Java serialized form of even small objects is very verbose so takes up a lot
                    of space on the wire, also Java serialization is slow compared to custom
                    marshalling techniques. Only use <tt class="literal">ObjectMessage</tt> if you really
                    can't use one of the other message types, i.e. if you really don't know the type
                    of the payload until run-time.</p></li><li><p>Avoid <tt class="literal">AUTO_ACKNOWLEDGE</tt>. <tt class="literal">AUTO_ACKNOWLEDGE</tt>
                    mode requires an acknowledgement to be sent from the server for each message
                    received on the client, this means more traffic on the network. If you can, use
                        <tt class="literal">DUPS_OK_ACKNOWLEDGE</tt> or use <tt class="literal">CLIENT_ACKNOWLEDGE</tt> or a transacted session and batch up many
                    acknowledgements with one acknowledge/commit. </p></li><li><p>Avoid durable messages. By default JMS messages are durable. If you don't
                    really need durable messages then set them to be non-durable. Durable messages
                    incur a lot more overhead in persisting them to storage.</p></li><li><p>Batch many sends or acknowledgements in a single transaction. HornetQ will
                    only require a network round trip on the commit, not on every send or
                    acknowledgement.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11522"></a>46.3.&nbsp;Other Tunings</h2></div></div><div></div></div><p>There are various other places in HornetQ where we can perform some tuning:</p><div class="itemizedlist"><ul type="disc"><li><p>Use Asynchronous Send Acknowledgements. If you need to send durable messages
                    non transactionally and you need a guarantee that they have reached the server
                    by the time the call to send() returns, don't set durable messages to be sent
                    blocking, instead use asynchronous send acknowledgements to get your
                    acknowledgements of send back in a separate stream, see <a href="#send-guarantees" title="Chapter&nbsp;20.&nbsp;Guarantees of sends and commits">Chapter&nbsp;20, <i>Guarantees of sends and commits</i></a> for more information on this.</p></li><li><p>Use pre-acknowledge mode. With pre-acknowledge mode, messages are acknowledged
                        <tt class="literal">before</tt> they are sent to the client. This reduces the
                    amount of acknowledgement traffic on the wire. For more information on this, see
                        <a href="#pre-acknowledge" title="Chapter&nbsp;29.&nbsp;Pre-Acknowledge Mode">Chapter&nbsp;29, <i>Pre-Acknowledge Mode</i></a>.</p></li><li><p>Disable security. You may get a small performance boost by disabling security
                    by setting the <tt class="literal">security-enabled</tt> parameter to <tt class="literal">false</tt> in <tt class="literal">hornetq-configuration.xml</tt>.</p></li><li><p>Disable persistence. If you don't need message persistence, turn it off
                    altogether by setting <tt class="literal">persistence-enabled</tt> to false in
                        <tt class="literal">hornetq-configuration.xml</tt>.</p></li><li><p>Sync transactions lazily. Setting <tt class="literal">journal-sync-transactional</tt> to <tt class="literal">false</tt> in
                        <tt class="literal">hornetq-configuration.xml</tt> can give you better
                    transactional persistent performance at the expense of some possibility of loss
                    of transactions on failure. See <a href="#send-guarantees" title="Chapter&nbsp;20.&nbsp;Guarantees of sends and commits">Chapter&nbsp;20, <i>Guarantees of sends and commits</i></a> for more
                    information.</p></li><li><p>Sync non transactional lazily. Setting <tt class="literal">journal-sync-non-transactional</tt> to <tt class="literal">false</tt> in
                        <tt class="literal">hornetq-configuration.xml</tt> can give you better
                    non-transactional persistent performance at the expense of some possibility of
                    loss of durable messages on failure. See <a href="#send-guarantees" title="Chapter&nbsp;20.&nbsp;Guarantees of sends and commits">Chapter&nbsp;20, <i>Guarantees of sends and commits</i></a> for
                    more information.</p></li><li><p>Send messages non blocking. Setting <tt class="literal">block-on-durable-send</tt>
                    and <tt class="literal">block-on-non-durable-send</tt> to <tt class="literal">false</tt> in
                        <tt class="literal">hornetq-jms.xml</tt> (if you're using JMS and JNDI) or
                    directly on the ClientSessionFactory. This means you don't have to wait a whole
                    network round trip for every message sent. See <a href="#send-guarantees" title="Chapter&nbsp;20.&nbsp;Guarantees of sends and commits">Chapter&nbsp;20, <i>Guarantees of sends and commits</i></a>
                    for more information.</p></li><li><p>If you have very fast consumers, you can increase consumer-window-size. This
                    effectively disables consumer flow control.</p></li><li><p>Socket NIO vs Socket Old IO. By default HornetQ uses old (blocking) on the
                    server and the client side (see the chapter on configuring transports for more
                    information <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a>). NIO is much more scalable
                    but can give you some latency hit compared to old blocking IO. If you need to be
                    able to service many thousands of connections on the server, then you should
                    make sure you're using NIO on the server. However, if don't expect many
                    thousands of connections on the server you can keep the server acceptors using
                    old IO, and might get a small performance advantage.</p></li><li><p>Use the core API not JMS. Using the JMS API you will have slightly lower
                    performance than using the core API, since all JMS operations need to be
                    translated into core operations before the server can handle them. If using the
                    core API try to use methods that take <tt class="literal">SimpleString</tt> as much as
                    possible. <tt class="literal">SimpleString</tt>, unlike java.lang.String does not
                    require copying before it is written to the wire, so if you re-use <tt class="literal">SimpleString</tt> instances between calls then you can avoid some
                    unnecessary copying.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11627"></a>46.4.&nbsp;Tuning Transport Settings</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>TCP buffer sizes. If you have a fast network and fast machines you may get a
                    performance boost by increasing the TCP send and receive buffer sizes. See the
                        <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a> for more information on this. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> Note that some operating systems like later versions of Linux include TCP
                        auto-tuning and setting TCP buffer sizes manually can prevent auto-tune from
                        working and actually give you worse performance!</p></div></li><li><p>Increase limit on file handles on the server. If you expect a lot of
                    concurrent connections on your servers, or if clients are rapidly opening and
                    closing connections, you should make sure the user running the server has
                    permission to create sufficient file handles.</p><p>This varies from operating system to operating system. On Linux systems you
                    can increase the number of allowable open file handles in the file <tt class="literal">/etc/security/limits.conf</tt> e.g. add the lines
                    </p><pre class="programlisting">
serveruser     soft    nofile  20000
serveruser     hard    nofile  20000                   
                </pre><p>
                    This would allow up to 20000 file handles to be open by the user <tt class="literal">serveruser</tt>. </p></li><li><p>Use <tt class="literal">batch-delay</tt> and set <tt class="literal">direct-deliver</tt>
                    to false for the best throughput for very small messages. HornetQ comes with a
                    preconfigured connector/acceptor pair (<tt class="literal">netty-throughput</tt>) in
                        <tt class="literal">hornetq-configuration.xml</tt> and JMS connection factory
                        (<tt class="literal">ThroughputConnectionFactory</tt>) in <tt class="literal">hornetq-jms.xml</tt>which can be used to give the very best
                    throughput, especially for small messages. See the <a href="#configuring-transports" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a> for more information on this.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11676"></a>46.5.&nbsp;Tuning the VM</h2></div></div><div></div></div><p>We highly recommend you use the latest Java JVM for the best performance. We test
            internally using the Sun JVM, so some of these tunings won't apply to JDKs from other
            providers (e.g. IBM or JRockit)</p><div class="itemizedlist"><ul type="disc"><li><p>Garbage collection. For smooth server operation we recommend using a parallel
                    garbage collection algorithm, e.g. using the JVM argument <tt class="literal">-XX:+UseParallelGC</tt> on Sun JDKs.</p></li><li><p><a name="perf-tuning.memory"></a>Memory settings. Give as much memory as you can to the server. HornetQ can run
                    in low memory by using paging (described in <a href="#paging" title="Chapter&nbsp;24.&nbsp;Paging">Chapter&nbsp;24, <i>Paging</i></a>) but if it
                    can run with all queues in RAM this will improve performance. The amount of
                    memory you require will depend on the size and number of your queues and the
                    size and number of your messages. Use the JVM arguments <tt class="literal">-Xms</tt>
                    and <tt class="literal">-Xmx</tt> to set server available RAM. We recommend setting
                    them to the same high value.</p></li><li><p>Aggressive options. Different JVMs provide different sets of JVM tuning
                    parameters, for the Sun Hotspot JVM the full list of options is available <a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp" target="_top">here</a>. We recommend at least using <tt class="literal">-XX:+AggressiveOpts</tt> and<tt class="literal">
                        -XX:+UseFastAccessorMethods</tt>. You may get some mileage with the
                    other tuning parameters depending on your OS platform and application usage
                    patterns.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11711"></a>46.6.&nbsp;Avoiding Anti-Patterns</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Re-use connections / sessions / consumers / producers. Probably the most
                    common messaging anti-pattern we see is users who create a new
                    connection/session/producer for every message they send or every message they
                    consume. This is a poor use of resources. These objects take time to create and
                    may involve several network round trips. Always re-use them.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Some popular libraries such as the Spring JMS Template are known to use
                        these anti-patterns. If you're using Spring JMS Template and you're getting
                        poor performance you know why. Don't blame HornetQ! The Spring JMS Template
                        can only safely be used in an app server which caches JMS sessions (e.g.
                        using JCA), and only then for sending messages. It cannot be safely be used
                        for synchronously consuming messages, even in an app server. </p></div></li><li><p>Avoid fat messages. Verbose formats such as XML take up a lot of space on the
                    wire and performance will suffer as result. Avoid XML in message bodies if you
                    can.</p></li><li><p>Don't create temporary queues for each request. This common anti-pattern
                    involves the temporary queue request-response pattern. With the temporary queue
                    request-response pattern a message is sent to a target and a reply-to header is
                    set with the address of a local temporary queue. When the recipient receives the
                    message they process it then send back a response to the address specified in
                    the reply-to. A common mistake made with this pattern is to create a new
                    temporary queue on each message sent. This will drastically reduce performance.
                    Instead the temporary queue should be re-used for many requests.</p></li><li><p>Don't use Message-Driven Beans for the sake of it. As soon as you start using
                    MDBs you are greatly increasing the codepath for each message received compared
                    to a straightforward message consumer, since a lot of extra application server
                    code is executed. Ask yourself do you really need MDBs? Can you accomplish the
                    same task using just a normal message consumer?</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration-index"></a>Chapter&nbsp;47.&nbsp;Configuration Reference</h2></div></div><div></div></div><p>This section is a quick index for looking up configuration. Click on the element name to
        go to the specific chapter.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="server.configuration"></a>47.1.&nbsp;Server Configuration</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11755"></a>47.1.1.&nbsp;hornetq-configuration.xml</h3></div></div><div></div></div><p>This is the main core server configuration file.</p><div class="table"><a name="d0e11760"></a><p class="title"><b>Table&nbsp;47.1.&nbsp;Server Configuration</b></p><table summary="Server Configuration" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Element Name</th><th>Element Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><a href="#configuring.live.backup" title="39.1.1.1.1.&nbsp;Configuration">backup</a></td><td>Boolean</td><td>true means that this server is a backup to another node in the
                                cluster</td><td>false</td></tr><tr><td><a href="#configuring.live.backup" title="39.1.1.1.1.&nbsp;Configuration">backup-connector-ref</a></td><td>String</td><td>the name of the remoting connector to connect to the backup
                                node</td><td>&nbsp;</td></tr><tr><td><a href="#configuring.bindings.journal" title="15.1.&nbsp;Configuring the bindings journal">bindings-directory</a></td><td>String</td><td>the directory to store the persisted bindings to</td><td>data/bindings</td></tr><tr><td><a href="#clusters" title="Chapter&nbsp;38.&nbsp;Clusters">clustered</a></td><td>Boolean</td><td>true means that the server is clustered</td><td>false</td></tr><tr><td><a href="#connection-ttl" title="Chapter&nbsp;17.&nbsp;Detecting Dead Connections">connection-ttl-override</a></td><td>Long</td><td>if set, this will override how long (in ms) to keep a connection
                                alive without receiving a ping. </td><td>-1</td></tr><tr><td><a href="#configuring.bindings.journal" title="15.1.&nbsp;Configuring the bindings journal">create-bindings-dir</a></td><td>Boolean</td><td>true means that the server will create the bindings directory on
                                start up</td><td>true</td></tr><tr><td><a href="#configuring.message.journal.create-journal-dir">create-journal-dir</a></td><td>Boolean</td><td>true means that the journal directory will be created</td><td>true</td></tr></tbody></table></div><p></p><p></p><p>Continued..</p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><a href="#using-server.configuration" title="6.6.&nbsp;Configuration files">file-deployment-enabled</a></td><td>Boolean</td><td>true means that the server will load configuration from the
                                configuration files</td><td>true</td></tr><tr><td><a href="#duplicate.id.cache" title="37.2.&nbsp;Configuring the Duplicate ID Cache">id-cache-size</a></td><td>Integer</td><td>the size of the cache for pre creating message id's</td><td>2000</td></tr><tr><td><a href="#configuring.message.journal.journal-buffer-size">journal-buffer-size</a></td><td>Long</td><td>The size of the internal buffer on the journal.</td><td>128 KiB</td></tr><tr><td><a href="#configuring.message.journal.journal-buffer-timeout">journal-buffer-timeout</a></td><td>Long</td><td>The timeout (in nanoseconds) used to flush internal
                                buffers on the journal.</td><td>20000</td></tr><tr><td><a href="#configuring.message.journal.journal-compact-min-files">journal-compact-min-files</a></td><td>Integer</td><td>The minimal number of data files before we can start
                                compacting</td><td>10</td></tr><tr><td><a href="#configuring.message.journal.journal-compact-percentage">journal-compact-percentage</a></td><td>Integer</td><td>The percentage of live data on which we consider compacting the
                                journal</td><td>30</td></tr><tr><td><a href="#configuring.message.journal.journal-directory">journal-directory</a></td><td>String</td><td>the directory to store the journal files in</td><td>data/journal</td></tr><tr><td><a href="#configuring.message.journal.journal-file-size">journal-file-size</a></td><td>Long</td><td>the size (in bytes) of each journal file</td><td>128 * 1024</td></tr><tr><td><a href="#configuring.message.journal.journal-max-io">journal-max-io</a></td><td>Integer</td><td>the maximum number of write requests that can be in the AIO queue
                                at any one time</td><td>500</td></tr><tr><td><a href="#configuring.message.journal.journal-min-files">journal-min-files</a></td><td>Integer</td><td>how many journal files to pre-create</td><td>2</td></tr><tr><td><a href="#configuring.message.journal.journal-sync-transactional">journal-sync-transactional</a></td><td>Boolean</td><td>if true wait for transaction data to be synchronized to the
                                journal before returning response to client</td><td>true</td></tr><tr><td><a href="#configuring.message.journal.journal-sync-non-transactional">journal-sync-non-transactional</a></td><td>Boolean</td><td>if true wait for non transaction data to be synced to the journal
                                before returning response to client.</td><td>true</td></tr><tr><td><a href="#configuring.message.journal.journal-type">journal-type</a></td><td>ASYNCIO|NIO</td><td>the type of journal to use</td><td>ASYNCIO</td></tr><tr><td><a href="#management.jmx.configuration" title="30.2.1.&nbsp;Configuring JMX">jmx-management-enabled</a></td><td>Boolean</td><td>true means that the management API is available via JMX</td><td>true</td></tr><tr><td><a href="#management.jmx.configuration" title="30.2.1.&nbsp;Configuring JMX">jmx-domain</a></td><td>String</td><td>the JMX domain used to registered HornetQ MBeans in the
                                MBeanServer</td><td>org.hornetq</td></tr><tr><td><a href="#large.message.configuring" title="23.1.&nbsp;Configuring the server">large-messages-directory</a></td><td>String</td><td>the directory to store large messages</td><td>data/largemessages</td></tr><tr><td><a href="#management.core.configuration" title="30.3.1.&nbsp;Configuring Core Management">management-address</a></td><td>String</td><td>the name of the management address to send management messages
                                to</td><td>jms.queue.hornetq.management</td></tr><tr><td><a href="#clusters.clusteruser" title="38.3.2.&nbsp;Cluster User Credentials">cluster-user</a></td><td>String</td><td>the user used by cluster connections to communicate between the
                                clustered nodes</td><td>HORNETQ.CLUSTER.ADMIN.USER</td></tr><tr><td><a href="#clusters.clusteruser" title="38.3.2.&nbsp;Cluster User Credentials">cluster-password</a></td><td>String</td><td>the password used by cluster connections to communicate between the
                                clustered nodes</td><td>CHANGE ME!!</td></tr><tr><td><a href="#management.notifications.core.configuration" title="30.5.2.1.&nbsp;Configuring The Core Management Notification Address">management-notification-address</a></td><td>String</td><td>the name of the address that consumers bind to receive management
                                notifications</td><td>hornetq.notifications</td></tr><tr><td><a href="#configuring.message.counters" title="30.6.1.&nbsp;Configuring Message Counters">message-counter-enabled</a></td><td>Boolean</td><td>true means that message counters are enabled</td><td>false</td></tr><tr><td><a href="#configuring.message.counters" title="30.6.1.&nbsp;Configuring Message Counters">message-counter-max-day-history</a></td><td>Integer</td><td>how many days to keep message counter history</td><td>10</td></tr><tr><td><a href="#configuring.message.counters" title="30.6.1.&nbsp;Configuring Message Counters">message-counter-sample-period</a></td><td>Long</td><td>the sample period (in ms) to use for message counters</td><td>10000</td></tr><tr><td><a href="#configuring.expiry.reaper" title="22.3.&nbsp;Configuring The Expiry Reaper Thread">message-expiry-scan-period</a></td><td>Long</td><td>how often (in ms) to scan for expired messages</td><td>30000</td></tr><tr><td><a href="#configuring.expiry.reaper" title="22.3.&nbsp;Configuring The Expiry Reaper Thread">message-expiry-thread-priority</a></td><td>Integer</td><td>the priority of the thread expiring messages</td><td>3</td></tr><tr><td><a href="#paging.main.config" title="24.2.&nbsp;Configuration">paging-directory</a></td><td>String</td><td>the directory to store paged messages in</td><td>data/paging</td></tr><tr><td><a href="#configuring.delivery.count.persistence" title="21.3.&nbsp;Delivery Count Persistence">
                                    persist-delivery-count-before-delivery</a></td><td>Boolean</td><td>true means that the delivery count is persisted before delivery.
                                False means that this only happens after a message has been
                                cancelled.</td><td>false</td></tr><tr><td><a href="#persistence.enabled" title="15.6.&nbsp;Configuring HornetQ for Zero Persistence">persistence-enabled</a></td><td>Boolean</td><td>true means that the server will use the file based journal for
                                persistence.</td><td>true</td></tr><tr><td><a href="#duplicate.id.cache" title="37.2.&nbsp;Configuring the Duplicate ID Cache">persist-id-cache</a></td><td>Boolean</td><td>true means that id's are persisted to the journal</td><td>true</td></tr><tr><td><a href="#server.scheduled.thread.pool" title="41.1.1.&nbsp;Server Scheduled Thread Pool">scheduled-thread-pool-max-size</a></td><td>Integer</td><td>the number of threads that the main scheduled thread pool
                                has.</td><td>5</td></tr><tr><td><a href="#security" title="Chapter&nbsp;31.&nbsp;Security">security-enabled</a></td><td>Boolean</td><td>true means that security is enabled</td><td>true</td></tr><tr><td><a href="#security" title="Chapter&nbsp;31.&nbsp;Security">security-invalidation-interval</a></td><td>Long</td><td>how long (in ms) to wait before invalidating the security
                                cache</td><td>10000</td></tr><tr><td><a href="#server.scheduled.thread.pool" title="41.1.1.&nbsp;Server Scheduled Thread Pool">thread-pool-max-size</a></td><td>Integer</td><td>the number of threads that the main thread pool has. -1 means no
                                limit</td><td>-1</td></tr><tr><td><a href="#connection-ttl.async-connection-execution" title="17.3.&nbsp;Configuring Asynchronous Connection Execution">async-connection-execution-enabled</a></td><td>Boolean</td><td>Should incoming packets on the server be handed off to a thread
                                from the thread pool for processing or should they be handled on the
                                remoting thread?</td><td>true</td></tr><tr><td><a href="#transaction-config" title="Chapter&nbsp;18.&nbsp;Resource Manager Configuration">transaction-timeout</a></td><td>Long</td><td>how long (in ms) before a transaction can be removed from the
                                resource manager after create time</td><td>60000</td></tr><tr><td><a href="#transaction-config" title="Chapter&nbsp;18.&nbsp;Resource Manager Configuration">transaction-timeout-scan-period</a></td><td>Long</td><td>how often (in ms) to scan for timeout transactions</td><td>1000</td></tr><tr><td><a href="#wildcard-routing" title="Chapter&nbsp;12.&nbsp;Routing Messages With Wild Cards">wild-card-routing-enabled</a></td><td>Boolean</td><td>true means that the server supports wild card routing</td><td>true</td></tr><tr><td><a href="#perf-tuning.memory">memory-measure-interval</a></td><td>Long</td><td>frequency to sample JVM memory in ms (or -1 to disable memory sampling)</td><td>-1</td></tr><tr><td><a href="#perf-tuning.memory">memory-warning-threshold</a></td><td>Integer</td><td>Percentage of available memory which threshold a warning log</td><td>25</td></tr><tr><td><a href="#configuring-transports.connectors" title="16.2.&nbsp;Understanding Connectors">connectors</a></td><td>Connector</td><td>a list of remoting connectors configurations to create</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.acceptors" title="16.1.&nbsp;Understanding Acceptors">connector.name (attribute)</a></td><td>String</td><td>Name of the connector - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.connectors" title="16.2.&nbsp;Understanding Connectors">connector.factory-class</a></td><td>String</td><td>Name of the ConnectorFactory implementation - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.connectors" title="16.2.&nbsp;Understanding Connectors">connector.param</a></td><td>A connector configuration parameter</td><td>A key-value pair used to configure the connector. A connector can have many param</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.connectors" title="16.2.&nbsp;Understanding Connectors">connector.param.key (attribute)</a></td><td>String</td><td>Key of a configuration parameter - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.connectors" title="16.2.&nbsp;Understanding Connectors">connector.param.value (attribute)</a></td><td>String</td><td>Value of a configuration parameter - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.acceptors" title="16.1.&nbsp;Understanding Acceptors">acceptors</a></td><td>Acceptor</td><td>a list of remoting acceptors to create</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.acceptors" title="16.1.&nbsp;Understanding Acceptors">acceptor.name (attribute)</a></td><td>String</td><td>Name of the acceptor - optional</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.acceptors" title="16.1.&nbsp;Understanding Acceptors">acceptor.factory-class</a></td><td>String</td><td>Name of the AcceptorFactory implementation - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.acceptors" title="16.1.&nbsp;Understanding Acceptors">acceptor.param</a></td><td>An acceptor configuration parameter</td><td>A key-value pair used to configure the acceptor. An acceptor can have many param</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.acceptors" title="16.1.&nbsp;Understanding Acceptors">acceptor.param.key (attribute)</a></td><td>String</td><td>Key of a configuration parameter - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#configuring-transports.acceptors" title="16.1.&nbsp;Understanding Acceptors">acceptor.param.value (attribute)</a></td><td>String</td><td>Value of a configuration parameter - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-groups</a></td><td>BroadcastGroup</td><td>a list of broadcast groups to create</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-group.name (attribute)</a></td><td>String</td><td>a unique name for the broadcast group - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-group.local-bind-address</a></td><td>String</td><td>local bind address that the datagram socket is bound to</td><td>wildcard IP address chosen by the kernel</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-group.local-bind-port</a></td><td>Integer</td><td>local port to which the datagram socket is bound to</td><td>-1 (anonymous port)</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-group.group-address</a></td><td>String</td><td>multicast address to which the data will be broadcast - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-group.group-port</a></td><td>Integer</td><td>UDP port number used for broadcasting - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-group.broadcast-period</a></td><td>Long</td><td>period in milliseconds between consecutive broadcasts</td><td>2000 (in milliseconds)</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-group.connector-ref</a></td><td>A pair of connector</td><td>A pair  connector and
                                 optional backup connector that will be broadcasted. A broadcast-group can have multiple connector-ref</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-group.connector-ref.connector-name (attribute)</a></td><td>String</td><td>Name of the live connector - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.broadcast-groups" title="38.2.1.&nbsp;Broadcast Groups">broadcast-group.connector-ref.backup-connector-name (attribute)</a></td><td>String</td><td>Name of the backup connector - optional</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.discovery-groups" title="38.2.2.&nbsp;Discovery Groups">discovery-groups</a></td><td>DiscoveryGroup</td><td>a list of discovery groups to create</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.discovery-groups" title="38.2.2.&nbsp;Discovery Groups">discovery-group.name (attribute)</a></td><td>String</td><td>a unique name for the discovery group - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.discovery-groups" title="38.2.2.&nbsp;Discovery Groups">discovery-group.local-bind-address</a></td><td>String</td><td>the discovery group will be bound only to this local address</td><td>&nbsp;</td></tr><tr><td><a name="configuration.discovery-group.group-address"></a><a href="#clusters.discovery-groups" title="38.2.2.&nbsp;Discovery Groups">discovery-group.group-address</a></td><td>String</td><td>Multicast IP address of the group to listen on - mandatory</td><td>&nbsp;</td></tr><tr><td><a name="configuration.discovery-group.group-port"></a><a href="#clusters.discovery-groups" title="38.2.2.&nbsp;Discovery Groups">discovery-group.group-port</a></td><td>Integer</td><td>UDP port of the multicast group - mandatory</td><td>&nbsp;</td></tr><tr><td><a name="configuration.discovery-group.refresh-timeout"></a><a href="#clusters.discovery-groups" title="38.2.2.&nbsp;Discovery Groups">discovery-group.refresh-timeout</a></td><td>Integer</td><td>Period the discovery group
                                  waits after receiving the last broadcast from a particular server before
                                  removing that servers connector pair entry from its list.</td><td>5000 (in milliseconds)</td></tr><tr><td><a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">diverts</a></td><td>Divert</td><td>a list of diverts to use</td><td>&nbsp;</td></tr><tr><td><a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">divert.name (attribute)</a></td><td>String</td><td>a unique name for the divert - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">divert.routing-name</a></td><td>String</td><td>the routing name for the divert - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">divert.address</a></td><td>String</td><td>the address this divert will divert from - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">divert.forwarding-address</a></td><td>String</td><td>the forwarding address for the divert - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">divert.exclusive</a></td><td>Boolean</td><td>is this divert exclusive?</td><td>false</td></tr><tr><td><a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">divert.filter</a></td><td>String</td><td>an optional core filter expression</td><td>null</td></tr><tr><td><a href="#diverts" title="Chapter&nbsp;35.&nbsp;Diverting and Splitting Message Flows">divert.transformer-class-name</a></td><td>String</td><td>an optional class name of a transformer</td><td>&nbsp;</td></tr><tr><td><a href="#predefined.queues" title="25.1.&nbsp;Predefined Queues">queues</a></td><td>Queue</td><td>a list of pre configured queues to create</td><td>&nbsp;</td></tr><tr><td><a href="#predefined.queues" title="25.1.&nbsp;Predefined Queues">queues.name
                                (attribute)</a></td><td>String</td><td>unique name of this queue</td><td>&nbsp;</td></tr><tr><td><a href="#predefined.queues" title="25.1.&nbsp;Predefined Queues">queues.address</a></td><td>String</td><td>address for this queue - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#predefined.queues" title="25.1.&nbsp;Predefined Queues">queues.filter</a></td><td>String</td><td>optional core filter expression for this queue</td><td>null</td></tr><tr><td><a href="#predefined.queues" title="25.1.&nbsp;Predefined Queues">queues.durable</a></td><td>Boolean</td><td>is this queue durable?</td><td>true</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges</a></td><td>Bridge</td><td>a list of bridges to create</td><td>&nbsp;</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.name
                                (attribute)</a></td><td>String</td><td>unique name for this bridge</td><td>&nbsp;</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.queue-name</a></td><td>String</td><td>name of queue that this bridge consumes from - mandatory</td><td>&nbsp;</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.forwarding-address</a></td><td>String</td><td>address to forward to. If omitted original address is
                                used</td><td>null</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.filter</a></td><td>String</td><td>optional core filter expression</td><td>null</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.transformer-class-name</a></td><td>String</td><td>optional name of transformer class</td><td>null</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.retry-interval</a></td><td>Long</td><td>period (in ms) between successive retries</td><td>2000 ms</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.retry-interval-multiplier</a></td><td>Double</td><td>multiplier to apply to successive retry intervals</td><td>1.0</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.reconnect-attempts</a></td><td>Integer</td><td>maximum number of retry attempts, -1 signifies infinite</td><td>-1</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.failover-on-server-shutdown</a></td><td>Boolean</td><td>should failover be prompted if target server is cleanly
                                shutdown?</td><td>false</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.use-duplicate-detection</a></td><td>Boolean</td><td>should duplicate detection headers be inserted in forwarded
                                messages?</td><td>true</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.discovery-group-ref</a></td><td>String</td><td>name of discovery group used by this bridge</td><td>null</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.connector-ref.connector-name
                                    (attribute)</a></td><td>String</td><td>name of connector to use for live connection</td><td>&nbsp;</td></tr><tr><td><a href="#core-bridges" title="Chapter&nbsp;36.&nbsp;Core Bridges">bridges.connector-ref.backup-connector-name
                                (attribute)</a></td><td>String</td><td>optional name of connector to use for backup connection</td><td>null</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections</a></td><td>ClusterConnection</td><td>a list of cluster connections</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections.name (attribute)</a></td><td>String</td><td>unique name for this cluster connection</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections.address</a></td><td>String</td><td>name of address this cluster connection applies to</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections.forward-when-no-consumers</a></td><td>Boolean</td><td>should messages be load balanced if there are no matching
                                consumers on target?</td><td>false</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections.max-hops</a></td><td>Integer</td><td>maximum number of hops cluster topology is propagated</td><td>1</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections.retry-interval</a></td><td>Long</td><td>period (in ms) between successive retries</td><td>2000</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections.use-duplicate-detection</a></td><td>Boolean</td><td>should duplicate detection headers be inserted in forwarded
                                messages?</td><td>true</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections.discovery-group-ref</a></td><td>String</td><td>name of discovery group used by this bridge</td><td>null</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections.connector-ref.connector-name
                                    (attribute)</a></td><td>String</td><td>name of connector to use for live connection</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.cluster-connections" title="38.3.1.&nbsp;Configuring Cluster Connections">cluster-connections.connector-ref.backup-connector-name
                                    (attribute)</a></td><td>String</td><td>optional name of connector to use for backup connection</td><td>null</td></tr><tr><td><a href="#security.settings.roles" title="31.1.&nbsp;Role based security for addresses">security-settings</a></td><td>SecuritySetting</td><td>a list of security settings</td><td>&nbsp;</td></tr><tr><td><a href="#security.settings.roles" title="31.1.&nbsp;Role based security for addresses">security-settings.match
                                    (attribute)</a></td><td>String</td><td>the string to use for matching security against an
                                address</td><td>&nbsp;</td></tr><tr><td><a href="#security.settings.roles" title="31.1.&nbsp;Role based security for addresses">security-settings.permission</a></td><td>Security Permission</td><td>a permision to add to the address</td><td>&nbsp;</td></tr><tr><td><a href="#security.settings.roles" title="31.1.&nbsp;Role based security for addresses">security-settings.permission.type (attribute)</a></td><td>Permission Type</td><td>the type of permission</td><td>&nbsp;</td></tr><tr><td><a href="#security.settings.roles" title="31.1.&nbsp;Role based security for addresses">security-settings.permission.roles (attribute)</a></td><td>Roles</td><td>a comma-separated list of roles to apply the permission
                                to</td><td>&nbsp;</td></tr><tr><td><a href="#queue-attributes.address-settings" title="25.3.&nbsp;Configuring Queues Via Address Settings">address-settings</a></td><td>AddressSetting</td><td>a list of address settings</td><td>&nbsp;</td></tr><tr><td><a href="#undelivered-messages.configuring" title="21.2.1.&nbsp;Configuring Dead Letter Addresses">address-settings.dead-letter-address</a></td><td>String</td><td>the address to send dead messages to</td><td>&nbsp;</td></tr><tr><td><a href="#undelivered-messages.configuring" title="21.2.1.&nbsp;Configuring Dead Letter Addresses">address-settings.max-delivery-attempts</a></td><td>Integer</td><td>how many times to attempt to deliver a message before sending to
                                dead letter address</td><td>10</td></tr><tr><td><a href="#message-expiry.configuring" title="22.2.&nbsp;Configuring Expiry Addresses">address-settings.expiry-address</a></td><td>String</td><td>the address to send expired messages to</td><td>&nbsp;</td></tr><tr><td><a href="#undelivered-messages.delay" title="21.1.1.&nbsp;Configuring Delayed Redelivery">address-settings.redelivery-delay</a></td><td>Long</td><td>the time (in ms) to wait before redelivering a cancelled
                                message.</td><td>0</td></tr><tr><td><a href="#last-value-queues" title="Chapter&nbsp;27.&nbsp;Last-Value Queues">address-settings.last-value-queue</a></td><td>boolean</td><td>whether to treat the queue as a last value queue</td><td>false</td></tr><tr><td><a href="#paging" title="Chapter&nbsp;24.&nbsp;Paging">address-settings.page-size-bytes</a></td><td>Long</td><td>the page size (in bytes) to use for an address</td><td>10 * 1024 * 1024</td></tr><tr><td><a href="#paging" title="Chapter&nbsp;24.&nbsp;Paging">address-settings.max-size-bytes</a></td><td>Long</td><td>the maximum size (in bytes) to use in paging for an
                                address</td><td>-1</td></tr><tr><td><a href="#clusters.message-redistribution" title="38.6.&nbsp;Message Redistribution">address-settings.redistribution-delay</a></td><td>Long</td><td>how long (in ms) to wait after the last consumer is closed on a
                                queue before redistributing messages.</td><td>-1</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12990"></a>47.1.2.&nbsp;hornetq-jms.xml</h3></div></div><div></div></div><p>This is the configuration file used by the server side JMS service to load JMS
                Queues, Topics and Connection Factories.</p><div class="table"><a name="d0e12995"></a><p class="title"><b>Table&nbsp;47.2.&nbsp;JMS Server Configuration</b></p><table summary="JMS Server Configuration" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Element Name</th><th>Element Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><a href="#using-jms.server.configuration" title="7.2.&nbsp;JMS Server Configuration">connection-factory</a></td><td>ConnectionFactory</td><td>a list of connection factories to create and add to JNDI</td><td>&nbsp;</td></tr></tbody></table></div><p></p><p></p><p>Continued..</p><div class="informaltable"><table border="1"><colgroup><col><col><col><col></colgroup><tbody><tr><td><a name="configuration.connection-factory.auto-group"></a><a href="#message-grouping.jmsconfigure" title="28.2.&nbsp;Using JMS">connection-factory.auto-group</a></td><td>Boolean</td><td>whether or not message grouping is automatically used</td><td>false</td></tr><tr><td><a href="#clusters.static.servers" title="38.5.2.&nbsp;Specifying List of Servers to form a Cluster">connection-factory.connectors</a></td><td>String</td><td>A list of connectors used by the connection factory</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.static.servers" title="38.5.2.&nbsp;Specifying List of Servers to form a Cluster">connection-factory.connectors.connector-ref.connector-name (attribute)</a></td><td>String</td><td>Name of the connector to connect to the live server</td><td>&nbsp;</td></tr><tr><td><a href="#clusters.static.servers" title="38.5.2.&nbsp;Specifying List of Servers to form a Cluster">connection-factory.connectors.connector-ref.backup-connector-name (attribute)</a></td><td>String</td><td>Name of the connector to connect to the backup server</td><td>&nbsp;</td></tr><tr><td><a href="#clusters-discovery.groups.clientside" title="38.2.4.&nbsp;Discovery Groups on the Client Side">connection-factory.discovery-group-ref.discovery-group-name (attribute)</a></td><td>String</td><td>Name of discovery group used by this connection factory</td><td>&nbsp;</td></tr><tr><td><a name="configuration.connection-factory.discovery-initial-wait-timeout"></a><a href="#clusters-discovery.groups.clientside" title="38.2.4.&nbsp;Discovery Groups on the Client Side">connection-factory.discovery-initial-wait-timeout</a></td><td>Long</td><td>the initial time to wait (in ms) for discovery groups to wait for
                                broadcasts</td><td>10000</td></tr><tr><td><a name="configuration.connection-factory.block-on-acknowledge"></a><a href="#send-guarantees.nontrans.acks" title="20.3.&nbsp;Guarantees of Non Transactional Acknowledgements">connection-factory.block-on-acknowledge</a></td><td>Boolean</td><td>whether or not messages are acknowledged synchronously</td><td>false</td></tr><tr><td><a name="configuration.connection-factory.block-on-non-durable-send"></a><a href="#non-transactional-sends" title="20.2.&nbsp;Guarantees of Non Transactional Message Sends">connection-factory.block-on-non-durable-send</a></td><td>Boolean</td><td>whether or not non-durable messages are sent synchronously</td><td>false</td></tr><tr><td><a name="configuration.connection-factory.block-on-durable-send"></a><a href="#non-transactional-sends" title="20.2.&nbsp;Guarantees of Non Transactional Message Sends">connection-factory.block-on-durable-send</a></td><td>Boolean</td><td>whether or not durable messages are sent synchronously</td><td>true</td></tr><tr><td><a name="configuration.connection-factory.call-timeout"></a>connection-factory.call-timeout</td><td>Long</td><td>the timeout (in ms) for remote calls</td><td>30000</td></tr><tr><td><a name="configuration.connection-factory.client-failure-check-period"></a><a href="#dead.connections" title="17.1.&nbsp;Cleaning up Dead Connection Resources on the Server">connection-factory.client-failure-check-period</a></td><td>Long</td><td>the period (in ms) after which the client will consider the
                                connection failed after not receiving packets from the
                                server</td><td>5000</td></tr><tr><td><a name="configuration.connection-factory.client-id"></a><a href="#using-jms.clientid" title="7.6.&nbsp;Setting The Client ID">connection-factory.client-id</a></td><td>String</td><td>the pre-configured client ID for the connection factory</td><td>null</td></tr><tr><td><a name="configuration.connection-factory.connection-load-balancing-policy-class-name"></a><a href="#clusters.client.loadbalancing" title="38.4.&nbsp;Client-Side Load balancing">
                                  connection-factory.connection-load-balancing-policy-class-name</a></td><td>String</td><td>the name of the load balancing class</td><td>org.hornetq.api.core.client.loadbalance.RoundRobinConnectionLoadBalancingPolicy</td></tr><tr><td><a name="configuration.connection-factory.connection-ttl"></a><a href="#dead.connections" title="17.1.&nbsp;Cleaning up Dead Connection Resources on the Server">connection-factory.connection-ttl</a></td><td>Long</td><td>the time to live (in ms) for connections</td><td>1 * 60000</td></tr><tr><td><a name="configuration.connection-factory.consumer-max-rate"></a><a href="#flow-control.rate.core.api" title="19.1.2.1.&nbsp;Using Core API">connection-factory.consumer-max-rate</a></td><td>Integer</td><td>the fastest rate a consumer may consume messages per
                                second</td><td>-1</td></tr><tr><td><a name="configuration.connection-factory.consumer-window-size"></a><a href="#flow-control.core.api" title="19.1.1.1.&nbsp;Using Core API">connection-factory.consumer-window-size</a></td><td>Integer</td><td>the window size (in bytes) for consumer flow control</td><td>1024 * 1024</td></tr><tr><td><a name="configuration.connection-factory.dups-ok-batch-size"></a><a href="#using-jms.dupsokbatchsize" title="7.7.&nbsp;Setting The Batch Size for DUPS_OK ">connection-factory.dups-ok-batch-size</a></td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using
                                DUPS_OK_ACKNOWLEDGE mode</td><td>1024 * 1024</td></tr><tr><td><a href="#ha.automatic.failover" title="39.2.1.&nbsp;Automatic Client Failover">connection-factory.failover-on-initial-connection</a></td><td>Boolean</td><td>whether or not to failover to backup on event that initial connection to live server fails</td><td>false</td></tr><tr><td><a name="configuration.connection-factory.failover-on-server-shutdown"></a><a href="#ha.automatic.failover" title="39.2.1.&nbsp;Automatic Client Failover">connection-factory.failover-on-server-shutdown</a></td><td>Boolean</td><td>whether or not to failover on server shutdown</td><td>false</td></tr><tr><td><a name="configuration.connection-factory.min-large-message-size"></a><a href="#large-messages.core.config" title="23.2.1.&nbsp;Using Core API">connection-factory.min-large-message-size</a></td><td>Integer</td><td>the size (in bytes) before a message is treated as large</td><td>100 * 1024</td></tr><tr><td><a href="#large-messages.cache.client" title="23.5.&nbsp;Cache Large Messages on client">connection-factory.cache-large-message-client</a></td><td>Boolean</td><td>If true clients using this connection factory will hold the large
                                message body on temporary files.</td><td>false</td></tr><tr><td><a name="configuration.connection-factory.pre-acknowledge"></a><a href="#pre-acknowledge.configure" title="29.1.&nbsp;Using PRE_ACKNOWLEDGE">connection-factory.pre-acknowledge</a></td><td>Boolean</td><td>whether messages are pre acknowledged by the server before
                                sending</td><td>false</td></tr><tr><td><a name="configuration.connection-factory.producer-max-rate"></a><a href="#flow-control.producer.rate.core.api" title="19.2.2.1.&nbsp;Using Core API">connection-factory.producer-max-rate</a></td><td>Integer</td><td>the maximum rate of messages per second that can be sent</td><td>-1</td></tr><tr><td><a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">connection-factory.producer-window-size</a></td><td>Integer</td><td>the window size in bytes for producers sending messages</td><td>1024 * 1024</td></tr><tr><td><a name="configuration.connection-factory.confirmation-window-size"></a><a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">connection-factory.confirmation-window-size</a></td><td>Integer</td><td>the window size (in bytes) for reattachment confirmations</td><td>1024 * 1024</td></tr><tr><td><a name="configuration.connection-factory.reconnect-attempts"></a><a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">connection-factory.reconnect-attempts</a></td><td>Integer</td><td>maximum number of retry attempts, -1 signifies infinite</td><td>0</td></tr><tr><td><a name="configuration.connection-factory.retry-interval"></a><a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">connection-factory.retry-interval</a></td><td>Long</td><td>the time (in ms) to retry a connection after failing</td><td>2000</td></tr><tr><td><a name="configuration.connection-factory.retry-interval-multiplier"></a><a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">connection-factory.retry-interval-multiplier</a></td><td>Double</td><td>multiplier to apply to successive retry intervals</td><td>1.0</td></tr><tr><td><a href="#client-reconnection" title="Chapter&nbsp;34.&nbsp;Client Reconnection and Session Reattachment">connection-factory.max-retry-interval</a></td><td>Integer</td><td>The maximum retry interval in the case a retry-interval-multiplier has been specified</td><td>2000</td></tr><tr><td><a name="configuration.connection-factory.scheduled-thread-pool-max-size"></a><a href="#thread-pooling.client.side" title="41.2.&nbsp;Client-Side Thread Management">connection-factory.scheduled-thread-pool-max-size</a></td><td>Integer</td><td>the size of the <span class="emphasis"><em>scheduled thread</em></span> pool</td><td>5</td></tr><tr><td><a name="configuration.connection-factory.thread-pool-max-size"></a><a href="#thread-pooling.client.side" title="41.2.&nbsp;Client-Side Thread Management">connection-factory.thread-pool-max-size</a></td><td>Integer</td><td>the size of the thread pool</td><td>-1</td></tr><tr><td><a name="configuration.connection-factory.transaction-batch-size"></a><a href="#using-jms.txbatchsize" title="7.8.&nbsp;Setting The Transaction Batch Size">
                                  connection-factory.transaction-batch-size</a></td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using a
                                transactional session</td><td>1024 * 1024</td></tr><tr><td><a name="configuration.connection-factory.use-global-pools"></a><a href="#thread-pooling.client.side" title="41.2.&nbsp;Client-Side Thread Management">connection-factory.use-global-pools</a></td><td>Boolean</td><td>whether or not to use a global thread pool for threads</td><td>true</td></tr><tr><td><a href="#using-jms.server.configuration" title="7.2.&nbsp;JMS Server Configuration">queue</a></td><td>Queue</td><td>a queue to create and add to JNDI</td><td>&nbsp;</td></tr><tr><td><a href="#using-jms.server.configuration" title="7.2.&nbsp;JMS Server Configuration">queue.name
                                    (attribute)</a></td><td>String</td><td>unique name of the queue</td><td>&nbsp;</td></tr><tr><td><a href="#using-jms.server.configuration" title="7.2.&nbsp;JMS Server Configuration">queue.entry</a></td><td>String</td><td>context where the queue will be bound in JNDI (there can be
                                many)</td><td>&nbsp;</td></tr><tr><td><a href="#using-jms.server.configuration" title="7.2.&nbsp;JMS Server Configuration">queue.durable</a></td><td>Boolean</td><td>is the queue durable?</td><td>true</td></tr><tr><td><a href="#using-jms.server.configuration" title="7.2.&nbsp;JMS Server Configuration">queue.filter</a></td><td>String</td><td>optional filter expression for the queue</td><td>&nbsp;</td></tr><tr><td><a href="#using-jms.server.configuration" title="7.2.&nbsp;JMS Server Configuration">topic</a></td><td>Topic</td><td>a topic to create and add to JNDI</td><td>&nbsp;</td></tr><tr><td><a href="#using-jms.server.configuration" title="7.2.&nbsp;JMS Server Configuration">topic.name
                                    (attribute)</a></td><td>String</td><td>unique name of the topic</td><td>&nbsp;</td></tr><tr><td><a href="#using-jms.server.configuration" title="7.2.&nbsp;JMS Server Configuration">topic.entry</a></td><td>String</td><td>context where the topic will be bound in JNDI (there can be
                                many)</td><td>&nbsp;</td></tr></tbody></table></div></div></div></div></div></body></html>