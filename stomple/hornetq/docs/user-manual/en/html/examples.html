<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;11.&nbsp;Examples</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="HornetQ 2.1 User Manual"><link rel="up" href="index.html" title="HornetQ 2.1 User Manual"><link rel="previous" href="client-classpath.html" title="Chapter&nbsp;10.&nbsp;The Client Classpath"><link rel="next" href="wildcard-routing.html" title="Chapter&nbsp;12.&nbsp;Routing Messages With Wild Cards"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;11.&nbsp;Examples</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="client-classpath.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="wildcard-routing.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="examples"></a>Chapter&nbsp;11.&nbsp;Examples</h2></div></div><div></div></div><p>The HornetQ distribution comes with over 70 run out-of-the-box examples demonstrating many
        of the features.</p><p>The examples are available in the distribution, in the <tt class="literal">examples</tt>
        directory. Examples are split into JMS and core examples. JMS examples show how a particular
        feature can be used by a normal JMS client. Core examples show how the equivalent feature
        can be used by a core messaging client.</p><p>A set of Java EE examples are also provided which need the JBoss Application Server
        installed to be able to run.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1602"></a>11.1.&nbsp;JMS Examples</h2></div></div><div></div></div><p>To run a JMS example, simply <tt class="literal">cd</tt> into the appropriate example
            directory and type <tt class="literal">./build.sh</tt> (or <tt class="literal">build.bat</tt> if you
            are on Windows).</p><p>Here's a listing of the examples with a brief description.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="application-level-failover"></a>11.1.1.&nbsp;Application-Layer Failover</h3></div></div><div></div></div><p>HornetQ also supports Application-Layer failover, useful in the case that
                replication is not enabled on the server side.</p><p>With Application-Layer failover, it's up to the application to register a JMS
                    <tt class="literal">ExceptionListener</tt> with HornetQ which will be called by
                HornetQ in the event that connection failure is detected.</p><p>The code in the <tt class="literal">ExceptionListener</tt> then recreates the JMS
                connection, session, etc on another node and the application can continue.</p><p>Application-layer failover is an alternative approach to High Availability (HA).
                Application-layer failover differs from automatic failover in that some client side
                coding is required in order to implement this. Also, with Application-layer
                failover, since the old session object dies and a new one is created, any
                uncommitted work in the old session will be lost, and any unacknowledged messages
                might be redelivered.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.bridge"></a>11.1.2.&nbsp;Core Bridge Example</h3></div></div><div></div></div><p>The <tt class="literal">bridge</tt> example demonstrates a core bridge deployed on one
                server, which consumes messages from a local queue and forwards them to an address
                on a second server.</p><p>Core bridges are used to create message flows between any two HornetQ servers
                which are remotely separated. Core bridges are resilient and will cope with
                temporary connection failure allowing them to be an ideal choice for forwarding over
                unreliable connections, e.g. a WAN.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.browsers"></a>11.1.3.&nbsp;Browser</h3></div></div><div></div></div><p>The <tt class="literal">browser</tt> example shows you how to use a JMS <tt class="literal">QueueBrowser</tt> with HornetQ.</p><p>Queues are a standard part of JMS, please consult the JMS 1.1 specification for
                full details.</p><p> A <tt class="literal">QueueBrowser</tt> is used to look at messages on the queue
                without removing them. It can scan the entire content of a queue or only messages
                matching a message selector.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1663"></a>11.1.4.&nbsp;Client Kickoff</h3></div></div><div></div></div><p>The <tt class="literal">client-kickoff</tt> example shows how to terminate client
                connections given an IP address using the JMX management API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1671"></a>11.1.5.&nbsp;Client-Side Load-Balancing</h3></div></div><div></div></div><p>The <tt class="literal">client-side-load-balancing</tt> example demonstrates how
                sessions created from a single JMS <tt class="literal">Connection</tt> can
                be created to different nodes of the cluster. In other words it demonstrates how
                HornetQ does client-side load-balancing of sessions across the cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.clustered.grouping"></a>11.1.6.&nbsp;Clustered Grouping</h3></div></div><div></div></div><p>This is similar to the message grouping example except that it demonstrates it
                working over a cluster. Messages sent to different nodes with the same group id will
                be sent to the same node and the same consumer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1687"></a>11.1.7.&nbsp;Clustered Queue</h3></div></div><div></div></div><p>The <tt class="literal">clustered-queue</tt> example demonstrates a JMS queue deployed
                on two different nodes. The two nodes are configured to form a cluster. We then
                create a consumer for the queue on each node, and we create a producer on only one
                of the nodes. We then send some messages via the producer, and we verify that both
                consumers receive the sent messages in a round-robin fashion.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1695"></a>11.1.8.&nbsp;Clustered Standalone</h3></div></div><div></div></div><p>The <tt class="literal">clustered-standalone</tt> example demonstrates how to configure
                and starts 3 cluster nodes on the same machine to form a cluster. A subscriber for a
                JMS topic is created on each node, and we create a producer on only one of the
                nodes. We then send some messages via the producer, and we verify that the 3
                subscribers receive all the sent messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1703"></a>11.1.9.&nbsp;Clustered Topic</h3></div></div><div></div></div><p>The <tt class="literal">clustered-topic</tt> example demonstrates a JMS topic deployed
                on two different nodes. The two nodes are configured to form a cluster. We then
                create a subscriber on the topic on each node, and we create a producer on only one
                of the nodes. We then send some messages via the producer, and we verify that both
                subscribers receive all the sent messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.consumer-rate-limit"></a>11.1.10.&nbsp;Message Consumer Rate Limiting</h3></div></div><div></div></div><p>With HornetQ you can specify a maximum consume rate at which a JMS MessageConsumer
                will consume messages. This can be specified when creating or deploying the
                connection factory.</p><p>If this value is specified then HornetQ will ensure that messages are never
                consumed at a rate higher than the specified rate. This is a form of consumer
                throttling.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.dead-letter"></a>11.1.11.&nbsp;Dead Letter</h3></div></div><div></div></div><p>The <tt class="literal">dead-letter</tt> example shows you how to define and deal with
                dead letter messages. Messages can be delivered unsuccessfully (e.g. if the
                transacted session used to consume them is rolled back). </p><p>Such a message goes back to the JMS destination ready to be redelivered. However,
                this means it is possible for a message to be delivered again and again without any
                success and remain in the destination, clogging the system.</p><p>To prevent this, messaging systems define dead letter messages: after a specified
                unsuccessful delivery attempts, the message is removed from the destination and put
                instead in a dead letter destination where they can be consumed for further
                investigation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.delayed-redelivery"></a>11.1.12.&nbsp;Delayed Redelivery</h3></div></div><div></div></div><p>The <tt class="literal">delayed-redelivery</tt> example demonstrates how HornetQ can be
                configured to provide a delayed redelivery in the case a message needs to be
                redelivered.</p><p>Delaying redelivery can often be useful in the case that clients regularly fail or
                roll-back. Without a delayed redelivery, the system can get into a "thrashing"
                state, with delivery being attempted, the client rolling back, and delivery being
                re-attempted in quick succession, using up valuable CPU and network
                resources.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="divert-example"></a>11.1.13.&nbsp;Divert</h3></div></div><div></div></div><p>HornetQ diverts allow messages to be transparently "diverted" or copied from one
                address to another with just some simple configuration defined on the server
                side.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1745"></a>11.1.14.&nbsp;Durable Subscription</h3></div></div><div></div></div><p>The <tt class="literal">durable-subscription</tt> example shows you how to use a durable
                subscription with HornetQ. Durable subscriptions are a standard part of JMS, please
                consult the JMS 1.1 specification for full details.</p><p>Unlike non-durable subscriptions, the key function of durable subscriptions is
                that the messages contained in them persist longer than the lifetime of the
                subscriber - i.e. they will accumulate messages sent to the topic even if there is
                no active subscriber on them. They will also survive server restarts or crashes.
                Note that for the messages to be persisted, the messages sent to them must be marked
                as durable messages. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1755"></a>11.1.15.&nbsp;Embedded</h3></div></div><div></div></div><p>The <tt class="literal">embedded</tt> example shows how to embed the HornetQ server
                within your own code.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1763"></a>11.1.16.&nbsp;HTTP Transport</h3></div></div><div></div></div><p>The <tt class="literal">http-transport</tt> example shows you how to configure HornetQ
                to use the HTTP protocol as its transport layer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1771"></a>11.1.17.&nbsp;Instantiate JMS Objects Directly</h3></div></div><div></div></div><p>Usually, JMS Objects such as <tt class="literal">ConnectionFactory</tt>, <tt class="literal">Queue</tt> and <tt class="literal">Topic</tt> instances are looked up from JNDI
                before being used by the client code. This objects are called "administered objects"
                in JMS terminology.</p><p>However, in some cases a JNDI server may not be available or desired. To come to
                the rescue HornetQ also supports the direct instantiation of these administered
                objects on the client side so you don't have to use JNDI for JMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.interceptor"></a>11.1.18.&nbsp;Interceptor</h3></div></div><div></div></div><p>HornetQ allows an application to use an interceptor to hook into the messaging
                system. Interceptors allow you to handle various message events in HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.jaas"></a>11.1.19.&nbsp;JAAS</h3></div></div><div></div></div><p>The <tt class="literal">jaas</tt> example shows you how to configure HornetQ to use JAAS
                for security. HornetQ can leverage JAAS to delegate user authentication and
                authorization to existing security infrastructure.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.jms.jms-bridge"></a>11.1.20.&nbsp;JMS Bridge</h3></div></div><div></div></div><p>The <tt class="literal">jms-brige</tt> example shows how to setup a bridge
            between two standalone HornetQ servers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.jmx"></a>11.1.21.&nbsp;JMX Management</h3></div></div><div></div></div><p>The <tt class="literal">jmx</tt> example shows how to manage HornetQ using JMX.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.large-message"></a>11.1.22.&nbsp;Large Message</h3></div></div><div></div></div><p>The <tt class="literal">large-message</tt> example shows you how to send and receive
                very large messages with HornetQ. HornetQ supports the sending and receiving of huge
                messages, much larger than can fit in available RAM on the client or server.
                Effectively the only limit to message size is the amount of disk space you have on
                the server.</p><p>Large messages are persisted on the server so they can survive a server restart.
                In other words HornetQ doesn't just do a simple socket stream from the sender to the
                consumer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.last-value-queue"></a>11.1.23.&nbsp;Last-Value Queue</h3></div></div><div></div></div><p>The <tt class="literal">last-value-queue</tt> example shows you how to define and deal
                with last-value queues. Last-value queues are special queues which discard any
                messages when a newer message with the same value for a well-defined last-value
                property is put in the queue. In other words, a last-value queue only retains the
                last value.</p><p>A typical example for last-value queue is for stock prices, where you are only
                interested by the latest price for a particular stock.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1836"></a>11.1.24.&nbsp;Load Balanced Clustered Queue</h3></div></div><div></div></div><p>The <tt class="literal">clustered-queue</tt> example demonstrates a JMS queue deployed
                on two different nodes. The two nodes are configured to form a cluster.</p><p>We then create a consumer on the queue on each node, and we create a producer on
                only one of the nodes. We then send some messages via the producer, and we verify
                that both consumers receive the sent messages in a round-robin fashion.</p><p>In other words, HornetQ load balances the sent messages across all consumers on
                the cluster</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.management"></a>11.1.25.&nbsp;Management</h3></div></div><div></div></div><p>The <tt class="literal">management</tt> example shows how to manage HornetQ using JMS
                Messages to invoke management operations on the server.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.management-notifications"></a>11.1.26.&nbsp;Management Notification</h3></div></div><div></div></div><p>The <tt class="literal">management-notification</tt> example shows how to receive
                management notifications from HornetQ using JMS messages. HornetQ servers emit
                management notifications when events of interest occur (consumers are created or
                closed, addresses are created or deleted, security authentication fails,
                etc.).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.message-counters"></a>11.1.27.&nbsp;Message Counter</h3></div></div><div></div></div><p>The <tt class="literal">message-counters</tt> example shows you how to use message
                counters to obtain message information for a JMS queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.expiry"></a>11.1.28.&nbsp;Message Expiration</h3></div></div><div></div></div><p>The <tt class="literal">expiry</tt> example shows you how to define and deal with
                message expiration. Messages can be retained in the messaging system for a limited
                period of time before being removed. JMS specification states that clients should
                not receive messages that have been expired (but it does not guarantee this will not
                happen).</p><p>HornetQ can assign an expiry address to a given queue so that when messages
                are expired, they are removed from the queue and sent to the expiry address.
                These "expired" messages can later be consumed from the expiry address for
                further inspection.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.message-group"></a>11.1.29.&nbsp;Message Group</h3></div></div><div></div></div><p>The <tt class="literal">message-group</tt> example shows you how to configure and use
                message groups with HornetQ. Message groups allow you to pin messages so they are
                only consumed by a single consumer. Message groups are sets of messages that has the
                following characteristics:</p><p>
                </p><div class="itemizedlist"><ul type="disc"><li><p>Messages in a message group share the same group id, i.e. they have
                            same JMSXGroupID string property values</p></li><li><p>The consumer that receives the first message of a group will receive
                            all the messages that belongs to the group</p></li></ul></div><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.message-group2"></a>11.1.30.&nbsp;Message Group</h3></div></div><div></div></div><p>The <tt class="literal">message-group2</tt> example shows you how to configure and use
                message groups with HornetQ via a connection factory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.message-priority"></a>11.1.31.&nbsp;Message Priority</h3></div></div><div></div></div><p>Message Priority can be used to influence the delivery order for messages.</p><p>It can be retrieved by the message's standard header field 'JMSPriority' as
                defined in JMS specification version 1.1. </p><p>The value is of type integer, ranging from 0 (the lowest) to 9 (the highest). When
                messages are being delivered, their priorities will effect their order of delivery.
                Messages of higher priorities will likely be delivered before those of lower
                priorities. </p><p>Messages of equal priorities are delivered in the natural order of their arrival
                at their destinations. Please consult the JMS 1.1 specification for full
                details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.no-consumer-buffering"></a>11.1.32.&nbsp;No Consumer Buffering</h3></div></div><div></div></div><p>By default, HornetQ consumers buffer messages from the server in a client side
                buffer before you actually receive them on the client side. This improves
                performance since otherwise every time you called receive() or had processed the
                last message in a <tt class="literal">MessageListener onMessage()</tt> method, the HornetQ
                client would have to go the server to request the next message, which would then get
                sent to the client side, if one was available.</p><p>This would involve a network round trip for every message and reduce performance.
                Therefore, by default, HornetQ pre-fetches messages into a buffer on each
                consumer.</p><p>In some case buffering is not desirable, and HornetQ allows it to be switched off.
                This example demonstrates that.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.non-transaction-failover"></a>11.1.33.&nbsp;Non-Transaction Failover With Server Data Replication</h3></div></div><div></div></div><p>The <tt class="literal">non-transaction-failover</tt> example demonstrates two servers coupled
                as a live-backup pair for high availability (HA), and a client using a <span class="emphasis"><em>non-transacted
                </em></span> JMS session failing over from live to backup when the live server is
                crashed.</p><p>HornetQ implements failover of client connections between
                live and backup servers. This is implemented by the replication of state between
                live and backup nodes. When replication is configured and a live node crashes, the
                client connections can carry and continue to send and consume messages. When non-transacted
                 sessions are used, once and only once message delivery is not guaranteed and it is possible
                 that some messages will be lost or delivered twice.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.paging"></a>11.1.34.&nbsp;Paging</h3></div></div><div></div></div><p>The <tt class="literal">paging</tt> example shows how HornetQ can support huge queues
                even when the server is running in limited RAM. It does this by transparently
                    <span class="emphasis"><em>paging</em></span> messages to disk, and <span class="emphasis"><em>depaging</em></span>
                them when they are required.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.pre-acknowledge"></a>11.1.35.&nbsp;Pre-Acknowledge</h3></div></div><div></div></div><p>Standard JMS supports three acknowledgement modes:<tt class="literal">
                    AUTO_ACKNOWLEDGE</tt>, <tt class="literal">CLIENT_ACKNOWLEDGE</tt>, and <tt class="literal">DUPS_OK_ACKNOWLEDGE</tt>. For a full description on these modes please
                consult the JMS specification, or any JMS tutorial.</p><p>All of these standard modes involve sending acknowledgements from the client to
                the server. However in some cases, you really don't mind losing messages in event of
                failure, so it would make sense to acknowledge the message on the server before
                delivering it to the client. This example demonstrates how HornetQ allows this with
                an extra acknowledgement mode.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="producer-rate-limiting-example"></a>11.1.36.&nbsp;Message Producer Rate Limiting</h3></div></div><div></div></div><p>The <tt class="literal">producer-rte-limit</tt> example demonstrates how, with HornetQ,
                you can specify a maximum send rate at which a JMS message producer will send
                messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1982"></a>11.1.37.&nbsp;Queue</h3></div></div><div></div></div><p>A simple example demonstrating a JMS queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1987"></a>11.1.38.&nbsp;Message Redistribution</h3></div></div><div></div></div><p>The <tt class="literal">queue-message-redistribution</tt> example demonstrates message
                redistribution between queues with the same name deployed in different nodes of a
                cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1995"></a>11.1.39.&nbsp;Queue Requestor</h3></div></div><div></div></div><p>A simple example demonstrating a JMS queue requestor.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2000"></a>11.1.40.&nbsp;Queue with Message Selector</h3></div></div><div></div></div><p>The <tt class="literal">queue-selector</tt> example shows you how to selectively consume
                messages using message selectors with queue consumers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2008"></a>11.1.41.&nbsp;Reattach Node example</h3></div></div><div></div></div><p>The <tt class="literal">Reattach Node</tt> example shows how a client can try to reconnect to
               the same server instead of failing the connection immediately and
               notifying any user ExceptionListener objects. HornetQ can be configured to automatically
               retry the connection, and reattach to the server when it becomes available again across
               the network.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2016"></a>11.1.42.&nbsp;Request-Reply example</h3></div></div><div></div></div><p>A simple example showing the JMS request-response pattern.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.scheduled-message"></a>11.1.43.&nbsp;Scheduled Message</h3></div></div><div></div></div><p>The <tt class="literal">scheduled-message</tt> example shows you how to send a scheduled
                message to a JMS Queue with HornetQ. Scheduled messages won't get delivered until a
                specified time in the future.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2029"></a>11.1.44.&nbsp;Security</h3></div></div><div></div></div><p>The <tt class="literal">security</tt> example shows you how configure and use role based
                queue security with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="asynchronous-send-acknowledgements-example"></a>11.1.45.&nbsp;Send Acknowledgements</h3></div></div><div></div></div><p>The <tt class="literal">send-acknowledgements</tt> example shows you how to use
                HornetQ's advanced <span class="emphasis"><em>asynchronous send acknowledgements</em></span> feature
                to obtain acknowledgement from the server that sends have been received and
                processed in a separate stream to the sent messages. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2048"></a>11.1.46.&nbsp;SSL Transport</h3></div></div><div></div></div><p>The <tt class="literal">ssl-enabled</tt> shows you how to configure SSL with HornetQ to
                send and receive message.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2056"></a>11.1.47.&nbsp;Static Message Selector</h3></div></div><div></div></div><p>The <tt class="literal">static-selector</tt> example shows you how to configure a
                HornetQ core queue with static message selectors (filters).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2064"></a>11.1.48.&nbsp;Static Message Selector Using JMS</h3></div></div><div></div></div><p>The <tt class="literal">static-selector-jms</tt> example shows you how to configure a
                HornetQ queue with static message selectors (filters) using JMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2072"></a>11.1.49.&nbsp;Stomp</h3></div></div><div></div></div><p>The <tt class="literal">stomp</tt> example shows you how to configure a
                HornetQ server to send and receive Stomp messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2080"></a>11.1.50.&nbsp;Stomp Over Web Sockets</h3></div></div><div></div></div><p>The <tt class="literal">stomp-websockets</tt> example shows you how to configure a
                HornetQ server to send and receive Stomp messages directly from Web browsers (provided
                they support Web Sockets).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2088"></a>11.1.51.&nbsp;Symmetric Cluster</h3></div></div><div></div></div><p>The <tt class="literal">symmetric-cluster</tt> example demonstrates a symmetric cluster
                set-up with HornetQ.</p><p>HornetQ has extremely flexible clustering which allows you to set-up servers in
                many different topologies. The most common topology that you'll perhaps be familiar
                with if you are used to application server clustering is a symmetric cluster.</p><p>With a symmetric cluster, the cluster is homogeneous, i.e. each node is configured
                the same as every other node, and every node is connected to every other node in the
                cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2100"></a>11.1.52.&nbsp;Temporary Queue</h3></div></div><div></div></div><p>A simple example demonstrating how to use a JMS temporary queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2105"></a>11.1.53.&nbsp;Topic</h3></div></div><div></div></div><p>A simple example demonstrating a JMS topic.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="topic-hierarchy-example"></a>11.1.54.&nbsp;Topic Hierarchy</h3></div></div><div></div></div><p>HornetQ supports topic hierarchies. With a topic hierarchy you can register a
                subscriber with a wild-card and that subscriber will receive any messages sent to an
                address that matches the wild card.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2115"></a>11.1.55.&nbsp;Topic Selector 1</h3></div></div><div></div></div><p>The <tt class="literal">topic-selector-example1</tt> example shows you how to send
                message to a JMS Topic, and subscribe them using selectors with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2123"></a>11.1.56.&nbsp;Topic Selector 2</h3></div></div><div></div></div><p>The <tt class="literal">topic-selector-example2</tt> example shows you how to
                selectively consume messages using message selectors with topic consumers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.transaction-failover"></a>11.1.57.&nbsp;Transaction Failover With Data Replication</h3></div></div><div></div></div><p>The <tt class="literal">transaction-failover</tt> example demonstrates two servers coupled
                as a live-backup pair for high availability (HA), and a client using a transacted JMS
                session failing over from live to backup when the live server is
                crashed.</p><p>HornetQ implements failover of client connections between
                live and backup servers. This is implemented by the replication of data between
                live and backup nodes. When replication is configured and a live node crashes, the
                client connections can carry and continue to send and consume messages. When transacted
                sessions are used, once and only once message delivery is guaranteed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2141"></a>11.1.58.&nbsp;Transactional Session</h3></div></div><div></div></div><p>The <tt class="literal">transactional</tt> example shows you how to use a transactional
                Session with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2149"></a>11.1.59.&nbsp;XA Heuristic</h3></div></div><div></div></div><p>The <tt class="literal">xa-heuristic</tt> example shows you how to make an XA heuristic
                decision through HornetQ Management Interface. A heuristic decision is a unilateral
                decision to commit or rollback an XA transaction branch after it has been
                prepared.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2157"></a>11.1.60.&nbsp;XA Receive</h3></div></div><div></div></div><p>The <tt class="literal">xa-receive</tt> example shows you how message receiving behaves
                in an XA transaction in HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2165"></a>11.1.61.&nbsp;XA Send</h3></div></div><div></div></div><p>The <tt class="literal">xa-send</tt> example shows you how message sending behaves in an
                XA transaction in HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2173"></a>11.1.62.&nbsp;XA with Transaction Manager</h3></div></div><div></div></div><p>The <tt class="literal">xa-with-jta</tt> example shows you how to use JTA interfaces to
                control transactions with HornetQ.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2181"></a>11.2.&nbsp;Core API Examples</h2></div></div><div></div></div><p>To run a core example, simply <tt class="literal">cd</tt> into the appropriate example
            directory and type <tt class="literal">ant</tt></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.embedded"></a>11.2.1.&nbsp;Embedded</h3></div></div><div></div></div><p>This example shows how to embed the HornetQ server within your own code.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2196"></a>11.3.&nbsp;Java EE Examples</h2></div></div><div></div></div><p>Most of the Java EE examples can be run the following way. simply cd into the
            appropriate example directory and type <tt class="literal">ant deploy</tt>. This will create a
            new JBoss AS profile and start the server. When the server is started from a different
            window type <tt class="literal">ant run</tt> to run the example. Some examples require further
            steps, please refer to the examples documentation for further instructions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2207"></a>11.3.1.&nbsp;EJB/JMS Transaction</h3></div></div><div></div></div><p>An example that shows using an EJB and JMS together within a transaction.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2212"></a>11.3.2.&nbsp;HAJNDI (High Availability)</h3></div></div><div></div></div><p>A simple example demonstrating using JNDI within a cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2217"></a>11.3.3.&nbsp;Resource Adapter Configuration</h3></div></div><div></div></div><p>This example demonstrates how to configure several properties on the HornetQ JCA
                resource adaptor.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2222"></a>11.3.4.&nbsp;Resource Adapter Remote Server Configuration</h3></div></div><div></div></div><p>This example demonstrates how to configure the HornetQ resource adapter to talk to a remote HornetQ server</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples.javaee.jms-bridge"></a>11.3.5.&nbsp;JMS Bridge</h3></div></div><div></div></div><p>An example demonstrating the use of the HornetQ JMS bridge.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2232"></a>11.3.6.&nbsp;MDB (Message Driven Bean)</h3></div></div><div></div></div><p>A simple example of a message driven bean.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2237"></a>11.3.7.&nbsp;Servlet Transport</h3></div></div><div></div></div><p>An example of how to use the HornetQ servlet transport.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2242"></a>11.3.8.&nbsp;Servlet SSL Transport</h3></div></div><div></div></div><p>An example of how to use the HornetQ servlet transport over SSL.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xa-recovery-example"></a>11.3.9.&nbsp;XA Recovery</h3></div></div><div></div></div><p>An example of how XA recovery works within the JBoss Application server using
                HornetQ.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="client-classpath.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="wildcard-routing.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;10.&nbsp;The Client Classpath&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;12.&nbsp;Routing Messages With Wild Cards</td></tr></table></div></body></html>