<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;32.&nbsp;Application Server Integration and Java EE</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="HornetQ 2.1 User Manual"><link rel="up" href="index.html" title="HornetQ 2.1 User Manual"><link rel="previous" href="security.html" title="Chapter&nbsp;31.&nbsp;Security"><link rel="next" href="jms-bridge.html" title="Chapter&nbsp;33.&nbsp;The JMS Bridge"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;32.&nbsp;Application Server Integration and Java EE</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="security.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="jms-bridge.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appserver-integration"></a>Chapter&nbsp;32.&nbsp;Application Server Integration and Java EE</h2></div></div><div></div></div><p>HornetQ can be easily installed in JBoss Application Server 4 or later. For details on
        installing HornetQ in the JBoss Application Server please refer to quick-start guide.</p><p>Since HornetQ also provides a JCA adapter, it is also possible to integrate HornetQ
        as a JMS provider in other JEE compliant app servers. For instructions on how to integrate a
        remote JCA adaptor into another application sever, please consult the other application server's
        instructions.</p><p>A JCA Adapter basically controls the inflow of messages to Message-Driven Beans (MDBs) and the
        outflow of messages sent from other JEE components, e.g. EJBs and Servlets.</p><p>This section explains the basics behind configuring the different JEE components in the
        AS.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7276"></a>32.1.&nbsp;Configuring Message-Driven Beans</h2></div></div><div></div></div><p>The delivery of messages to an MDB using HornetQ is configured on the JCA Adapter via
            a configuration file <tt class="literal">ra.xml</tt> which can be found under the <tt class="literal">jms-ra.rar</tt> directory. By default this is configured to consume
            messages using an InVM connector from the instance of HornetQ running within the
            application server. The configuration properties are listed later in this chapter. </p><p>All MDBs however need to have the destination type and the destination configured.
            The following example shows how this can be done using annotations:</p><pre class="programlisting">@MessageDriven(name = "MDBExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue")
                     })
@ResourceAdapter("hornetq-ra.rar")
public class MDBExample implements MessageListener
{
   public void onMessage(Message message)...
}</pre><p>In this example you can see that the MDB will consume messages from a queue that is
            mapped into JNDI with the binding <tt class="literal">queue/testQueue</tt>. This queue must be
            preconfigured in the usual way using the HornetQ configuration files.</p><p>The <tt class="literal">ResourceAdapter</tt> annotation is used to specify which adaptor
            should be used. To use this you will need to import <tt class="literal">org.jboss.ejb3.annotation.ResourceAdapter</tt> for JBoss AS 5.X and later version which can be found in the
                <tt class="literal">jboss-ejb3-ext-api.jar</tt> which can be found in the JBoss
            repository. For JBoss AS 4.X, the annotation to use is <tt class="literal">org.jboss.annotation.ejb.ResourceAdaptor</tt>.</p><p>
             Alternatively you can add use a deployment descriptor and add something like
            the following to <tt class="literal">jboss.xml</tt></p><pre class="programlisting">&lt;message-driven&gt;
   &lt;ejb-name&gt;ExampleMDB&lt;/ejb-name&gt;
   &lt;resource-adapter-name&gt;hornetq-ra.rar&lt;/resource-adapter-name&gt;
&lt;/message-driven&gt;
</pre><p>You
            can also rename the hornetq-ra.rar directory to jms-ra.rar and neither the annotation or
            the extra descriptor information will be needed. If you do this you will need to edit
            the <tt class="literal">jms-ds.xml</tt> datasource file and change <tt class="literal">rar-name</tt>
            element.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>HornetQ is the default JMS provider for JBoss AS 6. Starting with this AS version, HornetQ resource
              adapter is named <tt class="literal">jms-ra.rar</tt> and you no longer need to annotate the MDB for the resource adapter name.</p></div><p>All the examples shipped with the HornetQ distribution use the annotation.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7331"></a>32.1.1.&nbsp;Using Container-Managed Transactions</h3></div></div><div></div></div><p>When an MDB is using Container-Managed Transactions (CMT), the delivery of the
                message is done within the scope of a JTA transaction. The commit or rollback of
                this transaction is controlled by the container itself. If the transaction is rolled
                back then the message delivery semantics will kick in (by default, it will try to
                redeliver the message up to 10 times before sending to a DLQ). Using annotations
                this would be configured as follows:</p><pre class="programlisting">@MessageDriven(name = "MDB_CMP_TxRequiredExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue")
                     })
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MDB_CMP_TxRequiredExample implements MessageListener
{
   public void onMessage(Message message)...
}</pre><p>The <tt class="literal">TransactionManagement</tt> annotation tells the container to manage the
            transaction. The <tt class="literal">TransactionAttribute</tt> annotation tells the container that a JTA
                transaction is required for this MDB. Note that the only other valid value for this
                is <tt class="literal">TransactionAttributeType.NOT_SUPPORTED</tt> which tells the
                container that this MDB does not support JTA transactions and one should not be
                created.</p><p>It is also possible to inform the container that it must rollback the transaction
                by calling <tt class="literal">setRollbackOnly</tt> on the <tt class="literal">MessageDrivenContext</tt>. The code for this would look something
                like:</p><pre class="programlisting">   @Resource
   MessageDrivenContextContext ctx;

   public void onMessage(Message message)
   {
      try
      {
         //something here fails
      }
      catch (Exception e)
      {
         ctx.setRollbackOnly();
      }
   }</pre><p>If you do not want the overhead of an XA transaction being created every time but
                you would still like the message delivered within a transaction (i.e. you are only
                using a JMS resource) then you can configure the MDB to use a local transaction.
                This would be configured as such:</p><pre class="programlisting">@MessageDriven(name = "MDB_CMP_TxLocalExample",
               activationConfig =
                     {
                           @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                           @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
                           @ActivationConfigProperty(propertyName = "useLocalTx", propertyValue = "true")
                     })
@TransactionManagement(value = TransactionManagementType.CONTAINER)
@TransactionAttribute(value = TransactionAttributeType.NOT_SUPPORTED)
@ResourceAdapter("hornetq-ra.rar")
public class MDB_CMP_TxLocalExample implements MessageListener
{
   public void onMessage(Message message)...
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7363"></a>32.1.2.&nbsp;Using Bean-Managed Transactions</h3></div></div><div></div></div><p>Message-driven beans can also be configured to use Bean-Managed Transactions
                (BMT). In this case a User Transaction is created. This would be configured as
                follows:</p><pre class="programlisting">@MessageDriven(name = "MDB_BMPExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
                        @ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Dups-ok-acknowledge")
                     })
@TransactionManagement(value= TransactionManagementType.BEAN)
@ResourceAdapter("hornetq-ra.rar")
public class MDB_BMPExample implements MessageListener
{
   public void onMessage(Message message)
}</pre><p>When using Bean-Managed Transactions the message delivery to the MDB will occur
                outside the scope of the user transaction and use the acknowledge mode specified by
                the user with the <tt class="literal">acknowledgeMode</tt> property. There are only 2
                acceptable values for this <tt class="literal">Auto-acknowledge</tt> and <tt class="literal">Dups-ok-acknowledge</tt>. Please note that because the message delivery is outside
                the scope of the transaction a failure within the MDB will not cause the message to
                be redelivered.</p><p>A user would control the lifecycle of the transaction something like the
                following:</p><pre class="programlisting">   @Resource
   MessageDrivenContext ctx;

   public void onMessage(Message message)
   {
      UserTransaction tx;
      try
      {
         TextMessage textMessage = (TextMessage)message;

         String text = textMessage.getText();

         UserTransaction tx = ctx.getUserTransaction();

         tx.begin();
         
         //do some stuff within the transaction
         
         tx.commit();

      }
      catch (Exception e)
      {
         tx.rollback();
      }
   }</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7385"></a>32.1.3.&nbsp;Using Message Selectors with Message-Driven Beans</h3></div></div><div></div></div><p>It is also possible to use MDBs with message selectors. To do this simple define
                your message selector as follows:</p><pre class="programlisting">@MessageDriven(name = "MDBMessageSelectorExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
                        @ActivationConfigProperty(propertyName = "messageSelector", propertyValue = "color = 'RED'")
                     })
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MDBMessageSelectorExample implements MessageListener
{
   public void onMessage(Message message)....
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7392"></a>32.2.&nbsp;Sending Messages from within JEE components</h2></div></div><div></div></div><p>The JCA adapter can also be used for sending messages. The Connection Factory to use
            is configured by default in the <tt class="literal">jms-ds.xml</tt> file and is mapped to
                <tt class="literal">java:/JmsXA</tt>. Using this from within a JEE component will mean
            that the sending of the message will be done as part of the JTA transaction being used
            by the component.</p><p>This means that if the sending of the message fails the overall transaction would
            rollback and the message be re-sent. Heres an example of this from within an
            MDB:</p><pre class="programlisting">@MessageDriven(name = "MDBMessageSendTxExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue")
                     })
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MDBMessageSendTxExample implements MessageListener
{
   @Resource(mappedName = "java:/JmsXA")
   ConnectionFactory connectionFactory;

   @Resource(mappedName = "queue/replyQueue")
   Queue replyQueue;

   public void onMessage(Message message)
   {
      Connection conn = null;
      try
      {
         //Step 9. We know the client is sending a text message so we cast
         TextMessage textMessage = (TextMessage)message;

         //Step 10. get the text from the message.
         String text = textMessage.getText();

         System.out.println("message " + text);

         conn = connectionFactory.createConnection();

         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

         MessageProducer producer = sess.createProducer(replyQueue);

         producer.send(sess.createTextMessage("this is a reply"));

      }
      catch (Exception e)
      {
         e.printStackTrace();
      }
      finally
      {
         if(conn != null)
         {
            try
            {
               conn.close();
            }
            catch (JMSException e)
            { 
            }
         }
      }
   }
   }</pre><p>In JBoss Application Server you can use the JMS JCA adapter for sending messages from
            EJBs (including Session, Entity and Message-Driven Beans), Servlets (including jsps) and
            custom MBeans.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7409"></a>32.3.&nbsp;MDB and Consumer pool size</h2></div></div><div></div></div><p>Most application servers, including JBoss, allow you to configure how many MDB's there are in a pool. In
         Jboss this is configured via the <tt class="literal">MaxPoolSize</tt> parameter in the ejb3-interceptors-aop.xml file. Configuring
         this has no actual effect on how many sessions/consumers there actually are created. This is because the Resource
      Adaptor implementation knows nothing about the application servers MDB implementation. So even if you set the MDB
         pool size to 1, 15 sessions/consumers will be created (this is the default). If you want to limit how many
         sessions/consumers are created then you need to set the <tt class="literal">maxSession</tt> parameter either on the
      resource adapter itself or via an an Activation Config Property on the MDB itself</p><pre class="programlisting">@MessageDriven(name = "MDBMessageSendTxExample",
               activationConfig =
                     {
                        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
                        @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
                        @ActivationConfigProperty(propertyName = "maxSession", propertyValue = "1")
                     })
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MyMDB implements MessageListener
{ ....}
      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7422"></a>32.4.&nbsp;Configuring the JCA Adaptor</h2></div></div><div></div></div><p>The Java Connector Architecture (JCA) Adapter is what allows HornetQ to be integrated
            with JEE components such as MDBs and EJBs. It configures how components such as MDBs
            consume messages from the HornetQ server and also how components such as EJBs or
            Servlets can send messages.</p><p>The HornetQ JCA adapter is deployed via the <tt class="literal">jms-ra.rar</tt> archive. The
            configuration of the adapter is found in this archive under <tt class="literal">META-INF/ra.xml</tt>.</p><p>The configuration will look something like the following:</p><pre class="programlisting">&lt;resourceadapter&gt;
      &lt;resourceadapter-class&gt;org.hornetq.ra.HornetQResourceAdapter&lt;/resourceadapter-class&gt;
      &lt;config-property&gt;
         &lt;description&gt;The transport type&lt;/description&gt;
         &lt;config-property-name&gt;ConnectorClassName&lt;/config-property-name&gt;
         &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
         &lt;config-property-value&gt;org.hornetq.core.remoting.impl.invm.InVMConnectorFactory&lt;/config-property-value&gt;
      &lt;/config-property&gt;
      &lt;config-property&gt;
         &lt;description&gt;The transport configuration. These values must be in the form of key=val;key=val;&lt;/description&gt;
         &lt;config-property-name&gt;ConnectionParameters&lt;/config-property-name&gt;
         &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
         &lt;config-property-value&gt;server-id=0&lt;/config-property-value&gt;
      &lt;/config-property&gt;

      &lt;outbound-resourceadapter&gt;
         &lt;connection-definition&gt;
            &lt;managedconnectionfactory-class&gt;org.hornetq.ra.HornetQRAManagedConnection
            Factory&lt;/managedconnectionfactory-class&gt;

            &lt;config-property&gt;
               &lt;description&gt;The default session type&lt;/description&gt;
               &lt;config-property-name&gt;SessionDefaultType&lt;/config-property-name&gt;
               &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
               &lt;config-property-value&gt;javax.jms.Queue&lt;/config-property-value&gt;
            &lt;/config-property&gt;
            &lt;config-property&gt;
               &lt;description&gt;Try to obtain a lock within specified number of seconds; less
               than or equal to 0 disable this functionality&lt;/description&gt;
               &lt;config-property-name&gt;UseTryLock&lt;/config-property-name&gt;
               &lt;config-property-type&gt;java.lang.Integer&lt;/config-property-type&gt;
               &lt;config-property-value&gt;0&lt;/config-property-value&gt;
            &lt;/config-property&gt;

            &lt;connectionfactory-interface&gt;org.hornetq.ra.HornetQRAConnectionFactory
            &lt;/connectionfactory-interface&gt;
            &lt;connectionfactororg.hornetq.ra.HornetQConnectionFactoryImplonFactoryImpl
            &lt;/connectionfactory-impl-class&gt;
            &lt;connection-interface&gt;javax.jms.Session&lt;/connection-interface&gt;
            &lt;connection-impl-class&gt;org.hornetq.ra.HornetQRASession
            &lt;/connection-impl-class&gt;
         &lt;/connection-definition&gt;
         &lt;transaction-support&gt;XATransaction&lt;/transaction-support&gt;
         &lt;authentication-mechanism&gt;
            &lt;authentication-mechanism-type&gt;BasicPassword
            &lt;/authentication-mechanism-type&gt;
            &lt;credential-interface&gt;javax.resource.spi.security.PasswordCredential
            &lt;/credential-interface&gt;
         &lt;/authentication-mechanism&gt;
         &lt;reauthentication-support&gt;false&lt;/reauthentication-support&gt;
      &lt;/outbound-resourceadapter&gt;

      &lt;inbound-resourceadapter&gt;
         &lt;messageadapter&gt;
            &lt;messagelistener&gt;
               &lt;messagelistener-type&gt;javax.jms.MessageListener&lt;/messagelistener-type&gt;
               &lt;activationspec&gt;
                  &lt;activationspec-class&gt;org.hornetq.ra.inflow.HornetQActivationSpec
                  &lt;/activationspec-class&gt;
                  &lt;required-config-property&gt;
                      &lt;config-property-name&gt;destination&lt;/config-property-name&gt;
                  &lt;/required-config-property&gt;
               &lt;/activationspec&gt;
            &lt;/messagelistener&gt;
         &lt;/messageadapter&gt;
      &lt;/inbound-resourceadapter&gt;

   &lt;/resourceadapter&gt;</pre><p>There are three main parts to this configuration.</p><div class="orderedlist"><ol type="1"><li><p>A set of global properties for the adapter</p></li><li><p>The configuration for the outbound part of the adapter. This is used for
                    creating JMS resources within EE components. </p></li><li><p>The configuration of the inbound part of the adapter. This is used for
                    controlling the consumption of messages via MDBs. </p></li></ol></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7451"></a>32.4.1.&nbsp;Global Properties</h3></div></div><div></div></div><p>The first element you see is <tt class="literal">resourceadapter-class</tt> which should
                be left unchanged. This is the HornetQ resource adapter class.</p><p>After that there is a list of configuration properties. This will be where most of
                the configuration is done. The first two properties configure the transport used by the adapter
                and the rest configure the connection factory itself.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>All connection factory properties will use the defaults if they are not provided, except
                  for the <tt class="literal">reconnectAttempts</tt> which will default to -1. This
                  signifies that the connection should attempt to reconnect on connection
                  failure indefinitely. This is only used when the adapter is configured to
                  connect to a remote server as an InVM connector can never fail.
                </p></div><p>The following table explains what each property is for.</p><div class="table"><a name="d0e7469"></a><p class="title"><b>Table&nbsp;32.1.&nbsp;Global Configuration Properties</b></p><table summary="Global Configuration Properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property Name</th><th>Property Type</th><th>Property Description</th></tr></thead><tbody><tr><td>ConnectorClassName</td><td>String</td><td>The Connector class name (see <a href="configuring-transports.html" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a> for more information)</td></tr><tr><td>ConnectionParameters</td><td>String</td><td>The transport configuration. These parameters must be in the form of
                                <tt class="literal">key1=val1;key2=val2;</tt> and will be specific to the connector used</td></tr><tr><td>useLocalTx</td><td>boolean</td><td>True will enable local transaction optimisation.</td></tr><tr><td>UserName</td><td>String</td><td>The user name to use when making a connection </td></tr><tr><td>Password</td><td>String</td><td>The password to use when making a connection</td></tr><tr><td>BackupConnectorClassName</td><td>String</td><td>The backup transport to use in case of failure of the live node</td></tr><tr><td>BackupConnectionParameters</td><td>String</td><td>The backup transport configuration parameters</td></tr><tr><td><a href="configuration-index.html#configuration.discovery-group.group-address">DiscoveryAddress</a></td><td>String</td><td>The discovery group address to use to autodetect a server</td></tr><tr><td><a href="configuration-index.html#configuration.discovery-group.group-port">DiscoveryPort</a></td><td>Integer</td><td>The port to use for discovery</td></tr><tr><td><a href="configuration-index.html#configuration.discovery-group.refresh-timeout">DiscoveryRefreshTimeout</a></td><td>Long</td><td>The timeout, in milliseconds, to refresh.</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.discovery-initial-wait-timeout">
                                  DiscoveryInitialWaitTimeout
                               </a></td><td>Long</td><td>The initial time to wait for discovery.</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.connection-load-balancing-policy-class-name">
                                  ConnectionLoadBalancingPolicyClassName</a></td><td>String</td><td>The load balancing policy class to use.</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.connection-ttl">ConnectionTTL</a></td><td>Long</td><td>The time to live (in milliseconds) for the connection.</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.call-timeout">CallTimeout</a></td><td>Long</td><td>the call timeout (in milliseconds) for each packet sent.</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.dups-ok-batch-size">DupsOKBatchSize</a></td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using
                                 DUPS_OK_ACKNOWLEDGE mode</td></tr></tbody></table></div><p>Continued..</p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><a href="configuration-index.html#configuration.connection-factory.transaction-batch-size">TransactionBatchSize</a></td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using a
                                 transactional session</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.consumer-window-size">ConsumerWindowSize</a></td><td>Integer</td><td>the window size (in bytes) for consumer flow control</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.consumer-max-rate">ConsumerMaxRate</a></td><td>Integer</td><td>the fastest rate a consumer may consume messages per second</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.confirmation-window-size">ConfirmationWindowSize</a></td><td>Integer</td><td>the window size (in bytes) for reattachment confirmations</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.producer-max-rate">ProducerMaxRate</a></td><td>Integer</td><td>the maximum rate of messages per second that can be sent</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.min-large-message-size">MinLargeMessageSize</a></td><td>Integer</td><td>the size (in bytes) before a message is treated as large </td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.block-on-acknowledge">BlockOnAcknowledge</a></td><td>Boolean</td><td>whether or not messages are acknowledged synchronously</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.block-on-non-durable-send">BlockOnNonDurableSend</a></td><td>Boolean</td><td>whether or not non-durable messages are sent synchronously</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.block-on-durable-send">BlockOnDurableSend</a></td><td>Boolean</td><td>whether or not durable messages are sent synchronously</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.auto-group">AutoGroup</a></td><td>Boolean</td><td>whether or not message grouping is automatically used</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.pre-acknowledge">PreAcknowledge</a></td><td>Boolean</td><td>whether messages are pre acknowledged by the server before
                                 sending</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.reconnect-attempts">ReconnectAttempts</a></td><td>Integer</td><td>maximum number of retry attempts, default for the resource adpater is -1 (infinite attempts)</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.retry-interval">RetryInterval</a></td><td>Long</td><td>the time (in milliseconds) to retry a connection after failing</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.retry-interval-multiplier">RetryIntervalMultiplier</a></td><td>Double</td><td>multiplier to apply to successive retry intervals</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.failover-on-server-shutdown">FailoverOnServerShutdown</a></td><td>Boolean</td><td>If true client will reconnect to another server if
                                available</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.client-id">ClientID</a></td><td>String</td><td>the pre-configured client ID for the connection factory</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.client-failure-check-period">ClientFailureCheckPeriod</a></td><td>Long</td><td>the period (in ms) after which the client will consider the
                                 connection failed after not receiving packets from the
                                 server</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.use-global-pools">UseGlobalPools</a></td><td>Boolean</td><td>whether or not to use a global thread pool for threads</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.scheduled-thread-pool-max-size">ScheduledThreadPoolMaxSize</a></td><td>Integer</td><td>the size of the <span class="emphasis"><em>scheduled thread</em></span> pool</td></tr><tr><td><a href="configuration-index.html#configuration.connection-factory.thread-pool-max-size">ThreadPoolMaxSize</a></td><td>Integer</td><td>the size of the thread pool</td></tr><tr><td>SetupAttempts</td><td>Integer</td><td>Number of attempts to setup a JMS connection (default is 10, -1 means to attempt infinitely). It is possible
                               that the MDB is deployed before the JMS resources are available. In that case, the resource
                               adapter will try to setup several times until the resources are available. This applies only for inbound connections</td></tr><tr><td>SetupInterval</td><td>Long</td><td>Interval in milliseconds between consecutive attemps to setup a JMS connection (default is 2000m). This applies only for inbound connections</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7788"></a>32.4.2.&nbsp;Adapter Outbound Configuration</h3></div></div><div></div></div><p>The outbound configuration should remain unchanged as they define connection
                factories that are used by Java EE components. These Connection Factories can be
                defined inside a configuration file that matches the name <tt class="literal">*-ds.xml</tt>. You'll find a default <tt class="literal">jms-ds.xml</tt>
                configuration under the <tt class="literal">hornetq</tt> directory in the JBoss AS
                deployment. The connection factories defined in this file inherit their
                properties from the main <tt class="literal">ra.xml</tt> configuration but can also be
                overridden. The following example shows how to override them.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Please note that this configuration only applies when HornetQ resource adapter is installed in 
                JBoss Application Server. If you are using another JEE application
                server please refer to your application servers documentation for how to do
                this.</p></div><pre class="programlisting">&lt;tx-connection-factory&gt;
      &lt;jndi-name&gt;RemoteJmsXA&lt;/jndi-name&gt;
      &lt;xa-transaction/&gt;
      &lt;rar-name&gt;jms-ra.rar&lt;/rar-name&gt;
      &lt;connection-definition&gt;org.hornetq.ra.HornetQRAConnectionFactory
&lt;/connection-definition&gt;
      &lt;config-property name="SessionDefaultType" type="String"&gt;javax.jms.Topic
      &lt;/config-property&gt;
      &lt;config-property name="ConnectorClassName" type="String"&gt;
        org.hornetq.core.remoting.impl.netty.NettyConnectorFactory
      &lt;/config-property&gt;
      &lt;config-property name="ConnectionParameters" type="String"&gt;
          port=5445&lt;/config-property&gt;
      &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;
&lt;/tx-connection-factory&gt;</pre><p>In this example the connection factory will be bound to JNDI with the name
                    <tt class="literal">RemoteJmsXA</tt> and can be looked up in the usual way using JNDI
                or defined within the EJB or MDB as such:</p><pre class="programlisting">@Resource(mappedName="java:/RemoteJmsXA")
private ConnectionFactory connectionFactory;</pre><p>The <tt class="literal">config-property</tt> elements are what overrides those in the
                    <tt class="literal">ra.xml</tt> configuration file. Any of the elements pertaining to the
                connection factory can be overridden here.</p><p>The outbound configuration also defines additional properties in addition to the global configuration properties.</p><div class="table"><a name="d0e7827"></a><p class="title"><b>Table&nbsp;32.2.&nbsp;Outbound Configuration Properties</b></p><table summary="Outbound Configuration Properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property Name</th><th>Property Type</th><th>Property Description</th></tr></thead><tbody><tr><td>SessionDefaultType</td><td>String</td><td>the default session type</td></tr><tr><td>UseTryLock</td><td>Integer</td><td>try to obtain a lock within specified number of seconds. less
                            than or equal to 0 disable this functionality</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7857"></a>32.4.3.&nbsp;Adapter Inbound Configuration</h3></div></div><div></div></div><p>The inbound configuration should again remain unchanged. This controls what
                forwards messages onto MDBs. It is possible to override properties on the MDB by
                adding an activation configuration to the MDB itself. This could be used to
                configure the MDB to consume from a different server.</p><p>The inbound configuration also defines additional properties in addition to the global configuration properties.</p><div class="table"><a name="d0e7864"></a><p class="title"><b>Table&nbsp;32.3.&nbsp;Inbound Configuration Properties</b></p><table summary="Inbound Configuration Properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property Name</th><th>Property Type</th><th>Property Description</th></tr></thead><tbody><tr><td>Destination</td><td>String</td><td>JNDI name of the destination</td></tr><tr><td>DestinationType</td><td>String</td><td>type of the destination, either <tt class="literal">javax.jms.Queue</tt> or <tt class="literal">javax.jms.Topic</tt>
                                 (default is javax.jms.Queue)</td></tr><tr><td>AcknowledgeMode</td><td>String</td><td>The Acknowledgment mode, either <tt class="literal">Auto-acknowledge</tt> or <tt class="literal">Dups-ok-acknowledge</tt>
                                (default is Auto-acknowledge). <tt class="literal">AUTO_ACKNOWLEDGE</tt> and <tt class="literal">DUPS_OK_ACKNOWLEDGE</tt> are acceptable values.</td></tr><tr><td>MaxSession</td><td>Integer</td><td>Maximum number of session created by this inbound configuration (default is 15)</td></tr><tr><td>MessageSelector</td><td>String</td><td>the message selector of the consumer</td></tr><tr><td>SubscriptionDurability</td><td>String</td><td>Type of the subscription, either <tt class="literal">Durable</tt> or <tt class="literal">NonDurable</tt></td></tr><tr><td>SubscriptionName</td><td>String</td><td>Name of the subscription</td></tr><tr><td>TransactionTimeout</td><td>Long</td><td>The transaction timeout in milliseconds (default is 0, the transaction does not timeout)</td></tr><tr><td>UseJNDI</td><td>Boolean</td><td>Whether or not use JNDI to look up the destination (default is true)</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7966"></a>32.4.4.&nbsp;Configuring the adapter to use a standalone HornetQ Server</h3></div></div><div></div></div><p>Sometime you may want your messaging server on a different machine or separate from the application server.
          If this is the case you will only need the hornetq client libs installed. This section explains what config to create
          and what jar dependencies are needed.</p><div class="section" lang="en"><div class="titlepage"><div></div><div></div></div><p>There are two configuration files needed to do this, one for the incoming adapter used for MDB's
                and one for outgoing connections managed by the JCA managed connection pool used by outgoing JEE components
             wanting outgoing connections.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e7974"></a>32.4.4.1.1.&nbsp;Configuring the Incoming Adaptor</h5></div></div><div></div></div><p>Firstly you will need to create directory under the
                   <tt class="literal">deploy</tt>
                   directory ending in
                   <tt class="literal">.rar.
                      For this example we will name the directory <tt class="literal">hornetq-ra.rar</tt>. This detail is
                      important as
                      the name of directory is referred to by the MDB's and the outgoing configuration.
                   </tt>
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The jboss default for this is <tt class="literal">jms-ra.rar</tt>, If you don't want to have to
                      configure your
                      MDB's you can use this but you may need to remove the generic adaptor that uses this.
                   </p></div><p>Under the
                   <tt class="literal">hornetq-ra.rar</tt>
                   directory you will need to create a
                   <tt class="literal">META-INF</tt>
                   directory into which you should create an
                   <tt class="literal">ra.xml</tt>
                   configuration file. You can find a template
                   for the
                   <tt class="literal">ra.xml</tt>
                   under the config directory of the HornetQ distribution.
                </p><p>To configure MDB's to consume messages from a remote HornetQ server you need to edit the
                   <tt class="literal">ra.xml</tt>
                   file under
                   <tt class="literal">deploy/hornet-ra.rar/META-INF</tt>
                   and change the transport type to
                   use a netty connector (instead of the invm connector that is defined) and configure its transport
                   params.
                   Heres an example of what this would look like:
                </p><pre class="programlisting">
                   &lt;resourceadapter-class&gt;org.hornetq.ra.HornetQResourceAdapter&lt;/resourceadapter-class&gt;
                   &lt;config-property&gt;
                   &lt;description&gt;The transport type&lt;/description&gt;
                   &lt;config-property-name&gt;ConnectorClassName&lt;/config-property-name&gt;
                   &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
                   &lt;config-property-value&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/config-property-value&gt;
                   &lt;/config-property&gt;
                   &lt;config-property&gt;
                   &lt;description&gt;The transport configuration. These values must be in the form of key=val;key=val;&lt;/description&gt;
                   &lt;config-property-name&gt;ConnectionParameters&lt;/config-property-name&gt;
                   &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
                   &lt;config-property-value&gt;host=127.0.0.1;port=5446&lt;/config-property-value&gt;
                   &lt;/config-property&gt;
                </pre><p>This configures the resource adapter to connect to a server running on localhost listening on port
                   5446
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8020"></a>32.4.4.1.2.&nbsp;Configuring the outgoing adaptor</h5></div></div><div></div></div><p>You will also need to configure the outbound connection by creating a <tt class="literal">hornetq-ds.xml</tt>
                   and placing it under any directory that will be deployed under the <tt class="literal">deploy</tt> directory.
                   In a standard HornetQ jboss configuration this would be under <tt class="literal">horneq</tt> or <tt class="literal">hornetq.sar</tt>
                   but you can place it where ever you like. Actually as long as it ends in <tt class="literal">-ds.xml</tt> you can
                   call it anything you like. You can again find a template for this file under the config directory of the
                   HornetQ distribution but called <tt class="literal">jms-ds.xml</tt> which is the jboss default.
                </p><p>The following example shows a sample configuration</p><pre class="programlisting">
                   &lt;tx-connection-factory&gt;
                   &lt;jndi-name&gt;RemoteJmsXA&lt;/jndi-name&gt;
                   &lt;xa-transaction/&gt;
                   &lt;rar-name&gt;hornetq-ra.rar&lt;/rar-name&gt;
                   &lt;connection-definition&gt;org.hornetq.ra.HornetQRAConnectionFactory&lt;/connection-definition&gt;
                   &lt;config-property name="SessionDefaultType" type="java.lang.String"&gt;javax.jms.Topic&lt;/config-property&gt;
                   &lt;config-property name="ConnectorClassName" type="java.lang.String"&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/config-property&gt;
                   &lt;config-property name="ConnectionParameters" type="java.lang.String"&gt;host=127.0.0.1;port=5446&lt;/config-property&gt;
                   &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;
                   &lt;/tx-connection-factory&gt;
                </pre><p>Again you will see that this uses the netty connector type and will connect to the HornetQ server
                   running on localhost and listening on port 5446. JEE components can access this by using JNDI and looking
                   up the connection factory using JNDI using <tt class="literal">java:/RemoteJmsXA</tt>, you can see that this
                   is defined under the<tt class="literal">jndi-name</tt> attribute. You will also note that the outgoing connection
                   will be created by the resource adaptor configured under the directory <tt class="literal">hornetq-ra.rar</tt> as explained in the last section.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8058"></a>32.4.4.1.3.&nbsp;Jar dependencies</h5></div></div><div></div></div><p>This is a list of the HornetQ and third party jars needed</p><div class="table"><a name="d0e8063"></a><p class="title"><b>Table&nbsp;32.4.&nbsp;Jar Dependencies</b></p><table summary="Jar Dependencies" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Jar Name</th><th>Description</th><th>Location</th></tr></thead><tbody><tr><td>hornetq-ra.jar</td><td>The HornetQ resource adaptor classes</td><td>deploy/hornetq-ra.rar or equivelant</td></tr><tr><td>hornetq-core-client.jar</td><td>The HornetQ core client classes</td><td>either in the config lib, i.e. default/lib or the common lib dir, i.e. $JBOSS_HOME/common lib </td></tr><tr><td>hornetq-jms-client.jar</td><td>The HornetQ JMS classes</td><td>as above</td></tr><tr><td>netty.jar</td><td>The Netty transport classes</td><td>as above</td></tr></tbody></table></div></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8107"></a>32.5.&nbsp;High Availability JNDI (HA-JNDI)</h2></div></div><div></div></div><p>If you are using JNDI to look-up JMS queues, topics and connection factories from a
            cluster of servers, it is likely you will want to use HA-JNDI so that your JNDI look-ups
            will continue to work if one or more of the servers in the cluster fail.</p><p>HA-JNDI is a JBoss Application Server service which allows you to use JNDI from
            clients without them having to know the exact JNDI connection details of every server in
            the cluster. This service is only available if using a cluster of JBoss Application
            Server instances.</p><p>To use it use the following properties when connecting to JNDI.</p><pre class="programlisting">Hashtable&lt;String, String&gt; jndiParameters = new Hashtable&lt;String, String&gt;();
jndiParameters.put("java.naming.factory.initial", 
    "org.jnp.interfaces.NamingContextFactory");
jndiParameters.put("java.naming.factory.url.pkgs=", 
    "org.jboss.naming:org.jnp.interfaces");

initialContext = new InitialContext(jndiParameters);</pre><p>For more information on using HA-JNDI see the <a href="http://www.jboss.org/file-access/default/members/jbossas/freezone/docs/Clustering_Guide/5/html/clustering-jndi.html" target="_top">JBoss Application Server clustering documentation</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xa-recovery"></a>32.6.&nbsp;XA Recovery</h2></div></div><div></div></div><p><span class="emphasis"><em>XA recovery</em></span> deals with system or application failures to ensure
            that of a transaction are applied consistently to all resources affected by the
            transaction, even if any of the application processes or the machine hosting them crash
            or lose network connectivity. For more information on XA Recovery,please refer to <a href="http://www.jboss.org/community/wiki/JBossTransactions" target="_top">JBoss
                Transactions</a>.</p><p>When HornetQ is integrated with JBoss AS, it can take advantage of JBoss Transactions
            to provide recovery of messaging resources. If messages are involved in a XA
            transaction, in the event of a server crash, the recovery manager will ensure that the
            transactions are recovered and the messages will either be committed or rolled back
            (depending on the transaction outcome) when the server is restarted.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8134"></a>32.6.1.&nbsp;XA Recovery Configuration</h3></div></div><div></div></div><p>To enable HornetQ's XA Recovery, the Recovery Manager must be configured to connect
                to HornetQ to recover its resources. The following property must be added to the
                    <tt class="literal">jta</tt> section of <tt class="literal">conf/jbossts-properties.xml</tt>
                of JBoss AS profiles:</p><pre class="programlisting">
&lt;properties depends="arjuna" name="jta"&gt;
   ...
                     
   &lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HornetQ1"
                value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;[connection configuration]"/&gt;
&lt;/properties&gt;
            </pre><p>The <tt class="literal">[connection configuration]</tt> contains all the information
                required to connect to HornetQ node under the form <tt class="literal">[connector factory class
                    name],[user name], [password], [connector parameters]</tt>. </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">[connector factory class name]</tt> corresponds to the name
                        of the <tt class="literal">ConnectorFactory</tt> used to connect to HornetQ.
                        Values can be <tt class="literal">org.hornetq.core.remoting.impl.invm.InVMConnectorFactory</tt> or
                            <tt class="literal">org.hornetq.core.remoting.impl.netty.NettyConnectorFactory</tt></p></li><li><p><tt class="literal">[user name]</tt> is the user name to create a client
                        session. It is optional</p></li><li><p><tt class="literal">[password]</tt> is the password to create a client session.
                        It is mandatory only if the user name is specified</p></li><li><p><tt class="literal">[connector parameters]</tt> is a list of comma-separated
                        key=value pair which are passed to the connector factory (see <a href="configuring-transports.html" title="Chapter&nbsp;16.&nbsp;Configuring the Transport">Chapter&nbsp;16, <i>Configuring the Transport</i></a> for a list of the transport
                        parameters).</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>HornetQ must have a valid acceptor which corresponds to the connector
                    specified in <tt class="literal">conf/jbossts-properties.xml</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8192"></a>32.6.1.1.&nbsp;Configuration Settings</h4></div></div><div></div></div><p>If HornetQ is configured with a default in-vm acceptor:</p><pre class="programlisting">
&lt;acceptor name="in-vm"&gt;
    &lt;factory-class&gt;org.hornetq.core.remoting.impl.invm.InVMAcceptorFactory&lt;/factory-class&gt;
&lt;/acceptor&gt;
                </pre><p>the corresponding configuration in <tt class="literal">conf/jbossts-properties.xml</tt> is:</p><pre class="programlisting">
&lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HORNETQ1"
   value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;org.hornetq.core.remoting.impl.invm.InVMConnectorFactory"/&gt;        			
                </pre><p>If it is now configured with a netty acceptor on a non-default port:</p><pre class="programlisting">
&lt;acceptor name="netty"&gt;
    &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
    &lt;param key="port" value="8888"/&gt;
&lt;/acceptor&gt;
                </pre><p>the corresponding configuration in <tt class="literal">conf/jbossts-properties.xml</tt> is:</p><pre class="programlisting">
&lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HORNETQ1"
       value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory, , , port=8888"/&gt;        			                    
                </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Note the additional commas to skip the user and password before connector
                        parameters</p></div><p>If the recovery must use <tt class="literal">admin, adminpass</tt>, the
                    configuration would have been:</p><pre class="programlisting">
                    &lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HORNETQ1"
                           value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory, admin, adminpass, port=8888"/&gt;        			                    
                </pre><p>Configuring HornetQ with an invm acceptor and configuring the Recovery Manager
                    with an invm connector is the recommended way to enable XA Recovery.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8229"></a>32.6.2.&nbsp;Example</h3></div></div><div></div></div><p>See <a href="examples.html#xa-recovery-example" title="11.3.9.&nbsp;XA Recovery">Section&nbsp;11.3.9, &#8220;XA Recovery&#8221;</a> which shows how to configure XA Recovery
                and recover messages after a server crash.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="security.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="jms-bridge.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;31.&nbsp;Security&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;33.&nbsp;The JMS Bridge</td></tr></table></div></body></html>